<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo使用教程与常用命令</title>
    <url>/2020/05/12/Hexo%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>欢迎使用<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! 更多信息可以查看<a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo官方文档</a> 。如果你在使用过程中遇到任何问题，可以在这<a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">提问</a> 或者在<a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a> 上留言，这篇文章简单介绍下Hexo的使用以及常用的命令。</p>
<a id="more"></a>

<h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><h3 id="创建一篇文章"><a href="#创建一篇文章" class="headerlink" title="创建一篇文章"></a>创建一篇文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"文章标题"</span></span><br><span class="line">或者</span><br><span class="line">$ hexo n <span class="string">"文章标题"</span></span><br></pre></td></tr></table></figure>

<p>更多信息: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">writing</a></p>
<h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">或者</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>更多信息: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">或者</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p>更多信息: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="部署到远端"><a href="#部署到远端" class="headerlink" title="部署到远端"></a>部署到远端</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">或者</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<p>更多信息:: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h2 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h2><h3 id="获取主题"><a href="#获取主题" class="headerlink" title="获取主题"></a>获取主题</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/holysll/hexo-theme-ayer</span><br></pre></td></tr></table></figure>

<h3 id="修改主题配置"><a href="#修改主题配置" class="headerlink" title="修改主题配置"></a>修改主题配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">vi _config.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: hexo-theme-ayer</span><br></pre></td></tr></table></figure>

<h3 id="清除缓存并部署"><a href="#清除缓存并部署" class="headerlink" title="清除缓存并部署"></a>清除缓存并部署</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>GitHub</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言知识点总结归纳</title>
    <url>/2020/05/12/Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>本文主要对python语言基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。</p>
</blockquote>
<a id="more"></a>

<div style='display: none'>

<!-- TOC -->

<ul>
<li><a href="#1-python语言的特性">1. Python语言的特性</a></li>
<li><a href="#2-python语言相比其他语言的优点和缺点">2. python语言相比其他语言的优点和缺点</a></li>
<li><a href="#3-python中的元类metaclass">3. python中的元类metaclass</a></li>
<li><a href="#4-staticmethod和classmethod和实例方法">4. @staticmethod和@classmethod和实例方法</a></li>
<li><a href="#5-单例模式">5. 单例模式</a></li>
<li><a href="#6-python常用库">6. python常用库</a></li>
<li><a href="#7-python中的类型转换">7. python中的类型转换</a></li>
<li><a href="#8-文件流操作">8. 文件流操作</a></li>
<li><a href="#9-__new__-和-__init__的区别">9. <strong>new</strong> 和 <strong>init</strong>的区别</a></li>
<li><a href="#10-python内存管理与垃圾回收机制">10. python内存管理与垃圾回收机制</a></li>
<li><a href="#11-python2x-与python3x的主要区别">11. python2.x 与python3.x的主要区别</a></li>
<li><a href="#12-如何将python2的代码迁移到python3">12. 如何将python2的代码迁移到python3</a></li>
<li><a href="#13-python新式类和旧式类的区别">13. python新式类和旧式类的区别</a></li>
<li><a href="#14-鸭子类型">14. 鸭子类型</a></li>
<li><a href="#15-python自省">15. python自省</a></li>
<li><a href="#16-猴子补丁技术">16. 猴子补丁技术</a></li>
<li><a href="#17-python语法糖有哪些">17. python语法糖有哪些</a></li>
<li><a href="#18-迭代器和生成器">18. 迭代器和生成器</a></li>
<li><a href="#19-闭包">19. 闭包</a></li>
<li><a href="#20-装饰器">20. 装饰器</a></li>
<li><a href="#21-浅拷贝与深拷贝">21. 浅拷贝与深拷贝</a></li>
<li><a href="#22-设计模式">22. 设计模式</a><ul>
<li><a href="#1-工厂模式">1. 工厂模式</a></li>
<li><a href="#2-构造模式">2. 构造模式</a></li>
<li><a href="#4-原型模式">4. 原型模式</a></li>
<li><a href="#5-单例模式-1">5. 单例模式</a></li>
<li><a href="#6-装饰模式">6. 装饰模式</a></li>
<li><a href="#7-代理模式">7. 代理模式</a></li>
<li><a href="#8-适配器模式">8. 适配器模式</a></li>
<li><a href="#9-外观模式">9. 外观模式</a></li>
<li><a href="#10-享元模式">10. 享元模式</a></li>
<li><a href="#11-桥接模式">11. 桥接模式</a></li>
<li><a href="#12-组合模式">12. 组合模式</a></li>
<li><a href="#13-命令模式">13. 命令模式</a></li>
<li><a href="#14-访问者模式">14. 访问者模式</a></li>
<li><a href="#15-责任链模式">15. 责任链模式</a></li>
<li><a href="#16-备忘录模式">16. 备忘录模式</a></li>
<li><a href="#17-中介者模式">17. 中介者模式</a></li>
<li><a href="#18-状态模式">18. 状态模式</a></li>
<li><a href="#19-模板方法模式">19. 模板方法模式</a></li>
<li><a href="#20-解释器模式">20. 解释器模式</a></li>
<li><a href="#21-迭代器模式">21. 迭代器模式</a></li>
<li><a href="#22-观察者模式">22. 观察者模式</a></li>
<li><a href="#23-策略模式">23. 策略模式</a></li>
</ul>
</li>
<li><a href="#23-gil全局解释器锁">23. GIL全局解释器锁</a></li>
<li><a href="#24-函数是一等公民">24. 函数是一等公民？</a></li>
<li><a href="#25-函数与方法的区别">25. 函数与方法的区别</a></li>
<li><a href="#26-range与xrange的区别">26. range与Xrange的区别</a></li>
<li><a href="#27-search与match的区别">27. search与match的区别</a></li>
<li><a href="#28-面向对象编程oop">28. 面向对象编程OOP</a></li>
<li><a href="#29-面向切面编程aop">29. 面向切面编程AOP</a></li>
<li><a href="#30-封装">30. 封装</a></li>
<li><a href="#31-继承">31. 继承</a></li>
<li><a href="#32-多态与多态性">32. 多态与多态性</a></li>
<li><a href="#33-重载">33. 重载</a></li>
<li><a href="#34-函数式编程">34. 函数式编程</a></li>
<li><a href="#35-python中的高阶函数">35. python中的高阶函数</a></li>
<li><a href="#36-返回函数">36. 返回函数</a></li>
<li><a href="#37-匿名函数">37. 匿名函数</a></li>
<li><a href="#38-偏函数">38. 偏函数</a></li>
<li><a href="#39-元编程">39. 元编程</a></li>
<li><a href="#40-捕获异常">40. 捕获异常</a></li>
<li><a href="#41-python常见的内置数据结构">41. python常见的内置数据结构</a></li>
<li><a href="#42-python-bytes与bytearray">42. python bytes与bytearray</a></li>
<li><a href="#43-字符串和字节串的区别">43. 字符串和字节串的区别</a></li>
<li><a href="#44-字符集字符编码">44. 字符集（字符编码）</a></li>
<li><a href="#45-python中参数类型有哪些">45. python中参数类型有哪些</a></li>
<li><a href="#46-args和kwargs的区别">46. <em>args和*</em>kwargs的区别</a></li>
<li><a href="#47-实参和形参的区别">47. 实参和形参的区别</a></li>
<li><a href="#48-python中函数传参过程">48. python中函数传参过程</a></li>
<li><a href="#49-python中可变对象和不可变对象">49. python中可变对象和不可变对象</a></li>
<li><a href="#50-python中正则使用方式">50. python中正则使用方式</a></li>
<li><a href="#51-numpyscipypanadas的区别">51. Numpy、Scipy、Panadas的区别</a></li>
<li><a href="#52-python中反射机制">52. python中反射机制</a></li>
<li><a href="#53-python中如何管理依赖">53. python中如何管理依赖</a></li>
<li><a href="#54-如何分析python代码性能">54. 如何分析python代码性能</a></li>
<li><a href="#55-列表的顺序访问和随机访问">55. 列表的顺序访问和随机访问</a></li>
<li><a href="#56-随机函数">56. 随机函数</a></li>
<li><a href="#57-python中单下划线和双下划线">57. Python中单下划线和双下划线</a></li>
<li><a href="#58-python的作用域以及python搜索变量的顺序">58. Python的作用域以及Python搜索变量的顺序</a></li>
<li><a href="#59-编码与解码">59. 编码与解码</a></li>
<li><a href="#60-字符串格式化">60. 字符串格式化</a></li>
<li><a href="#61-增量赋值">61. 增量赋值</a></li>
<li><a href="#62-exec对字符串执行和eval对字符串求值">62. exec对字符串执行和eval对字符串求值</a></li>
<li><a href="#63-raise语句的作用">63. raise语句的作用</a></li>
<li><a href="#64-yield语句的作用">64. yield语句的作用</a></li>
<li><a href="#65-协程与生成器">65. 协程与生成器</a></li>
<li><a href="#66-python-decimal精确计算">66. python decimal精确计算</a></li>
<li><a href="#67-模块和代码块">67. 模块和代码块</a></li>
<li><a href="#68-上下文管理器">68. 上下文管理器</a></li>
</ul>
<!-- /TOC -->

</div>

<h2 id="1-Python语言的特性"><a href="#1-Python语言的特性" class="headerlink" title="1. Python语言的特性"></a>1. Python语言的特性</h2><p>   Python是一种解释型语言，不需要再运行之前进行编译。<br>   Python是一种动态类型语言，不需要声明变量的类型。<br>   python适合面向对象编程，允许类的定义以及组合和继承。  </p>
<h2 id="2-python语言相比其他语言的优点和缺点"><a href="#2-python语言相比其他语言的优点和缺点" class="headerlink" title="2. python语言相比其他语言的优点和缺点"></a>2. python语言相比其他语言的优点和缺点</h2><ul>
<li><p><strong>优点</strong></p>
<ul>
<li>简单易懂，灵活简洁</li>
<li>强大的标准库和三方库</li>
<li>活跃的社区，许多开源项目</li>
<li>开发效率高，迭代便捷</li>
<li>应用领域广泛，Web开发、网络编程、自动化运维、Linux系统管理、数据分析、科学计算、人工智能、机器学习</li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li>执行效率较差,</li>
<li>异步生态不完善，相关的库较少(tornado)</li>
<li>GIL的存在，无法充分利用多核的特性</li>
</ul>
</li>
</ul>
<h2 id="3-python中的元类metaclass"><a href="#3-python中的元类metaclass" class="headerlink" title="3. python中的元类metaclass"></a>3. python中的元类metaclass</h2><blockquote>
<p>不会很常用，在ORM这种复杂结构中晦遇到，同时在看一些框架源代码的过程中可能会遇到很多元类的实例，看起来很晦涩。推荐<a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python" target="_blank" rel="noopener">Stack overflow</a> 一些专业解答，也可以参考下<a href="https://www.cnblogs.com/tkqasn/p/6524879.html" target="_blank" rel="noopener">这篇博客</a>的深刻理解，很详细。</p>
</blockquote>
<ul>
<li><strong>str是用来创建字符串对象的类</strong></li>
<li><strong>int是用来创建整数对象的类</strong></li>
<li><strong>type就是创建类对象的类</strong></li>
</ul>
<blockquote>
<p>通过type函数动态创建类</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># type的语法</span></span><br><span class="line">type(class_name, class_parents, class_attr_dict)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    class_name: 类名</span></span><br><span class="line"><span class="string">    class_parents: 父类的元组(针对集成的情况，可为空)</span></span><br><span class="line"><span class="string">    class_attr_dict: 包函属性的字典</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    MyClass = type(<span class="string">'MyClass'</span>, (), &#123;<span class="string">'foo'</span>:<span class="literal">True</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>元类：就是能够创建python中类这种对象的东西，如type就是Python的内建元类</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MyClass = MetaClass()  <span class="comment"># 元类的创建</span></span><br><span class="line">my_class = MyClass()  <span class="comment"># 类的实例</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上Myclass就是通过type()来创建出的MyClass类，它是type()类的一个实例。<br>同时，MyClass本身也是累，也可以创建自己的实例my_class。</p>
</blockquote>
<ul>
<li><strong><strong>metaclass</strong></strong></li>
</ul>
<blockquote>
<p>可以再写一个类的时候为其添加<strong>metaclass</strong>属性，这样就定义了这个类的元类。<strong>metaclass</strong>实际上可以被任意调用，它并不需要是一个正式的类。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># py2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = something</span><br><span class="line"></span><br><span class="line"><span class="comment"># py3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(metaclass=something)</span>:</span></span><br><span class="line">    __metaclass__ = something</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>自定义元类</strong></li>
</ul>
<blockquote>
<p>元类的主要目的为了当创建类时能够自动改变类，通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。</p>
</blockquote>
<ul>
<li>可以使用函数当做元类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 元类通常会将你传给type的参数作为自己的参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upper_attr</span><span class="params">(future_class_name, future_class_parents, future_class_attr)</span>:</span></span><br><span class="line">    <span class="string">"""返回一个类对象，将属性都转为大写形式"""</span></span><br><span class="line">    <span class="comment"># 选择所有不以'__'开头的属性</span></span><br><span class="line">    attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> future_class_attr.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>))</span><br><span class="line">    <span class="comment"># 将他们转化为大写形式</span></span><br><span class="line">    uppercase_attr = dict&#123;(name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs&#125;</span><br><span class="line">    <span class="comment"># 通过type来做类对象的创建</span></span><br><span class="line">    <span class="keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)  <span class="comment"># 返回一个对象，这个对象是个类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(metaclass=upper_attr)</span>:</span></span><br><span class="line">    _metaclass__ = upper_attr</span><br><span class="line">    bar = <span class="string">'bip'</span></span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, <span class="string">'bar'</span>))  <span class="comment"># False</span></span><br><span class="line">print(hasattr(Foo, <span class="string">'BAR'</span>))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line">print(f.BAR)  <span class="comment"># 'bip'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用class来当做元类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaClass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr)</span>:</span></span><br><span class="line">        attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> future_class_attr.items() <span class="keyword">if</span> <span class="keyword">not</span> name.starswith(<span class="string">'__'</span>))</span><br><span class="line">        uppercase_attr = dict((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 复用type.__new__方法，OOP编程。</span></span><br><span class="line">    <span class="comment"># 由于type是元类也是类，本身也是通过__new__方法生成实例，只不过这个实例是一个类。</span></span><br><span class="line">    <span class="keyword">return</span> tpye.__new__(upperattr_metaclass, future_classs_name, future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>真实业务场景下的元类</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaClass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, dct)</span>:</span></span><br><span class="line">        attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> dct.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>))</span><br><span class="line">        uppercase_attr = dict((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, uppercase_attr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># supper继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaClass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, dct)</span>:</span></span><br><span class="line">        attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> dct.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>))</span><br><span class="line">        uppercase_attr = dict((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line">        <span class="keyword">return</span> supper(UpperAttrMetaClass, cls).__new__(cls, name, bases, uppercase_attr)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用元类创建ORM实例</strong></li>
</ul>
<blockquote>
<p>熟悉Django框架的，应该知道ORM结构，元类创建API，使得调用简洁明了。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 1.定义Field类，用于保存数据表的字段名和字段类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, column_type)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.column_type = column_type</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;%s:%s&gt;'</span> % (self.__class__.__name__, self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringField</span><span class="params">(Field)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super().__init__(name, <span class="string">'varchar(100)'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerField</span><span class="params">(Field)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super().__init__(name, <span class="string">'bigint'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义元类，控制Model对象的创建</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelMetaClass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""定义元类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">'Model'</span>:</span><br><span class="line">            <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line">        print(<span class="string">'Found model: %s'</span> % name)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 排除掉对Model类的修改</span></span><br><span class="line">        mappings = dict()</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():</span><br><span class="line">            <span class="comment"># 保存类属性和列的映射关系到mappings字典</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(v, Field):</span><br><span class="line">              print(<span class="string">'Found mapping: %s==&gt;%s'</span> % (k, v)</span><br><span class="line">              mappings[k] = v</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():</span><br><span class="line">            <span class="comment"># 将类属性移除，是定义的类字段不污染User类属性，只在实例中可以访问这些key</span></span><br><span class="line">            attrs.pop(k)</span><br><span class="line">        <span class="comment"># 假设表名为类名的小写，创建类时添加一个__table__类属性</span></span><br><span class="line">        attrs[<span class="string">'__table__'</span>] = name.lower()</span><br><span class="line">        <span class="comment"># 保存属性和列的映射关系，创建类时添加一个__mappings__类属性</span></span><br><span class="line">        attrs[<span class="string">'__mappings__'</span>] = mappings</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写Model基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(dict, metaclass= ModelMetaClass)</span>:</span></span><br><span class="line">    <span class="string">"""只是简单实现了INSERT功能"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kw)</span>:</span></span><br><span class="line">        super(Model, self).__init__(**kw)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">r"'Model' object has no attribute '%s'"</span> % key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self)</span>:</span></span><br><span class="line">        fields = []</span><br><span class="line">        params = []</span><br><span class="line">        args = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__mappings__.items():</span><br><span class="line">            fields.append(v.name)</span><br><span class="line">            params.append(<span class="string">'?'</span>)</span><br><span class="line">            args.append(getattr(self, k, <span class="literal">None</span>))</span><br><span class="line">        sql = <span class="string">'insert into %s (%s) values (%s)'</span> % (self.__table__, <span class="string">','</span>.join(fields), <span class="string">','</span>.join(params))</span><br><span class="line">        print(<span class="string">'SQL: %s'</span> % sql)</span><br><span class="line">        print(<span class="string">'ARGS: %s'</span> % str(args))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个model，用户表User，定义数据字段就可实现数据表和字段的操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Model)</span>：</span></span><br><span class="line">    id = IntegerField('id')  # 对应数据表的id字段</span><br><span class="line">    name = StringField(<span class="string">'username'</span>)  <span class="comment"># 对应数据表的username字段</span></span><br><span class="line">    email = StringField(<span class="string">'email'</span>)  <span class="comment"># 对应数据表的email字段</span></span><br><span class="line">    password = StringField(<span class="string">'password'</span>)  <span class="comment"># 对应数据表的password字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个实例</span></span><br><span class="line">user = User(id=<span class="number">123456</span>, name=<span class="string">'Michael'</span>, email=<span class="string">'test@163.com'</span>, password=<span class="string">'123456'</span>)</span><br><span class="line"><span class="comment"># 保存数据库</span></span><br><span class="line">user.save()</span><br></pre></td></tr></table></figure>

<h2 id="4-staticmethod和-classmethod和实例方法"><a href="#4-staticmethod和-classmethod和实例方法" class="headerlink" title="4. @staticmethod和@classmethod和实例方法"></a>4. @staticmethod和@classmethod和实例方法</h2><blockquote>
<p><strong><a href="https://stackoverflow.com/questions/136097/difference-between-staticmethod-and-classmethod" target="_blank" rel="noopener">what-is-the-difference-between-staticmethod-and-classmethod-in-python</a></strong></p>
</blockquote>
<blockquote>
<p><strong><a href="https://realpython.com/instance-class-and-static-methods-demystified/" target="_blank" rel="noopener">real python上详细知识</a></strong></p>
</blockquote>
<ul>
<li><strong>静态方法</strong></li>
</ul>
<blockquote>
<p>静态方法：其实和普通的方法一样，不需要对谁进行绑定，必须有@staticmethod修饰，类和实例都可以访问静态方法，调用方式A。static_foo(x)和a.static_foo(x)。</p>
</blockquote>
<ul>
<li><strong>类方法</strong></li>
</ul>
<blockquote>
<p>类方法：即在类里定义的函数方法，需要@classmethod修饰，并且有个隐藏参数cls，传递的是类而不是实例，类可以访问类方法，也可以访问实例方法，访问实例方法时必须带参数self。</p>
</blockquote>
<ul>
<li><strong>实例方法</strong></li>
</ul>
<blockquote>
<p>实例方法的调用离不开实例，必须有个参数self，把实例自己传给函数，调用是够是a.foo(x)与foo(a, x)等价。实例可以访问实例方法，也可以访问类方法。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>：</span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"executing foo(%s)"</span> % <span class="params">(x)</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(<span class="string">"executing foo(%s, %s)"</span> % (self, x))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span><span class="params">(cls, x)</span>:</span></span><br><span class="line">      print(<span class="string">"executing foo(%s, %s)"</span> % (cls, x)<span class="string">")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # 静态方法</span></span><br><span class="line"><span class="string">    @staticmethod</span></span><br><span class="line"><span class="string">    def static_foo(x):</span></span><br><span class="line"><span class="string">      print("</span>executing foo(%s)<span class="string">" % x)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">a = A()</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">实例/类</th>
<th align="center">实例方法</th>
<th align="center">类方法</th>
<th align="center">静态方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实例: a = A()</td>
<td align="center">a.foo(x)</td>
<td align="center">a.class_foo(x)</td>
<td align="center">a.static_foo(x)</td>
</tr>
<tr>
<td align="center">类: A</td>
<td align="center">不可用</td>
<td align="center">A.class_foo(x)</td>
<td align="center">A.static_foo(x)</td>
</tr>
</tbody></table>
<h2 id="5-单例模式"><a href="#5-单例模式" class="headerlink" title="5. 单例模式"></a>5. 单例模式</h2><ul>
<li><strong>使用<strong>new</strong>方法</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>共享属性</strong></li>
</ul>
<blockquote>
<p>创建实例时把所有实例的<code>__dict__</code>指向同一个字典，这样它们具有相同的属性和方法.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Borg</span><span class="params">(object)</span>:</span></span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        ob = super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        <span class="keyword">return</span> ob</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span><span class="params">(Borg)</span>:</span></span><br><span class="line">  a = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>装饰器版本</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getinstance</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> getinstance</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">   ···</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>import方法</strong></li>
</ul>
<blockquote>
<p>作为python的模块是天然的单例模式</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysingleton.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">my_singleton = My_Singleton()</span><br><span class="line"></span><br><span class="line"><span class="comment"># to use</span></span><br><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> my_singleton</span><br><span class="line"></span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>元类实现单例</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过__init__方法实现元类（优雅）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"__init__"</span>)</span><br><span class="line">        self.__instance = <span class="literal">None</span></span><br><span class="line">        super(Singleton, self).__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"__call__"</span>)</span><br><span class="line">        <span class="keyword">if</span> self.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.__instance = super(Singleton, self).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> self.__instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">    __metaclass__ = Singleton</span><br><span class="line"></span><br><span class="line">foo1 = Foo()</span><br><span class="line">foo2 = Foo()</span><br><span class="line">print(Foo.__dict__)</span><br><span class="line">print(foo1 <span class="keyword">is</span> foo2)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过元类的__new__方法实现元类（为了实例增加属性重写__new__方法，不推荐）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        print(<span class="string">"__new__"</span>)</span><br><span class="line">        attrs[<span class="string">"_instance"</span>] = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> super(Singleton, cls).__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"__call__"</span>)</span><br><span class="line">        <span class="keyword">if</span> self._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._instance = super(Singleton, self).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> self._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">   __metaclass__ = Singleton</span><br><span class="line"></span><br><span class="line">foo1 = Foo()</span><br><span class="line">foo2 = Foo()</span><br><span class="line">print(Foo.__dict__)</span><br><span class="line">print(foo1 <span class="keyword">is</span> foo2)</span><br></pre></td></tr></table></figure>

<p><strong><a href="http://python.jobbole.com/87294/" target="_blank" rel="noopener">单例模式伯乐在线详细解释</a></strong></p>
<h2 id="6-python常用库"><a href="#6-python常用库" class="headerlink" title="6. python常用库"></a>6. python常用库</h2><ul>
<li><p><strong>标准库</strong></p>
<p><strong><a href="https://www.cnblogs.com/haochengdu/p/8855028.html" target="_blank" rel="noopener">网友总结参考</a></strong></p>
<p><strong><a href="https://docs.python.org/zh-cn/3.8/library/index.html" target="_blank" rel="noopener">官网中文参考</a></strong></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os：提供了不少于操作系统相关联的函数  </span><br><span class="line"></span><br><span class="line">sys：通常用于命令行参数</span><br><span class="line"></span><br><span class="line">res：正则表达式操作</span><br><span class="line"></span><br><span class="line">math：数学运算</span><br><span class="line"></span><br><span class="line">decimal：十进制定点和浮点运算</span><br><span class="line"></span><br><span class="line">datetime：日期时间</span><br><span class="line"></span><br><span class="line">collections：容器数据类型</span><br><span class="line"></span><br><span class="line">json：JSON 编码和解码器</span><br><span class="line"></span><br><span class="line">base64：Base16, Base32, Base64, Base85 数据编码</span><br><span class="line"></span><br><span class="line">heapq：堆队列算法</span><br><span class="line"></span><br><span class="line">copy：复制</span><br><span class="line"></span><br><span class="line">threading：基于线程的并行</span><br><span class="line"></span><br><span class="line">multiprocessing：基于进程的并行</span><br><span class="line"></span><br><span class="line">subprocess：子进程管理</span><br><span class="line"></span><br><span class="line">queue：一个同步的队列类</span><br><span class="line"></span><br><span class="line">random：生成伪随机数</span><br><span class="line"></span><br><span class="line">pprint：数据美化输出</span><br><span class="line"></span><br><span class="line">itertools：为高效循环而创建迭代器的函数</span><br><span class="line"></span><br><span class="line">functools：高阶函数和可调用对象上的操作</span><br><span class="line"></span><br><span class="line">operator：标准运算符替代函数</span><br><span class="line"></span><br><span class="line">logging：Python 的日志记录工具</span><br><span class="line"></span><br><span class="line">hashlib：安全哈希与消息摘要</span><br><span class="line"></span><br><span class="line">pickle：Python 对象序列化</span><br><span class="line"></span><br><span class="line">html.parser：简单的 HTML 和 XHTML 解析器</span><br><span class="line"></span><br><span class="line">urllib：URL 处理模块</span><br><span class="line"></span><br><span class="line">traceback：打印或检索堆栈回溯</span><br><span class="line"></span><br><span class="line">__future__：Future 语句定义</span><br><span class="line"></span><br><span class="line">gc：垃圾回收器接口</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>科学计算与数据分析库</strong></p>
<blockquote>
<p>numpy：科学计算包，支持N维数组运算、处理大型矩阵、成熟的广播函数库、矢量运算、线性代数、傅里叶变换、随机数生成，并可与C++/Fortran语言无缝结合。</p>
</blockquote>
<blockquote>
<p>scipy：建立在NumPy基础上，它是离散傅立叶变换、线性代数、优化和稀疏矩阵等多种高级科学和工程模块最有用的库之一。</p>
</blockquote>
<blockquote>
<p>pandas：主要用于结构化数据的运算和操作，广泛用于数据整理和预处理，其有助于提高Python在数据科学社区的使用。</p>
</blockquote>
<blockquote>
<p>matplotlib：主要用于绘制各种各样的图形，从直方图到线图、热力图，还可以使用Latex命令在图像中添加数学符号。</p>
</blockquote>
<blockquote>
<p>Scikit：主要用于机器学习，该库建立在NumPy、SciPy和matplotlib基础上，包含许多有效的机器学习和统计建模工具，如分类、回归、聚类和降维。</p>
</blockquote>
<blockquote>
<p>Statsmodels：用于统计建模，是一个Python中提供用户探索数据、估计统计模型和执行统计测试的模组。可用于不同类型数据的描述性统计，统计测试，绘图功能和结果统计。</p>
</blockquote>
<blockquote>
<p>Seaborn：用于数据可视化，是一个用于在Python中制作有吸引力和翔实的统计图形库。它是基于matplotlib。Seaborn旨在使可视化成为探索和理解数据的核心组成。  </p>
</blockquote>
<blockquote>
<p>Bokeh：用于在现代网络浏览器上创建交互式图表，仪表盘和数据应用程序。它赋予用户以D3.js的风格生成优雅简洁的图形。此外，它具有超大型或流式数据集的高性能交互能力。</p>
</blockquote>
<blockquote>
<p>Blaze: 将Numpy和Pandas的能力扩展到分布式和流式传输数据集。它可以用于从众多来源包括Bcolz，MongDB,SQLAlchemy,Apache Spark,PyTables等访问数据，与Bokeh一起，可以作为在矩形数据模块上创建有效可视化和仪表盘的强大的工具。</p>
</blockquote>
<blockquote>
<p>Sympy：用于符号计算，具有从基本算数符号到微积分、袋鼠、离散数学和量子物理学的广泛能力，另一个有用的功能是将计算结果格式化为LaTeX代码。</p>
</blockquote>
</li>
<li><p><strong>第三方库</strong></p>
<blockquote>
<p>pymysqldb：是在 Python2.x 版本中用于连接 MySQL 服务器的一个库，导包：import MySQLdb。</p>
</blockquote>
<blockquote>
<p>PyMySQL：是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，导包：import pymysql，当要向下兼容python2时,可以加上：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个连接对象，再使用创建游标</span></span><br><span class="line">con = pymysql.connect(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'1234'</span>, db=<span class="string">'mysql'</span>)</span><br><span class="line">cursor = con.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一个SQL语句</span></span><br><span class="line">sql = <span class="string">"select * from user"</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从游标中取出所有记录放到一个序列中并关闭游标</span></span><br><span class="line">result = cursor.fetchall()</span><br><span class="line">print(result)</span><br><span class="line">cursor.close()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>djano：是一个高层次的web开发框架，特点是开发快、代码少。可扩展性强。采用MTV（Model、Template、View）模型组织资源，框架功能丰富，模板扩展选择最多。</p>
</blockquote>
<blockquote>
<p>flask： 是一个web开发的微框架，严格来说，它仅仅提供web服务器支持，不提供全栈开发支持。然而，Flask非常轻量、非常简单，特别适合小微原型系统的开发，耗时少，开发效率高。  </p>
</blockquote>
<blockquote>
<p>Tornado：是一个基于异步网络功能库的Web开发框架，能够支持几万个开放连接，Web服务比较稳定。比较适合高并发场景下的Web系统，如秒杀系统、抢票系统等，灵活性较差。</p>
</blockquote>
<blockquote>
<p>Falcon：是一个支持大规模微服务API或移动App后端响应的web开发框架，它完全基于python并提供了非常高性能、可靠性和可扩展性。</p>
</blockquote>
<blockquote>
<p>Pyramid：是一个扩展性很强且灵活的web开发框架，上手十分容易，比较适合中等规模且边开发边设计的场景。它不提供绝对严格的框架定义，根据需求可以扩展开发，对高阶程序员十分友好。</p>
</blockquote>
<blockquote>
<p>Quart：是面向ASGI(异步服务器网关接口)开发的web为框架，采用Flask兼容的API接口，提供非常轻量级的开发方式。</p>
</blockquote>
<blockquote>
<p>requests：用于Web访问，类似于python标准库的urllib2，更容易更方便上手，适合初学者。</p>
</blockquote>
<blockquote>
<p>scrapy： 用于网络爬虫，它是获取特定模式数据的非常有用的框架，从网站首页URL开始,然后挖掘网站内的网页内容来手机信息。</p>
</blockquote>
<blockquote>
<p>selenium：是一个用于测试网站的自动化工具，支持Chrome、Firefox、Safari等主流界面浏览器，同时也支持PhantomJS无界面浏览器。</p>
</blockquote>
<blockquote>
<p>celery：是一个由python编写的简单、灵活、可靠的用于处理大量信息的分布式系统，它同时提供操作和维护分布式所需的工具，专注于实时任务，支持任务调度。是一个分布式队列管理工具，可以用celery提供接口快速实现并管理一个分布式任务队列。</p>
</blockquote>
</li>
</ul>
<h2 id="7-python中的类型转换"><a href="#7-python中的类型转换" class="headerlink" title="7. python中的类型转换"></a>7. python中的类型转换</h2><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th></th>
<th>函数</th>
<th>作用</th>
<th></th>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>int()</td>
<td>转整型</td>
<td></td>
<td>list()</td>
<td>转列表</td>
<td></td>
<td>bin()</td>
<td>整数转2进制</td>
</tr>
<tr>
<td>float()</td>
<td>转浮点型</td>
<td></td>
<td>dict()</td>
<td>转字典</td>
<td></td>
<td>oct()</td>
<td>整数转6进制</td>
</tr>
<tr>
<td>str()</td>
<td>转字符串</td>
<td></td>
<td>set()</td>
<td>转集合</td>
<td></td>
<td>hex()</td>
<td>整数转16进制</td>
</tr>
<tr>
<td>ord()</td>
<td>字符转整数</td>
<td></td>
<td>tuple()</td>
<td>转元组</td>
<td></td>
<td>complex()</td>
<td>实数转复数</td>
</tr>
</tbody></table>
<h2 id="8-文件流操作"><a href="#8-文件流操作" class="headerlink" title="8. 文件流操作"></a>8. 文件流操作</h2><ul>
<li><strong>打开文件</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f=open(<span class="string">'file_name'</span>, <span class="string">'file_type'</span>)</span><br><span class="line"><span class="keyword">if</span> f:  <span class="comment"># 判断文件是否打开</span></span><br><span class="line">file_type</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'file_name'</span>, <span class="string">'file_type'</span>) <span class="keyword">as</span> f:</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>访问模式</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w: 只写</span><br><span class="line"></span><br><span class="line">r：只读</span><br><span class="line"></span><br><span class="line">a: 追加写入</span><br><span class="line">rb: 二进制只读</span><br><span class="line"></span><br><span class="line">wb：二进制写入</span><br><span class="line"></span><br><span class="line">ab：二进制追加写入</span><br><span class="line"></span><br><span class="line">r+：打开一个文件用于读写，文件指针将会放在文件的开头。</span><br><span class="line"></span><br><span class="line">w+：打开一个文件用于读写，如果文件已经存在则将其覆盖，如果文件不存在，则创建新文件。</span><br><span class="line"></span><br><span class="line">a+：打开一个文件用于读写，追加模式。如果文件存在，文件指针将会放在文件的结尾；如果该文件不存在，穿件新文件用于读写。</span><br><span class="line"></span><br><span class="line">rb+: 以二进制格式打开一个文件用于读写，文件指正将会放在文件的开头，一般用于非文本文件如图片等。</span><br><span class="line"></span><br><span class="line">wb+:以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件，一般用于非文本文件如图片等。</span><br><span class="line"></span><br><span class="line">ab+:以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾；如果文件不存在，创建新文件用于读写。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>写文件</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f.write(content)  <span class="comment"># 打开文件后，将制定内容写入文件中</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>读取文件</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f.read(lenth)  <span class="comment"># 使用read可以从文件中读取制定长度的数据，并将指针移到这条数据之后。如果为空，则默认读取全部数据。</span></span><br><span class="line"></span><br><span class="line">f.readline()  <span class="comment"># 读取文件中一行数据的信息，指针移动到下一行。</span></span><br><span class="line"></span><br><span class="line">f.readlines() <span class="comment"># 读取整个文件的数据信息，返回一个列表，列表中每个元素为一行数据信息。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>查看指针位置</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f.tell()  <span class="comment"># 查看单签位置，就是指针对应的位置</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>指针定位</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seek(offset, <span class="keyword">from</span>)  <span class="comment"># 将指针定位到某个位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span>: <span class="comment"># 方向，0表示文件开头；1表示文件当前位置；2表示文件的末尾</span></span><br><span class="line">offset: 偏移量</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">    f.seek(<span class="number">5</span>,<span class="number">0</span>)  <span class="comment"># 文件开头，向后偏移5个位置</span></span><br><span class="line">    f.seek(<span class="number">-3</span>,<span class="number">2</span>)  <span class="comment"># 文件结尾，向前偏移3个位置</span></span><br></pre></td></tr></table></figure>

<h2 id="9-new-和-init的区别"><a href="#9-new-和-init的区别" class="headerlink" title="9. new 和 init的区别"></a>9. <strong>new</strong> 和 <strong>init</strong>的区别</h2><ul>
<li><strong>new</strong>是一个静态方法，而<strong>init</strong>是一个实例方法</li>
<li><strong>new</strong>方法会返回一个创建的实例，而<strong>init</strong>什么都不返回</li>
<li>只有在<strong>new</strong>返回一个cls的实例时，后面的<strong>init</strong>才能被调用</li>
<li>创建一个新实例时调用<strong>new</strong>方法，初始化一个实例时调用<strong>init</strong>方法</li>
</ul>
<h2 id="10-python内存管理与垃圾回收机制"><a href="#10-python内存管理与垃圾回收机制" class="headerlink" title="10. python内存管理与垃圾回收机制"></a>10. python内存管理与垃圾回收机制</h2><p><strong><a href="https://blog.csdn.net/xiongchengluo1129/article/details/80462651" target="_blank" rel="noopener">Python垃圾回收机制详解</a></strong></p>
<blockquote>
<p>Python GC主要使用引用计数(reference counting)来跟踪和回收垃圾。在引用计数的基础上，通过标记清除机制(mark and sweep)解决容器对象可能产生的循环引用问题，通过分代回收(generation collection)策略，以以空间换时间的方法来提高垃圾回收的效率。</p>
</blockquote>
<ul>
<li>引用计数</li>
</ul>
<blockquote>
<p>引用计数法的原理是每个对象维护一个ob_ref，用来记录当前对象被引用的次数，也就是来追踪到底有多少引用指向了这个对象，当发生（对象被创建、对象被引用、对象被作为参数传到函数中、对象作为一个元素，存储在容器中）四种情况的时候，该对象的引用计数+1；当发生（该对象的别名被显示销毁时、该对象的引别名被赋予新的对象、一个对象离开它的作用域、该元素从容器中删除时或容器被销毁时），该对象的引用计数器-1。</p>
</blockquote>
<p><strong>简而言之，PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当有一个对象有心的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少。当引用计数为0时，该对象生命就结束了。</strong></p>
<p><strong>优点：</strong><br>① 高效<br>② 运行期没有停顿<br>③ 对象有确定的生命周期<br>④ 易于实现</p>
<p><strong>缺点：</strong><br>① 维护引用计数消耗资源，维护引用计数的次数和应用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。<br>② 无法解决循环引用的问题。</p>
<ul>
<li>标记清除机制(mark and sweep)</li>
</ul>
<blockquote>
<p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没有标记的对象释放。为了保证效率，Python只会在垃圾达到一定阈值时，垃圾回收才会启动。主要处理对象是一些容器对象，如list、dict、tuple、set、instance等，因为对于字符串、数值对象是不可能造成循环引用问题。</p>
</blockquote>
<p><strong>缺点：</strong><br>①清除非活动对象前必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。</p>
<ul>
<li>分带回收策略</li>
</ul>
<blockquote>
<p>分代回收的整体思想是：将系统中所有的内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，python将内存等为3“代”，分别是年轻代(第0代)、中年代(第1代)、老年代(第2代)，它们对应的是三个链表，它们的垃圾回收集频率随着“代”的存活时间的增大而减小，新创建的对象都会分配在年轻代，年轻代链表总数达到上限时，python垃圾回收机制就回被触发，把那些可以被回收的对象回收，而那些不被回收的对象就会移到中年代去，以此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期，存活时间通常利用经过几次垃圾回收来度量。同时，分代回收是建立在标记清除技术基础之上。</p>
</blockquote>
<blockquote>
<p>Python默认定义三代对象集合，索引越大，对象存活时间越长。</p>
</blockquote>
<h2 id="11-python2-x-与python3-x的主要区别"><a href="#11-python2-x-与python3-x的主要区别" class="headerlink" title="11. python2.x 与python3.x的主要区别"></a>11. python2.x 与python3.x的主要区别</h2><p><strong><a href="https://www.pythonheidong.com/blog/article/22/" target="_blank" rel="noopener">比较详细</a></strong></p>
<ul>
<li><p>输入， py2中：raw_input(); py3中：input()</p>
</li>
<li><p>输出， py2中：print语句; py3中：print()函数</p>
</li>
<li><p>除法，py2中整数间进行’/‘和’//‘运算返回的是整数，而py3的’/‘运算返回的是浮点数</p>
</li>
<li><p>遍历范围，py2中：range()或xrange(); py3中：不等于，py2中：range</p>
</li>
<li><p>不等于，py2中：&lt;&gt;或!= ; py3中：!=</p>
</li>
<li><p>编码问题，py3默认使用unicode，字节是bytes；而py2中字节是str, 默认支持ascii编码，unicode需要在前面加u</p>
</li>
<li><p>异常，py2中：except exec, var ; py3中：except exec as var</p>
</li>
<li><p>八进制字面量，py2中：0o777或0777 ; py3中：0o777</p>
</li>
<li><p>去掉了repr表达式``，py2中：反引号相当于repr()的作用; py3中：去除反引号写法</p>
</li>
<li><p>多个模块变化</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>旧的名字</th>
<th>新的名字</th>
</tr>
</thead>
<tbody><tr>
<td>_winreg</td>
<td>winreg</td>
</tr>
<tr>
<td>ConfigParser</td>
<td>configparser</td>
</tr>
<tr>
<td>copy_reg</td>
<td>copyreg</td>
</tr>
<tr>
<td>Queue</td>
<td>queue</td>
</tr>
<tr>
<td>SocketServer</td>
<td>socketserver</td>
</tr>
<tr>
<td>repr</td>
<td>reprlib</td>
</tr>
</tbody></table>
<ul>
<li><p>数据类型，py3中去除long类型，只有int</p>
</li>
<li><p>rasie，py2中：raise IOError, “file error”; py3中：raise IOError(“file error”)</p>
</li>
<li><p>去除.next()，py2中：next(generator)和generator.next(); py3中：next(generator)</p>
</li>
<li><p>py3中for循环变量不会导致命名空间泄漏</p>
</li>
<li><p>py3中不能比较不可排序类型，需同类型比较</p>
</li>
<li><p>py3中range、zip、map、reduce、filter等返回的是可迭代对象，而不是列表</p>
</li>
<li><p>py3中新增asynico内置库，async/await原生协程支持异步编程</p>
</li>
<li><p>py3中移除cmp函数</p>
</li>
<li><p>py3中去除元组参数解包</p>
</li>
<li><p>增加了@abstractmethod和 @abstractproperty两个 decorator，编写抽象方法（属性）更加方便</p>
</li>
<li><p>移除了cPickle模块，可以使用pickle模块代替</p>
</li>
<li><p>移除了new模块</p>
</li>
<li><p>移除了 audiodev, Bastion, bsddb185, exceptions, linuxaudiodev, md5, MimeWriter, mimify, popen2,<br>rexec, sets, sha, stringold, strop, sunaudiodev, timing和xmllib模块</p>
</li>
<li><p>移除了imageop模块</p>
</li>
<li><p>迭代器的next()方法改名为<strong>next</strong>()，并增加内置函数next()，用以调用迭代器的<strong>next</strong>()方法</p>
</li>
</ul>
<h2 id="12-如何将python2的代码迁移到python3"><a href="#12-如何将python2的代码迁移到python3" class="headerlink" title="12. 如何将python2的代码迁移到python3"></a>12. 如何将python2的代码迁移到python3</h2><p><strong><a href="https://docs.python.org/zh-cn/3.9/howto/pyporting.html" target="_blank" rel="noopener">官方文档</a></strong></p>
<blockquote>
<p>第一步：使用自带的2to3.py文件，可以实现大部分代码从py2到py3的自动转换。命令：2to3 -w example.py</p>
</blockquote>
<blockquote>
<p>第二步：使用Pylint或者Pyflakes工具，检测代码错误。</p>
</blockquote>
<blockquote>
<p>第三步：检查模块和依赖库的变化。</p>
</blockquote>
<blockquote>
<p>第四步：人工修复被破坏的py2代码。</p>
</blockquote>
<p><strong>利用好<strong>future</strong>模块</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division  <span class="comment"># 在Python 2 中表现 Python 3.x 中的整除</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals  <span class="comment"># 适应Python 3.x的新的字符串的表示方法</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function  <span class="comment"># 使用打印功能</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> nested_scopes  <span class="comment"># 静态嵌套范围</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> generators  <span class="comment"># 简单生成器</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import  <span class="comment"># 绝对/相对导入</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> with_statement  <span class="comment"># with声明</span></span><br></pre></td></tr></table></figure>

<h2 id="13-python新式类和旧式类的区别"><a href="#13-python新式类和旧式类的区别" class="headerlink" title="13. python新式类和旧式类的区别"></a>13. python新式类和旧式类的区别</h2><blockquote>
<p>新式类是在创建的时候继承内置的object对象或者是内置类型如list、dict，而旧式类(经典类)是直接声明的，可以用dir()方法查看新式类中内置了很多性的属性和方法。</p>
</blockquote>
<blockquote>
<p>新式类遍历方法是广度优先，经典类是深度优先。</p>
</blockquote>
<h2 id="14-鸭子类型"><a href="#14-鸭子类型" class="headerlink" title="14. 鸭子类型"></a>14. 鸭子类型</h2><blockquote>
<p>编程语言中动态类型语言的一种设计风格，一个对象的特征不是由父类决定，而是通过对象的方法决定。类与类之间不用共同继承一个父类，只需要将它们做的像一件事物即可。</p>
</blockquote>
<blockquote>
<p>注重对象的行为，而非对象的类型，一个对象能都昨晚函数、表达是的参数，取决于其行为而非类型归属。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gua gua"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"女王大人"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_quack</span><span class="params">(ducker)</span>:</span></span><br><span class="line">    ducker.quack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    d = Duck(<span class="string">'duck'</span>)</span><br><span class="line">    m = Man(<span class="string">'man'</span>)</span><br><span class="line">    do_quack(d)</span><br><span class="line">    do_quack(m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">gua gua</span></span><br><span class="line"><span class="string">女王大人</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="15-python自省"><a href="#15-python自省" class="headerlink" title="15. python自省"></a>15. python自省</h2><blockquote>
<p>在一些语言中也叫做反射，简单来说就是对象检查。面向对象的语言所写的程序在运行时，所能知道对象的类型。是什么(isinstance)，是什么类型(type)，有那些属性(hasattr)，有哪些变量方法(dir)，有哪些行为(hasattr)，getattr、setattr、delattr、callable。</p>
</blockquote>
<h2 id="16-猴子补丁技术"><a href="#16-猴子补丁技术" class="headerlink" title="16. 猴子补丁技术"></a>16. 猴子补丁技术</h2><blockquote>
<p>是一种让程序行为在运行时扩展或者变更的方法。</p>
</blockquote>
<blockquote>
<p>python充分利用动态语言的特性，在程序运行时动态改变类、模块、属性或方法，为的是将第三方代码打补丁在不按预期运行的bug或者feature上，gevent在这方面运用的比较多。</p>
</blockquote>
<h2 id="17-python语法糖有哪些"><a href="#17-python语法糖有哪些" class="headerlink" title="17. python语法糖有哪些"></a>17. python语法糖有哪些</h2><blockquote>
<p>在计算及科学中，语法糖是某种特殊的语法，对语言的功能没有影响，但对程序员来说，有更好的易用性，简洁性、可读性、方便性。比如索引切片、列表推导式、字典推导式、生成器推导式等等。</p>
</blockquote>
<ul>
<li>切片操作</li>
</ul>
<p><strong><a href="https://www.jianshu.com/p/15715d6f4dad" target="_blank" rel="noopener">Python切片操作详细例子</a></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'123456'</span></span><br><span class="line">s[:<span class="number">3</span>]  <span class="comment"># 结果为'123'，取索引索引小于3的值，或叫“取前3位”</span></span><br><span class="line">s[<span class="number">3</span>:]  <span class="comment"># 结果为'456', 取索引大于等于3的值，或叫“从第4位取到最后”</span></span><br><span class="line">s[<span class="number">2</span>:<span class="number">4</span>]  <span class="comment"># 结果为'34', 取索引大于等2，小于4的值，或叫“取第3位到第4位”</span></span><br><span class="line">s[:]  <span class="comment"># 结果为'123456', 取索引全部</span></span><br><span class="line">s[:<span class="number">-1</span>]  <span class="comment"># 结果为'654321' 取倒序</span></span><br><span class="line">s[::<span class="number">2</span>]  <span class="comment"># 结果为'135' 步长为2取值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>with打开文件</li>
</ul>
<blockquote>
<p>实现的是一个上下文管理器，它主要的特点就是帮助我们自动管理上下文的衔接。即在需要的时候传给我们，不需要的时候自动关闭上下文对象。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        print(line,end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>else语法糖</li>
</ul>
<blockquote>
<p>for-else、while-else 需要和break语句配合使用。</p>
</blockquote>
<blockquote>
<p>try-else-finally</p>
</blockquote>
<ul>
<li><p>动态参数: (<em>args, *</em>kwargs)</p>
</li>
<li><p>匿名函数: lambda x: x * 2</p>
</li>
<li><p>推导表达式</p>
</li>
</ul>
<blockquote>
<p>列表推导表达式：[i for i in s if i%2 != 0]<br>生成器推导表达式： (i for i in s if i%2 != 0)<br>集合推导表达式：{i for i in s if i%2 != 0}<br>字典推导表达式：{i:i*2 for i in s if i%2 != 0}</p>
</blockquote>
<ul>
<li>yield表达式</li>
</ul>
<blockquote>
<p>yield是Python中实现<strong>协程(coroutine)</strong>的一个重要基础</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_generator</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">'''生成器'''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">yield</span> i*<span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>装饰器</li>
</ul>
<blockquote>
<p>一种设计模式，本质上也是一种python函数，是一种闭包。装饰器需要返回一个对象，该对象可以是经过处理的原参数对象，一个包装且类似原参数的对象。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">'''装饰器'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>

<ul>
<li>map</li>
</ul>
<blockquote>
<p>map(function, iterable, …) 会根据提供的函数对指定序列做映射。function函数，iterable一个或多个序列，其中py2返回的列表，py3返回的是迭代器。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line">map(square, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">map(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>], [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li>reduce</li>
</ul>
<blockquote>
<p>reduce(function, iterable[, initializer]) 函数会对参数序列中元素进行累积。function 有两个参数, iterable可迭代对象，initializer可选，初始参数。用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">reduce(add, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">reduce(<span class="keyword">lambda</span> x, y: x+y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li>filter</li>
</ul>
<blockquote>
<p>filter(function, iterable) 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。function判断函数，iterable可迭代对象，该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">odd</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line">newlist = filter(odd, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">print(list(newlist))</span><br></pre></td></tr></table></figure>

<h2 id="18-迭代器和生成器"><a href="#18-迭代器和生成器" class="headerlink" title="18. 迭代器和生成器"></a>18. 迭代器和生成器</h2><blockquote>
<p>迭代器是一个更抽象的概念，任何对象，如果它的类有next方法和iter方法返回自己本身。对于string、list、dict、tuple等这类容器对象，使用for循环遍历是很方便的。在后台for语句对容器对象调用iter()函数，iter()是python的内置函数。iter()会返回一个定义了next()方法的迭代器对象，它在容器中逐个访问容器内元素，next()也是python的内置函数。在没有后续元素时，next()会抛出一个StopIteration异常。</p>
</blockquote>
<blockquote>
<p>生成器(Generator)是创建迭代器的简单而强大的工具。它们写起来就像是正规的函数，只是在需要返回数据的时候使用yield语句，生成器使用yield语句返回一个值，yield语句挂起该生成器函数的状态，保留足够的信息，以便之后从它离开的地方继续执行。每次next()被调用时，生成器会返回它脱离的位置（它记忆语句最后一次执行的位置和所有的数据值）。生成器需要注意：只能遍历一次。</p>
</blockquote>
<blockquote>
<p>区别：生成器能做到迭代器能做的所有事，而且因为自动创建了<strong>iter</strong>()和next()方法，生成器显得特别简洁，而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法，当发生器终结时，还会自动抛出StopIteration异常。</p>
</blockquote>
<h2 id="19-闭包"><a href="#19-闭包" class="headerlink" title="19. 闭包"></a>19. 闭包</h2><blockquote>
<p>闭包(closure)是函数式编程的重要的语法结构，也是一种组织代码的结构，提高了代码的复用性。简单说，外函数的内部定义了一个内函数，内部函数使用了外部函数的临时变量，并外函数的返回值是内函数的引用。产生闭包需满足的条件：</p>
</blockquote>
<ul>
<li>必须有一个内嵌函数</li>
<li>内嵌函数必须引用外部函数的变量</li>
<li>外部函数的返回值必须是内嵌函数</li>
</ul>
<blockquote>
<p>简单说，闭包就是根据不同的配置信息得到不同的结果，装饰器就是一种闭包，闭包有效的减少了函数所需定义的参数数目。</p>
</blockquote>
<blockquote>
<p>闭包的好处：<br>    - 取代硬编码中的常量<br>    - 避免使用全局值，并提供某种形式的数据隐藏<br>    - 提供一致的函数签名<br>    - 实现面向对象</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">line_conf</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">line</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a*x +b</span><br><span class="line">    <span class="keyword">return</span> line</span><br><span class="line"></span><br><span class="line">line1 = line_conf(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">line2 = line_conf(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">print(line1(<span class="number">5</span>), line2(<span class="number">5</span>))  <span class="comment"># (6, 25)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>返回闭包时：返回函数不要引用任何循环变量，或者后续会发生变化的变量</strong>。解决方法是在创建一个函数，用函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> j*j</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        fs.append(f(i))</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line">print(f1())</span><br><span class="line">print(f2())</span><br><span class="line">print(f3())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="20-装饰器"><a href="#20-装饰器" class="headerlink" title="20. 装饰器"></a>20. 装饰器</h2><blockquote>
<p><strong>以下是一些前人的总结参考：</strong></p>
</blockquote>
<p><strong><a href="https://blog.csdn.net/tryhardsilently/article/details/90767627" target="_blank" rel="noopener">python装饰器</a></strong></p>
<p><strong><a href="https://blog.csdn.net/yhy1271927580/article/details/72758577" target="_blank" rel="noopener">Python装饰器各种类型详解</a></strong></p>
<p><strong><a href="https://blog.csdn.net/five3/article/details/83447467" target="_blank" rel="noopener">Python各种类型装饰器详解说明</a></strong></p>
<p><strong><a href="https://blog.csdn.net/xiemanr/article/details/72510885" target="_blank" rel="noopener">python装饰器的4种类型</a></strong></p>
<p><strong><a href="https://blog.csdn.net/weixin_42134789/article/details/84635252?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase" target="_blank" rel="noopener">一文看懂Python系列之装饰器</a></strong></p>
<p><strong><a href="https://blog.csdn.net/u010358168/article/details/77773199?utm_medium=distribute.pc_relevant_right.none-task-blog-BlogCommendFromMachineLearnPai2-29.nonecase&depth_1-utm_source=distribute.pc_relevant_right.none-task-blog-BlogCommendFromMachineLearnPai2-29.nonecase" target="_blank" rel="noopener">python装饰器简介</a></strong></p>
<blockquote>
<p>装饰器本质上是一个函数，可以让其他函数在不需要做任何代码处理的前提下增加额外的功能，装饰器的返回值也是一个函数对象(函数的引用)。它经常用于有切面需求的场景，比如：<strong>插入日志、性能测试、事务处理、缓存、权限校验等场景</strong>，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p>
</blockquote>
<ul>
<li><strong>装饰器自身为函数</strong></li>
</ul>
<p>(1). 被装饰的对象为函数，且不带参数  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)  # 保证装饰过的函数__name__属性不变</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"Hello inner"</span>)</span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(func.__name__, end - start))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且不带参数</span></span><br><span class="line"><span class="meta">@time_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"foo is running."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.__name__)</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">inner</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">foo is running.</span></span><br><span class="line"><span class="string">方法foo用时:3.01444411277771秒</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在以上代码中，@time_decorator装饰器对foo函数进行了装饰，这是一个不带参数的装饰器，当python解释器执行到@time_decorator时，回去调用time_decorator函数，同时将被装饰的对象的函数名foo作为参数传入，这时time_decorator函数接受到一个参数(即方法名foo)，然后进入内嵌函数inner，计算开始时间，调用传进来的foo方法，再计算结束时间，打印函数foo的耗时，最后将结果用内部函数inner返回，其实就是一个闭包函数。</p>
</blockquote>
<blockquote>
<p>首先打印的是foo.<strong>name</strong>，这里是inner而不是foo，本质上是调用inner函数<br>其次打印的是inner的内容”Hello inner”，然后开始调用foo函数，打印”func1 is running.”<br>最后打印”方法foo用时:3.01444411277771秒”</p>
</blockquote>
<p>(2). 被装饰的对象为函数，且带参数  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    如果原函数有参数，那闭包函数必须保持参数个数一直，并且将参数传递给原方法</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"><span class="meta">    @wraps(func)  # 保证装饰过的函数__name__属性不变</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(name)</span>:</span>  <span class="comment"># 如果被装饰的函数有形参，那么闭包函数必须有参数，且一致</span></span><br><span class="line">        print(<span class="string">"Hello inner"</span>)</span><br><span class="line">        start = time.time()</span><br><span class="line">        func(name)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(func.__name__, end - start))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数，且带参数</span></span><br><span class="line"><span class="meta">@time_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"hello "</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.__name__)</span><br><span class="line">foo(<span class="string">'lucy'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">hello lucy</span></span><br><span class="line"><span class="string">方法foo用时:3.000863790512085秒</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当被装饰的函数，带参数时，需要在装饰器的闭包函数inner函数中添加一致的参数name，调用func对象时也需要加上一致的参数name，并且返回了以reurn inner形式返回闭包函数，具体调用过程看结果应该不难理解。</p>
</blockquote>
<blockquote>
<p>当然，如果被装饰函数存在多个参数时，这里使用了python中动态参数的概念，利用<code>(*args, **kwargs)</code>来接收可变参数和关键字参数，这样装饰器就可以支持任意的组合参数的函数了。装饰器修改如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)  # 保证装饰过的函数__name__属性不变</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 接收可变参数和关键字参数</span></span><br><span class="line">        print(<span class="string">"Hello inner"</span>)</span><br><span class="line">        start = time.time()</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(func.__name__, end - start))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数，且带参数</span></span><br><span class="line"><span class="meta">@time_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"hello "</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.__name__)</span><br><span class="line">foo(<span class="string">'lucy'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">hello lucy</span></span><br><span class="line"><span class="string">方法foo用时:3.000807762145996秒</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>(3). 被装饰的对象为函数，且带返回值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)  # 保证装饰过的函数__name__属性不变</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"Hello inner"</span>)</span><br><span class="line">        start = time.time()</span><br><span class="line">        res = func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(func.__name__, end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且带返回值</span></span><br><span class="line"><span class="meta">@time_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"foo is running."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"this is foo's return value"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.__name__)</span><br><span class="line">res = foo()</span><br><span class="line">print(<span class="string">'返回值：%s'</span> % res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">foo is running.</span></span><br><span class="line"><span class="string">方法foo用时:3.000837802886963秒</span></span><br><span class="line"><span class="string">返回值：this is foo's return value</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>若被装饰的函数是带返回值的，闭包函数inner中，调用func()时必须相应的带返回值，不然装饰函数时，也不进行返回，默认为None。</p>
</blockquote>
<p>(4). 被装饰的对象为函数，且装饰器带参数也有返回值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且带参数带返回值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_decorator</span><span class="params">(arg=None)</span>:</span>  <span class="comment"># 如果在调用装饰器时为给传参数，则默认值为None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)  # 保证装饰过的函数__name__属性不变</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">"Hello inner"</span>)</span><br><span class="line">            print(<span class="string">"装饰器的参数为：&#123;&#125;"</span>.format(arg))</span><br><span class="line">            start = time.time()</span><br><span class="line">            res = func(*args,**kwargs)</span><br><span class="line">            end = time.time()</span><br><span class="line">            print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(func.__name__, end - start))</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且不定参数</span></span><br><span class="line"><span class="meta">@time_decorator('hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"foo is running."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"this is foo's return value"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.__name__)</span><br><span class="line">res = foo()</span><br><span class="line">print(<span class="string">'返回值：%s'</span> % res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">装饰器的参数为：hello</span></span><br><span class="line"><span class="string">foo is running.</span></span><br><span class="line"><span class="string">方法foo用时:3.000739336013794秒</span></span><br><span class="line"><span class="string">返回值：this is foo's return value</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>带有参数的装饰器，需要写三层嵌套函数，最外一层用来传递装饰器的参数。上面的装饰器即带参数也带返回值，先执行time_decorator(‘hello’)，返回wrapper函数的应用，然后使用wrapper对函数foo进行装饰，内层inner使用的是<code>*args,**kwargs</code>接收可变参数和关键字参数，具体运行顺序看结果应该不难理解。</p>
</blockquote>
<p>(5). 被装饰的对象为类，且不带参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="comment"># 在装饰器中声明一个变量，用于保存类的实例，那么这个实例对象将始终是通过一个实例对象</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line"><span class="meta">    @wraps(cls)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'Hello inner'</span>)</span><br><span class="line">        print(<span class="string">'class name: &#123;&#125;'</span>.format(cls.__name__))</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls()</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象是类，且不带参数</span></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'lucy'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"her name is &#123;&#125;"</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化装饰后的类</span></span><br><span class="line">print(Foo.__name__)</span><br><span class="line">foo = Foo()</span><br><span class="line">foo.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">class name: Foo</span></span><br><span class="line"><span class="string">her name is lucy</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子是基于装饰器的单例模式，通过装饰器装饰这个类，是的类在初始化时候始终将初始化实例赋值给instances，而instances是装饰器的一个实例对象，通过实例赋值，instances始终占有同一个内存空间，也就实现了单例模式设计。</p>
</blockquote>
<blockquote>
<p>当然，如果用这个装饰器对类里面方法say进行装饰的话，此时装饰器single接收到的参数cls=say，所以打印”class name”是say，因为cls__name__就是say，这里等同于函数装饰器给函数进行装饰，于是装饰器的内层函数inner需要接受say带来的参数name，不加参数则会报错，其他与前面一样。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="comment"># 在装饰器中声明一个变量，用于保存类的实例，那么这个实例对象将始终是通过一个实例对象</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line"><span class="meta">    @wraps(cls)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(name)</span>:</span>  <span class="comment"># 必须和所修饰类里面的函数参数个数一致，否则会报错</span></span><br><span class="line">        print(<span class="string">'Hello inner'</span>)</span><br><span class="line">        print(<span class="string">'class name: &#123;&#125;'</span>.format(cls.__name__))</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(name)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象是类中的函数，调用类中的初始化参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'lucy'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @singleton</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"her name is &#123;&#125;"</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化装饰后的类</span></span><br><span class="line">print(Foo.__name__)</span><br><span class="line">foo = Foo()</span><br><span class="line">foo.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">class name: say</span></span><br><span class="line"><span class="string">her name is lucy</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>(6). 被装饰的对象为类，且带参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="comment"># 在装饰器中声明一个变量，用于保存类的实例，那么这个实例对象将始终是通过一个实例对象</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(cls)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Hello inner'</span>)</span><br><span class="line">        print(<span class="string">'class name: &#123;&#125;'</span>.format(cls.__name__))</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象是类，且带参数</span></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.id = args[<span class="number">0</span>]</span><br><span class="line">        self.name = kwargs.get(<span class="string">'name_dict'</span>).get(self.id)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"her name is &#123;&#125;"</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化装饰后的类</span></span><br><span class="line">print(Foo.__name__)</span><br><span class="line">foo = Foo(<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, name_dict=&#123;<span class="string">'1'</span>: <span class="string">'Lucy'</span>, <span class="string">'2'</span>: <span class="string">'Linda'</span>, <span class="string">'3'</span>: <span class="string">'Mary'</span>&#125;)</span><br><span class="line">foo.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">class name: Foo</span></span><br><span class="line"><span class="string">her name is Lucy</span></span><br></pre></td></tr></table></figure>

<p>(7). 被装饰的对象为类，且装饰器带参数也有返回值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且带参数带返回值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(arg=None)</span>:</span> <span class="comment"># 如果在调用装饰器时为给传参数，则默认值为None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="comment"># 在装饰器中声明一个变量，用于保存类的实例，那么这个实例对象将始终是通过一个实例对象</span></span><br><span class="line">        instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(cls)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">'Hello inner'</span>)</span><br><span class="line">            print(<span class="string">"装饰器的参数为：&#123;&#125;"</span>.format(arg))</span><br><span class="line">            print(<span class="string">'class name: &#123;&#125;'</span>.format(cls.__name__))</span><br><span class="line">            <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">                instances[cls] = cls(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> instances[cls]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象是类，且带参数</span></span><br><span class="line"><span class="meta">@singleton('hello')</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.id = args[<span class="number">0</span>]</span><br><span class="line">        self.name = kwargs.get(<span class="string">'name_dict'</span>).get(self.id)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"her name is &#123;&#125;"</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化装饰后的类</span></span><br><span class="line">print(Foo.__name__)</span><br><span class="line">foo = Foo(<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, name_dict=&#123;<span class="string">'1'</span>: <span class="string">'Lucy'</span>, <span class="string">'2'</span>: <span class="string">'Linda'</span>, <span class="string">'3'</span>: <span class="string">'Mary'</span>&#125;)</span><br><span class="line">foo.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">装饰器的参数为：hello</span></span><br><span class="line"><span class="string">class name: Foo</span></span><br><span class="line"><span class="string">her name is Lucy</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里与（4）类似，都是带有参数的装饰器，且装饰器为函数，需要写三层嵌套函数，最外一层用来传递装饰器的参数。上面的装饰器即带参数也带返回值，先执行time_decorator(‘hello’)，返回wrapper函数的应用，然后使用wrapper对函数foo进行装饰，内层inner使用的是<code>*args,**kwargs</code>接收可变参数和关键字参数，具体运行顺序看结果应该不难理解。</p>
</blockquote>
<ul>
<li><strong>装饰器自身为类</strong></li>
</ul>
<blockquote>
<p>类装饰器本质上和函数装饰器原理、作用相同，都是为其它函数增加额外的功能。但是相比于函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器可以直接依靠类内部的<strong>call</strong>方法来实现，当使用 @ 形式将类装饰器附加到函数上时，就会调用类装饰器的<strong>call</strong>方法。而不需要向函数装饰器那样，在装饰器函数中定义嵌套函数，来实现装饰功能。</p>
</blockquote>
<p>(1). 被装饰的对象为函数，且不带参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器是类，且不带参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化函数只会调用一次，当第二次装饰的时候，这一步就滤过了</span></span><br><span class="line">        print(<span class="string">'decorator init'</span>)</span><br><span class="line">        print(<span class="string">'func name is &#123;&#125;'</span>.format(func.__name__))</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'装饰器中的功能：&#123;&#125; 睡眠3秒'</span>.format(self.func.__name__))</span><br><span class="line">        start = time.time()</span><br><span class="line">        res = self.func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(self.func.__name__, end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且不带参数</span></span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"foo is running."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.func.__name__)</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator init</span></span><br><span class="line"><span class="string">func name is foo</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">装饰器中的功能：foo 睡眠3秒</span></span><br><span class="line"><span class="string">foo is running.</span></span><br><span class="line"><span class="string">方法foo用时:3.000671863555908秒</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>装饰器为类时，调用<strong>init</strong>方法创建实例、传递参数，并调用<strong>call</strong>方法实现对被装饰函数功能的添加。</p>
</blockquote>
<p>(2). 被装饰的对象为函数，且带参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器是类，且不带参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化函数只会调用一次，当第二次装饰的时候，这一步就滤过了</span></span><br><span class="line">        print(<span class="string">'decorator init'</span>)</span><br><span class="line">        print(<span class="string">'func name is &#123;&#125;'</span>.format(func.__name__))</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">'装饰器中的功能：&#123;&#125; 睡眠3秒'</span>.format(self.func.__name__))</span><br><span class="line">        start = time.time()</span><br><span class="line">        res = self.func(name)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(self.func.__name__, end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且带参数</span></span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"hello "</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.func.__name__)</span><br><span class="line">foo(<span class="string">'lucy'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator init</span></span><br><span class="line"><span class="string">func name is foo</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">装饰器中的功能：foo 睡眠3秒</span></span><br><span class="line"><span class="string">hello lucy</span></span><br><span class="line"><span class="string">方法foo用时:3.0009634494781494秒</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当被装饰的函数，且带参数时，需要在装饰器类的<strong>call</strong>中添加一致的参数name，调用func对象时也需要加上一致的参数name，并且返回了以reurn inner形式返回闭包函数，具体调用过程看结果应该不难理解。</p>
</blockquote>
<blockquote>
<p>当然，如果被装饰函数存在多个参数时，这里使用了python中动态参数的概念，利用<code>(*args, **kwargs)</code>来接收可变参数和关键字参数，这样装饰器就可以支持任意的组合参数的函数了。装饰器修改如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器是类，且不带参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化函数只会调用一次，当第二次装饰的时候，这一步就滤过了</span></span><br><span class="line">        print(<span class="string">'decorator init'</span>)</span><br><span class="line">        print(<span class="string">'func name is &#123;&#125;'</span>.format(func.__name__))</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'装饰器中的功能：&#123;&#125; 睡眠3秒'</span>.format(self.func.__name__))</span><br><span class="line">        start = time.time()</span><br><span class="line">        res = self.func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(self.func.__name__, end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且带参数</span></span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"hello "</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.func.__name__)</span><br><span class="line">foo(<span class="string">'lucy'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator init</span></span><br><span class="line"><span class="string">func name is foo</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">装饰器中的功能：foo 睡眠3秒</span></span><br><span class="line"><span class="string">hello lucy</span></span><br><span class="line"><span class="string">方法foo用时:3.000622510910034秒</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>(3). 被装饰的对象为函数，且带返回值  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器是类，且不带参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化函数只会调用一次，当第二次装饰的时候，这一步就滤过了</span></span><br><span class="line">        print(<span class="string">'decorator init'</span>)</span><br><span class="line">        print(<span class="string">'func name is &#123;&#125;'</span>.format(func.__name__))</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'装饰器中的功能：&#123;&#125; 睡眠3秒'</span>.format(self.func.__name__))</span><br><span class="line">        start = time.time()</span><br><span class="line">        res = self.func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(self.func.__name__, end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且带返回值</span></span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"foo is running."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"this is foo's return value"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.func.__name__)</span><br><span class="line">res = foo()</span><br><span class="line">print(<span class="string">'返回值：%s'</span> % res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator init</span></span><br><span class="line"><span class="string">func name is foo</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">装饰器中的功能：foo 睡眠3秒</span></span><br><span class="line"><span class="string">foo is running.</span></span><br><span class="line"><span class="string">方法foo用时:3.0008039474487305秒</span></span><br><span class="line"><span class="string">返回值：this is foo's return value</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>和之前装饰器是函数一样，若被装饰的函数是带返回值的，闭包函数inner中，调用func()时必须相应的带返回值，不然装饰函数时，也不进行返回，默认为None。</p>
</blockquote>
<p>(4). 被装饰的对象为函数，且装饰器带参数也有返回值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器是类，且带参数带返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg=None)</span>:</span>  <span class="comment"># 如果在调用装饰器时为给传参数，则默认值为None</span></span><br><span class="line">        print(<span class="string">'decorator init'</span>)</span><br><span class="line">        self.arg = arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)  # 保证装饰过的函数__name__属性不变</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">"Hello inner"</span>)</span><br><span class="line">            print(<span class="string">'装饰器的参数为：&#123;&#125;'</span>.format(self.arg))</span><br><span class="line">            print(<span class="string">'装饰器中的功能：&#123;&#125; 睡眠3秒'</span>.format(func.__name__))</span><br><span class="line">            start = time.time()</span><br><span class="line">            res = func(*args, **kwargs)</span><br><span class="line">            end = time.time()</span><br><span class="line">            print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(func.__name__, end - start))</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且不带参数</span></span><br><span class="line"><span class="meta">@Decorator('hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"foo is running."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"this is foo's return value"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.__name__)</span><br><span class="line">res = foo()</span><br><span class="line">print(<span class="string">'返回值：%s'</span> % res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator init</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">装饰器的参数为：hello</span></span><br><span class="line"><span class="string">装饰器中的功能：foo 睡眠3秒</span></span><br><span class="line"><span class="string">foo is running.</span></span><br><span class="line"><span class="string">类foo用时:3.000250816345215秒</span></span><br><span class="line"><span class="string">返回值：this is foo's return value</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>和之前装饰器是函数一样，带有参数的装饰器类，会把被装饰函数所带的参数传递给装饰器<strong>init</strong>进行初始化，而<strong>call</strong>作为外层函数接收被装饰函数的函数名，作为参数传递给内层函数inner，这里需要注意的是func传入，不需要在前面加self了，其他的跟函数装饰函数很相似，可以通过结果去理解整个装饰器的运行过程。</p>
</blockquote>
<p>(5). 被装饰的对象为类，且不带参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器是类，且不带参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化函数只会调用一次，当第二次装饰的时候，这一步就滤过了</span></span><br><span class="line">        print(<span class="string">'decorator init'</span>)</span><br><span class="line">        print(<span class="string">'class name is &#123;&#125;'</span>.format(func.__name__))</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'装饰器中的功能：&#123;&#125; 睡眠3秒'</span>.format(self.func.__name__))</span><br><span class="line">        start = time.time()</span><br><span class="line">        res = self.func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'类&#123;&#125;用时:&#123;&#125;秒'</span>.format(self.func.__name__, end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且不带参数</span></span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'lucy'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line">        print(<span class="string">"her name is &#123;&#125;"</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化装饰后的类</span></span><br><span class="line">print(<span class="string">"类名：&#123;&#125;"</span>.format(Foo.func.__name__))</span><br><span class="line">foo = Foo()</span><br><span class="line">foo.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator init</span></span><br><span class="line"><span class="string">func name is Foo</span></span><br><span class="line"><span class="string">类名：Foo</span></span><br><span class="line"><span class="string">装饰器中的功能：Foo 睡眠3秒</span></span><br><span class="line"><span class="string">类Foo用时:0.0秒</span></span><br><span class="line"><span class="string">her name is lucy</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>跟函数装饰器装饰类一样，这里把类Foo通过@Decorator类装饰器传递给参数func，但这个类装饰器没有<strong>get</strong>方法，无法返回装饰后的类，而是进行初始化。第二次调用，这时类Foo()就相当于调用了装饰器的<strong>call</strong>方法，在里面调用self.func()方法</p>
</blockquote>
<p>(6). 被装饰的对象为类，且带参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器是类，且不带参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化函数只会调用一次，当第二次装饰的时候，这一步就滤过了</span></span><br><span class="line">        print(<span class="string">'decorator init'</span>)</span><br><span class="line">        print(<span class="string">'class name is &#123;&#125;'</span>.format(func.__name__))</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'装饰器中的功能：&#123;&#125; 睡眠3秒'</span>.format(self.func.__name__))</span><br><span class="line">        start = time.time()</span><br><span class="line">        res = self.func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'类&#123;&#125;用时:&#123;&#125;秒'</span>.format(self.func.__name__, end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为类，且带参数</span></span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.id = args[<span class="number">0</span>]</span><br><span class="line">        self.name = kwargs.get(<span class="string">'name_dict'</span>).get(self.id)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"her name is &#123;&#125;"</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化装饰后的类</span></span><br><span class="line">print(<span class="string">"类名：&#123;&#125;"</span>.format(Foo.func.__name__))</span><br><span class="line">foo = Foo(<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, name_dict=&#123;<span class="string">'1'</span>: <span class="string">'Lucy'</span>, <span class="string">'2'</span>: <span class="string">'Linda'</span>, <span class="string">'3'</span>: <span class="string">'Mary'</span>&#125;)</span><br><span class="line">foo.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator init</span></span><br><span class="line"><span class="string">class name is Foo</span></span><br><span class="line"><span class="string">类名：Foo</span></span><br><span class="line"><span class="string">装饰器中的功能：Foo 睡眠3秒</span></span><br><span class="line"><span class="string">方法Foo用时:0.0秒</span></span><br><span class="line"><span class="string">her name is Lucy</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>(7). 被装饰的对象为类，且装饰器带参数也有返回值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器是类，且带参数带返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg=None)</span>:</span>  <span class="comment"># 如果在调用装饰器时为给传参数，则默认值为None</span></span><br><span class="line">        print(<span class="string">'decorator init'</span>)</span><br><span class="line">        self.arg = arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)  # 保证装饰过的函数__name__属性不变</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">"Hello inner"</span>)</span><br><span class="line">            print(<span class="string">'装饰器的参数为：&#123;&#125;'</span>.format(self.arg))</span><br><span class="line">            print(<span class="string">'装饰器中的功能：&#123;&#125; 睡眠3秒'</span>.format(func.__name__))</span><br><span class="line">            start = time.time()</span><br><span class="line">            res = func(*args, **kwargs)</span><br><span class="line">            end = time.time()</span><br><span class="line">            print(<span class="string">'类&#123;&#125;用时:&#123;&#125;秒'</span>.format(func.__name__, end - start))</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为类，且带参数</span></span><br><span class="line"><span class="meta">@Decorator('hello')</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.id = args[<span class="number">0</span>]</span><br><span class="line">        self.name = kwargs.get(<span class="string">'name_dict'</span>).get(self.id)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"her name is &#123;&#125;"</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化装饰后的类</span></span><br><span class="line">print(<span class="string">"类名：&#123;&#125;"</span>.format(Foo.func.__name__))</span><br><span class="line">foo = Foo(<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, name_dict=&#123;<span class="string">'1'</span>: <span class="string">'Lucy'</span>, <span class="string">'2'</span>: <span class="string">'Linda'</span>, <span class="string">'3'</span>: <span class="string">'Mary'</span>&#125;)</span><br><span class="line">foo.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator init</span></span><br><span class="line"><span class="string">类名：Foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">装饰器的参数为：hello</span></span><br><span class="line"><span class="string">装饰器中的功能：Foo 睡眠3秒</span></span><br><span class="line"><span class="string">类Foo用时:0.0秒</span></span><br><span class="line"><span class="string">her name is Lucy</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特殊的装饰器(类静态属性装饰器)</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类静态属性装饰器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, height, weigth)</span>:</span></span><br><span class="line">        self.height = height</span><br><span class="line">        self.weigth = weigth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ratio</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.height / self.weigth</span><br><span class="line"></span><br><span class="line">foo = Foo(<span class="number">176</span>, <span class="number">120</span>)</span><br><span class="line">print(foo.ratio)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为：1.4666666666666666</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中，@property是一个特殊的装饰器，把ratio方法变成一个属性，所以调用的时候是foo.ratio而不是foo.ratio()。这类特殊装饰器需要python的特定的属性和机制的支持才可以实现，不同特性的装饰器所需机制不同。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实现@property装饰器效果</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prop</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        self.arg = arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.arg(instance)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用效果与原生的@property装饰器的一样</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, height, weigth)</span>:</span></span><br><span class="line">        self.height = height</span><br><span class="line">        self.weigth = weigth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Prop</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ratio</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.height / self.weigth</span><br><span class="line"></span><br><span class="line">foo = Foo(<span class="number">176</span>, <span class="number">120</span>)</span><br><span class="line">print(foo.ratio)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为：1.4666666666666666</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>经典的装饰器装饰类，通过setattr魔术方法，对Person类进行修改，name作为类属性，<code>name = TypeCheck(name,required_type)</code>，这样修改了Person类，使得Person类有了两个类变量，一个是<code>name = TypeCheck(&#39;name&#39;, required_type)</code>，另一个是<code>age = TypeCheck(&#39;age&#39;, required_type)</code>。</p>
</blockquote>
<blockquote>
<p>因此实例化时<code>Person(&#39;lucy&#39;, 18)</code>，self.name中name不是实例变量而是类变量，会调用描述器TypeCheck，赋值的时候，就会调用<strong>set</strong>方法，取值的时候会调用<strong>get</strong>方法。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 经典的装饰器装饰类</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeCheck</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, srcType, dstType)</span>:</span></span><br><span class="line">        self.srcType = srcType</span><br><span class="line">        self.dstType = dstType</span><br><span class="line"></span><br><span class="line">    <span class="comment"># instance == a, cls == A</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.srcType]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(value, self, dstType):</span><br><span class="line">            instance.__dict__[self.srcType] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'&#123;&#125; should be &#123;&#125;'</span>.format(value, self.dstType))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器自身是一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">type_assert</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wraps</span><span class="params">(*args)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> name, required_type <span class="keyword">in</span> kwargs.items():</span><br><span class="line">                setattr(cls, name, TypeCheck(name, required_type))</span><br><span class="line">            <span class="keyword">return</span> cls(*args)  <span class="comment"># 这里是实例化新的Person类后返回实例对象，也就是p</span></span><br><span class="line">        <span class="keyword">return</span> wraps</span><br><span class="line">    <span class="keyword">return</span> dec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰对象是一个类，且带参数</span></span><br><span class="line"><span class="meta">@type_assert(name=str, age=int)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化新的Person类，这里相对于调用的是wraps函数</span></span><br><span class="line">p = Person(<span class="string">'lucy'</span>, <span class="number">18</span>)</span><br><span class="line">print(p.name)</span><br><span class="line">print(p.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器修改后的Person类为下面这个新的Person类，因此实例化Person的时候，调用的是下面这个新的Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name = TypeCheck(<span class="string">'name'</span>, str)</span><br><span class="line">    age = TypeCheck(<span class="string">'age'</span>, int)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name:str, age:int)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure>

<ul>
<li>装饰器顺序</li>
</ul>
<blockquote>
<p>当有两个或两个以上装饰器装饰一个函数时，装饰器是从上到下执行，从下向上装饰，语法糖语句执行流程的顺序是从下往上（就近原则，靠近函数定义的先执行）。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个装饰器wrapper1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper1</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"wapper1"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"inner1"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;b&gt;'</span> + func() + <span class="string">'&lt;/b&gt;'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个装饰器wrapper2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper2</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"wapper2"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"inner2"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;i&gt;'</span> + func() + <span class="string">'&lt;/i&gt;'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个装饰器</span></span><br><span class="line"><span class="meta">@wrapper1</span></span><br><span class="line"><span class="meta">@wrapper2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"foo"</span>)</span><br><span class="line">    print(<span class="string">"end"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">res = foo()</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">wapper2</span></span><br><span class="line"><span class="string">wapper1</span></span><br><span class="line"><span class="string">inner1</span></span><br><span class="line"><span class="string">inner2</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">&lt;b&gt;&lt;i&gt;hello&lt;/i&gt;&lt;/b&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据结果，函数foo先用wapper2装饰器进行装饰，接着是用wrapper1再进行装饰，但是在调用过程中又是先执行第一个装饰器wrapper1，然后在执行第二个装饰器wrapper2。</p>
</blockquote>
<blockquote>
<p>具体分析其过程，就近原则先用第二个装饰器wrapper2进行装饰，@wrapper2等价于<code>foo = wrapper2(foo)</code>，此时括号内的foo即是函数名，而外部的foo实际指向的是wrapper2的inner。<br>@wrapper1等价于<code>foo = wrapper1(foo)</code>，此时括号内的foo指向的是<code>wrapper2.inner</code>，而外部的foo指向wrapper1的inner。</p>
</blockquote>
<blockquote>
<p>当执行到@wrapper1时要对下面的函数进行装饰，此时解释器继续往下走，发现并不是一个函数名，而又是一个装饰器，这时@wrapper1装饰器暂停执行，而接着执行接下来的装饰器@wrapper2，接着把foo函数名传入到装饰器wrapper2函数func，从而打印”wrapper2”，在wrapper2装饰完后，此时的foo指向wrapper2的inner函数地址，这是又返回来执行@wrapper1，接着把新的foo（即wrapper2.inner）传入wrapper装饰器函数中，因此打印”wrapper1”，在wrapper1装饰完后，此时的foo指向wrapper1的inner函数地址。</p>
</blockquote>
<blockquote>
<p>在调用foo函数的时候，根据上述分析，此时foo指向wrapper1的inner函数地址，故打印”inner1”，接下来调用func()的时候，实际上调用的是wrapper2.inner()函数，所以会打印”inner2”，而wrapper2.inner()函数中，调用的func()才是最初传入的foo函数，所以打印”foo”和”end”，最后一层层调用完后打印的”<code>&lt;b&gt;&lt;i&gt;hello&lt;/i&gt;&lt;/b&gt;</code>“。</p>
</blockquote>
<ul>
<li>通用万能装饰</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_all</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"万能装饰器"</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<h2 id="21-浅拷贝与深拷贝"><a href="#21-浅拷贝与深拷贝" class="headerlink" title="21. 浅拷贝与深拷贝"></a>21. 浅拷贝与深拷贝</h2><blockquote>
<p>赋值：对象赋值实际上是对象的引用。类似于改名字，内部结构、内存空间地址都一样，赋值给另一个变量的时候，并没有拷贝这个对象，而是拷贝了这个对象的引用。</p>
</blockquote>
<blockquote>
<p>浅拷贝：另开辟新内存空间，只拷贝父结构，没有拷贝子对象，所以原始数据改变，子对象会改变。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line">a.append(<span class="number">5</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果1</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a = [1, 2, 3, ['a', 'b'], 5]</span></span><br><span class="line"><span class="string">b = [1, 2, 3, ['a', 'b']]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 若a的子对象['a', 'b']发生改变</span></span><br><span class="line">a[<span class="number">3</span>].append(<span class="string">'c'</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果2</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a = [1, 2, 3, ['a', 'b', 'c'], 5]</span></span><br><span class="line"><span class="string">b = [1, 2, 3, ['a', 'b', 'c']]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>深拷贝：另开辟新内存空间，拷贝对象里面所有的元素，包括父子任何元素，与原始对象已经无任何关系，所以原始对象改变不会造成深拷贝后任何父子元素的改变。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br><span class="line">c = copy.deepcopy(a)</span><br><span class="line">a.append(<span class="number">5</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果1</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a = [1, 2, 3, ['a', 'b'], 5]</span></span><br><span class="line"><span class="string">c = [1, 2, 3, ['a', 'b']]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 若a的子对象['a', 'b']发生改变，而C始终不变</span></span><br><span class="line">a[<span class="number">3</span>].append(<span class="string">'c'</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果2</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a = [1, 2, 3, ['a', 'b', 'c'], 5]</span></span><br><span class="line"><span class="string">b = [1, 2, 3, ['a', 'b']]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="22-设计模式"><a href="#22-设计模式" class="headerlink" title="22. 设计模式"></a>22. 设计模式</h2><p><strong><a href="https://github.com/weilanhanf/python-design-patterns" target="_blank" rel="noopener">Python 实现23种设计模式</a></strong><br><strong><a href="https://www.cnblogs.com/baxianhua/p/11770434.html" target="_blank" rel="noopener">Python 23种设计模式全</a></strong><br><strong><a href="https://refactoringguru.cn/design-patterns/python" target="_blank" rel="noopener">Python 常用设计模式</a></strong><br><strong><a href="https://www.cnblogs.com/onepiece-andy/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">python 设计模式</a></strong></p>
<h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1. 工厂模式"></a>1. 工厂模式</h3><ul>
<li>简单工厂模式的不足</li>
</ul>
<blockquote>
<p>在简单工厂模式中，只提供了一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它知道每个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点是当有新产品要加入时，必须修改工厂类，加入必要的处理逻辑，这违背了“开闭原则”。在简单工厂模式中，所有的产品都是由同一个工厂创建的，工厂类的职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一个问题。</p>
</blockquote>
<ul>
<li>工厂方法模式</li>
</ul>
<blockquote>
<p>定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p>
</blockquote>
<blockquote>
<p>工厂方法模式就是简单工厂模式的进一步抽象。由于面向对象的多态性，工厂方法模式保持了简单工厂的优点，同时克服了它的缺点。工厂方法模式中，核心的工厂被提升为一个抽象类，将具体创建工作交给它的子类完成。这个抽象的工厂类仅规定具体工厂实现的接口，而不明确指出如何实例化一个产品类，这使得工厂方法模式允许系统在不修改原有产品结构的情况下轻重的引进新产品。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码出处：https://www.cnblogs.com/onepiece-andy/p/python_factory_method_pattern.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">场景:雷锋工厂,不关心执行者,只关心执行结果</span></span><br><span class="line"><span class="string">创建一个抽象工厂类CreateLeiFeng和一个抽象对象类LeiFeng，当创建具体leifeng对象-Undergradiate去dosomething时，使用继承抽象工厂的UndergraduateFactory工厂类，该类返回一个Undergradiate实例，如果还要去做另一个dosomething时，再创建一个VolunteerFactory工厂方法创建创建一个Volunteer实例就可以了</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeiFeng</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sweep</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"扫地"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Wash</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"洗衣"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BuyRice</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"买米"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IFactory</span><span class="params">(LeiFeng)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CreateLeiFeng</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 大学生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Undergraduate</span><span class="params">(LeiFeng)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增社区服务者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Volunteer</span><span class="params">(LeiFeng)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 学习雷锋的大学生工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndergraduateFactory</span><span class="params">(IFactory)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CreateLeiFeng</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Undergraduate()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增一个社区服务者的工厂e</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolunteerFactory</span><span class="params">(IFactory)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CreateLeiFeng</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Volunteer()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    student = UndergraduateFactory()</span><br><span class="line">    volunteer = VolunteerFactory()</span><br><span class="line">    student.BuyRice()</span><br><span class="line">    student.Sweep()</span><br><span class="line">    volunteer.Wash()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">买米</span></span><br><span class="line"><span class="string">扫地</span></span><br><span class="line"><span class="string">洗衣</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>抽象工厂模式</li>
</ul>
<blockquote>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。</p>
</blockquote>
<blockquote>
<p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。当系统说提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时，就可以使用抽象工厂模式，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品，当一个工程等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂模式更为简单、更有效率。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码出处：https://www.cnblogs.com/onepiece-andy/p/python-abstract-factory-pattern.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">设计模式——抽象工厂模式</span></span><br><span class="line"><span class="string">抽象工厂模式(Abstract Factory Pattern):提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的类。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象用户表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_user</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_user</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象部门表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_department</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_department</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作具体User数据库类-Mysql</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlUser</span><span class="params">(User)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_user</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'MysqlUser get User'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_user</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'MysqlUser insert User'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作具体Department数据库类-Mysql</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlDepartment</span><span class="params">(Department)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_department</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'MysqlDepartment get department'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_department</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'MysqlDepartment insert department'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作具体User数据库-Orcal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrcaleUser</span><span class="params">(User)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_user</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'OrcalUser get User'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_user</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'OrcalUser insert User'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作具体Department数据库类-Orcal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrcaleDepartment</span><span class="params">(Department)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_department</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'OrcalDepartment get department'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_department</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'OrcalDepartment insert department'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_department</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlFactory</span><span class="params">(AbstractFactory)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> MysqlUser()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_department</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> MysqlDepartment()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrcaleFactory</span><span class="params">(AbstractFactory)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> OrcaleUser()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_department</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> OrcaleDepartment()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = [<span class="string">'Mysql'</span>, <span class="string">'Orcale'</span>]</span><br><span class="line">    <span class="keyword">for</span> db <span class="keyword">in</span> s:</span><br><span class="line">        myfactory = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> db == <span class="string">'Mysql'</span>:</span><br><span class="line">            myfactory = MysqlFactory()</span><br><span class="line">        <span class="keyword">elif</span> db == <span class="string">'Orcale'</span>:</span><br><span class="line">            myfactory = OrcaleFactory()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"不支持的数据库类型"</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        user = myfactory.create_user()</span><br><span class="line">        department = myfactory.create_department()</span><br><span class="line">        user.insert_user()</span><br><span class="line">        user.get_user()</span><br><span class="line">        department.insert_department()</span><br><span class="line">        department.get_department()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">MysqlUser insert User</span></span><br><span class="line"><span class="string">MysqlUser get User</span></span><br><span class="line"><span class="string">MysqlDepartment insert department</span></span><br><span class="line"><span class="string">MysqlDepartment get department</span></span><br><span class="line"><span class="string">OrcalUser insert User</span></span><br><span class="line"><span class="string">OrcalUser get User</span></span><br><span class="line"><span class="string">OrcalDepartment insert department</span></span><br><span class="line"><span class="string">OrcalDepartment get department</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>优点：具体工厂类如MysqlFactory在一个应用中只需要初始化一次，这样改动一个具体工厂变得很容易，只需要改变具体工厂就可以改变整个产品的配置。具体的创建实例过程与客户端分离，客户端通过他们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户端代码中。</p>
</blockquote>
<blockquote>
<p>缺点：在新增一个具体工厂就需要增加多个类才能实现。</p>
</blockquote>
<ul>
<li><p>工厂方法模式与抽象工厂模式对比</p>
<ul>
<li>工厂模式的优点：</li>
</ul>
<blockquote>
<p>工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节 能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部，在系统中加入新产品时，完全符合开闭原则。</p>
</blockquote>
<ul>
<li>工厂模式的缺点：</li>
</ul>
<blockquote>
<p>系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，会给系统带来一些额外的开销 增加了系统的抽象性和理解难度。</p>
</blockquote>
<ul>
<li>工厂模式的适用环境：</li>
</ul>
<blockquote>
<p>客户端不知道它所需要的对象的类（客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体产品对象由具体工厂类创建） 抽象工厂类通过其子类来指定创建哪个对象。</p>
</blockquote>
<ul>
<li>抽象模式的优点：</li>
</ul>
<blockquote>
<p>隔离了具体类的生成，使得客户端并不需要知道什么被创建，当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象，增加新的产品族很方便，无须修改已有系统，符合开闭原则。</p>
</blockquote>
<ul>
<li>抽象模式的缺点：</li>
</ul>
<blockquote>
<p>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则。</p>
</blockquote>
<ul>
<li>抽象模式的适用环境：</li>
</ul>
<blockquote>
<p>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，系统中有多于一个的产品族，但每次只使用其中某一产品族，属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</p>
</blockquote>
</li>
</ul>
<h3 id="2-构造模式"><a href="#2-构造模式" class="headerlink" title="2. 构造模式"></a>2. 构造模式</h3><h3 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4. 原型模式"></a>4. 原型模式</h3><blockquote>
<p>原型模式关注的是大量相同对象或者相似对象的创建问题，意图在于通过复制一个已经存在的实例来获得一个新的实例，以避免重复创建此类实例带来的开销。被复制的实例就是这个“原型”，这个原型是可定制的。</p>
</blockquote>
<ul>
<li>原型模式的实现</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码来源：https://www.cnblogs.com/onepiece-andy/p/python_prototype_pattern.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">原型模式(Prototype Pattern):用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象</span></span><br><span class="line"><span class="string">原型模式是用场景:需要大量的基于某个基础原型进行微量修改而得到新原型时使用</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> copy, deepcopy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原型抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clone</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deep_clone</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作经历类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkExperience</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.timearea = <span class="string">''</span></span><br><span class="line">        self.company = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_workexperience</span><span class="params">(self, timearea, company)</span>:</span></span><br><span class="line">        self.timearea = timearea</span><br><span class="line">        self.company = company</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简历类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resume</span><span class="params">(Prototype)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.workexperience = WorkExperience()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_personinfo</span><span class="params">(self, sex, age)</span>:</span></span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_workexperience</span><span class="params">(self, timearea, company)</span>:</span></span><br><span class="line">        self.workexperience.set_workexperience(timearea, company)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name)</span><br><span class="line">        print(self.sex, self.age)</span><br><span class="line">        print(<span class="string">"工作经历"</span>, self.workexperience.timearea, self.workexperience.company)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clone</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> copy(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deep_clone</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> deepcopy(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__  == <span class="string">'__main__'</span>:</span><br><span class="line">    obj1 = Resume(<span class="string">'Liming'</span>)</span><br><span class="line">    obj2 = obj1.clone()  <span class="comment"># 浅拷贝对象</span></span><br><span class="line">    obj3 = obj1.deep_clone()  <span class="comment"># 深拷贝对象</span></span><br><span class="line"></span><br><span class="line">    obj1.set_personinfo(<span class="string">'男'</span>, <span class="number">22</span>)</span><br><span class="line">    obj1.set_workexperience(<span class="string">'2010-2018'</span>, <span class="string">'aa'</span>)</span><br><span class="line">    obj2.set_personinfo(<span class="string">'男'</span>, <span class="number">23</span>)</span><br><span class="line">    obj2.set_workexperience(<span class="string">'2010-2019'</span>, <span class="string">'bb'</span>)  <span class="comment"># 修改浅拷贝的对象工作经历</span></span><br><span class="line">    obj3.set_personinfo(<span class="string">'男'</span>, <span class="number">24</span>)</span><br><span class="line">    obj3.set_workexperience(<span class="string">'2010-2020'</span>, <span class="string">'cc'</span>)  <span class="comment"># 修改深拷贝的对象的工作经历</span></span><br><span class="line"></span><br><span class="line">    obj1.display()</span><br><span class="line">    obj2.display()</span><br><span class="line">    obj3.display()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Liming</span></span><br><span class="line"><span class="string">男 22</span></span><br><span class="line"><span class="string">工作经历 2010-2019 bb</span></span><br><span class="line"><span class="string">Liming</span></span><br><span class="line"><span class="string">男 23</span></span><br><span class="line"><span class="string">工作经历 2010-2019 bb</span></span><br><span class="line"><span class="string">Liming</span></span><br><span class="line"><span class="string">男 24</span></span><br><span class="line"><span class="string">工作经历 2010-2020 cc</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>原型模式的优点</li>
</ul>
<blockquote>
<p>原型摸手机用于创建复杂的或者耗时的实例，复制一个已经存在的实例使程序运行高效，相对于工厂模式，原型模式减少了之类的构建。</p>
</blockquote>
<ul>
<li>原型模式的缺点</li>
</ul>
<blockquote>
<p>每个产品类都必须配置一个克隆方法，并且这个克隆方法需要对类的功能进行整体考虑。</p>
</blockquote>
<ul>
<li>原型模式的应用<ul>
<li>当一个系统应该独立于它的产品的创建、构成和表示时；</li>
<li>当实例化的类是在运行时刻指定时，例如通过动态装载；</li>
<li>为了避免创建一个与产品类层次平行的工厂类层次时；</li>
</ul>
</li>
</ul>
<h3 id="5-单例模式-1"><a href="#5-单例模式-1" class="headerlink" title="5. 单例模式"></a>5. 单例模式</h3><blockquote>
<p>单利模式是一种创建型的设计模式，保证某一个类仅有一个实例，而且提供一个访问该实例的全局访问点。比如，最常见的就是当一个office文档已经被打开时，通过另一个窗口再次访问时，系统就会提示此文档已经被占用，智能以只读的方式打开。</p>
</blockquote>
<ul>
<li><p>单例模式的实现步骤</p>
<ul>
<li>(1). 私有化构造函数，防止其他类可以创建这个类的对象；</li>
<li>(2). 在本类中创建唯一实例对象（因为构造函数私有化了，所以单例类的唯一实例对象只能在单例类里面创建），使用一个室友静态成员变量保存。</li>
<li>(3). 对外提供一个公开的静态函数，用于获取这个唯一的实例对象</li>
</ul>
</li>
<li><p>单例模式的实现方式</p>
</li>
</ul>
<p><strong>可以参考前面总结的，<a href="#5-单例模式">5. 单例模式</a></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码出处：https://www.cnblogs.com/onepiece-andy/p/python-singleton-pattern.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># # -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">python中模块化的操作,可以代替单例模式,生成一个类的实例作为全局变量,其他地方只引用这个实例就可以实现单例，也就是import 方式</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为__new__在__init__前被执行，利用__new__实现单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'__instance'</span>):  <span class="comment"># 创建过的单例带有属性__instance</span></span><br><span class="line">            cls.__instance = super(Singleton1, cls).__new__(cls, *args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 共享属性</span></span><br><span class="line"><span class="comment"># 创建实例时利用__dict__指向同一个字典，这样他们具有相同的属性和方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span><span class="params">(object)</span>:</span></span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        ob = super(Singleton2, cls).__new__(cls, *args, **kwargs)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        <span class="keyword">return</span> ob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用元类在创建方法时使用__metaclass__来创建</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, dct)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'__instance'</span>):</span><br><span class="line">        cls.__instance = super(Singleton3, cls).__new__(cls, name, bases, dct)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton4</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    instance = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_single</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> _single</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass1</span><span class="params">(Singleton1)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass1</span><span class="params">(Singleton1)</span>:</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass3</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = Singleton3</span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass4</span><span class="params">(object)</span>:</span></span><br><span class="line">    a = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s1 = Myclass1()</span><br><span class="line">    s2 = Myclass1()</span><br><span class="line">    print(s1.a, id(s1.a), id(s2.a))</span><br><span class="line"></span><br><span class="line">    s3 = Myclass2()</span><br><span class="line">    s4 = Myclass2()</span><br><span class="line">    print(s3.a, id(s3.a), id(s4.a))</span><br><span class="line"></span><br><span class="line">    s5 = Myclass3()</span><br><span class="line">    s6 = Myclass3()</span><br><span class="line">    print(s5.a, id(s5.a), id(s6.a))</span><br><span class="line"></span><br><span class="line">    s7 = Myclass4()</span><br><span class="line">    s8 = Myclass4()</span><br><span class="line">    print(s7.a, id(s7.a), id(s8.a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1 140722211689280 140722211689280</span></span><br><span class="line"><span class="string">2 140722211689312 140722211689312</span></span><br><span class="line"><span class="string">3 140722211689344 140722211689344</span></span><br><span class="line"><span class="string">4 140722211689376 140722211689376</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>单例模式的优点</p>
<ul>
<li>(1). 由于单例模式要求在全局内只有一个实例，一次可以节省内存空间；</li>
<li>(2). 全局只有一个访问点，可以更好地进行数据同步控制，避免多重占用；</li>
<li>(3). 单例可以长驻内存，减少系统开销。</li>
</ul>
</li>
<li><p>单例模式的缺点</p>
<ul>
<li>(1). 单例模式的扩展是比较困难的；</li>
<li>(2). 赋予了单例太多的职责，某种程度上违反了单一职责原则；</li>
<li>(3). 单例模式是并发协作软件模块中需要最先完成的，因此不利于测试；</li>
<li>(4). 单例模式在某种情况下会导致“资源瓶颈”。</li>
</ul>
</li>
<li><p>单例模式的应用举例</p>
<ul>
<li>(1). 生成全局唯一的序列号；</li>
<li>(2). 访问全局复工的唯一资源，如磁盘、总线等；</li>
<li>(3). 单个对象占用资源过多，如数据库等；</li>
<li>(4). 系统全局统一管理，如windows系统的资源管理器；</li>
<li>(5). 网站计数器。</li>
</ul>
</li>
</ul>
<h3 id="6-装饰模式"><a href="#6-装饰模式" class="headerlink" title="6. 装饰模式"></a>6. 装饰模式</h3><blockquote>
<p>有时为了给某个对象而不是给整个类添加一个功能，使用继承机制是添加功能的有效途径，但是不够灵活，用户不能控制对组件加边框的方式和时机，并且会导致之类膨胀。一种比较领过的方式是将组件嵌入另一个对象中，这个嵌入的对象叫做装饰。</p>
</blockquote>
<blockquote>
<p>装饰模式：动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用之类更加灵活的替代方案，以对客户同名的方式动态地给一个对象附加更多的责任，可以在不需要创建更多子类的情况下，让对象的功能得以扩展。</p>
</blockquote>
<ul>
<li>装饰模式分析</li>
</ul>
<blockquote>
<p>可以在不改变一个对象本身功能的基础上给对象增加额外的新行为，是一种用于替代继承的技术，它通过一种无须定义之类的方式给对象动态增加职责，使用对象间的关联关系取代类之间的继承关系，引入装饰类，在装饰类中既可以调用带装饰的原有类的方法，还可以增加新的方法，以扩展原有类的功能。</p>
</blockquote>
<ul>
<li><p>装饰模式的结构</p>
<ul>
<li>抽象部件(Component)：声明封装器和被封装对象的公用接口。</li>
<li>具体部件(Concrete Component)：类是被封装对象所属的类，定义了基础行为，但装饰器可以改变这些行为。</li>
<li>抽象装饰类(Decorator)：类拥有一个指向被封装对象的引用成员变量，该变量的类型应当被声明为通用部件的接口，这样它就引用具体的部件和装饰，抽象装饰类会将所有操作委派给被封装的对象。</li>
<li>具体装饰类(ConcreteDecorator)：定义了可动态添加到部件的额外行为，具体装饰类会重写抽象装饰类的方法，并在调用父类方法之前或之后进行额外的行为。</li>
</ul>
</li>
<li><p>装饰模式的实现</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码来源：https://www.cnblogs.com/onepiece-andy/p/python-decorator-pattern.html</span></span><br><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">装饰模式(Decorator Pattern):动态的给一个对象添加一些额外的职责,就增加功能来说,装饰模式比生成子类更为灵活。</span></span><br><span class="line"><span class="string">特点: 有效的把类的核心职责和装饰功能区分开,而且可以去除相关类中重复的装饰逻辑。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义对象接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"装扮的%s"</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Finery</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Decorate</span><span class="params">(self, component)</span>:</span></span><br><span class="line">        self.component = component</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.component != <span class="literal">None</span>:</span><br><span class="line">            self.component.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装扮——T恤</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TShirts</span><span class="params">(Finery)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"T恤"</span>)</span><br><span class="line">        self.component.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装扮——大裤衩</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigTrouser</span><span class="params">(Finery)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"大裤衩"</span>)</span><br><span class="line">        self.component.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装扮——人字拖</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlipFlops</span><span class="params">(Finery)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"人字拖"</span>)</span><br><span class="line">        self.component.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Person(<span class="string">'aaa'</span>)</span><br><span class="line">    ff = FlipFlops()</span><br><span class="line">    bt = BigTrouser()</span><br><span class="line">    ts = TShirts()</span><br><span class="line">    ff.Decorate(p)</span><br><span class="line">    bt.Decorate(ff)</span><br><span class="line">    ts.Decorate(bt)</span><br><span class="line">    ts.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">T恤</span></span><br><span class="line"><span class="string">大裤衩</span></span><br><span class="line"><span class="string">人字拖</span></span><br><span class="line"><span class="string">装扮的aaa</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>装饰模式的优点</li>
</ul>
<blockquote>
<p>对于扩展一个对象的功能，装饰模式比继承模式更加灵活，不会导致类的个数急剧增加，可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为，可以对一个对象进行多次装饰，具体部件类和具体装饰类可以独立变化，用户可以根据需要增加新的具体部件和具体装饰类，且原有的类库代码无需改变，符合开闭原则。</p>
</blockquote>
<ul>
<li>装饰模式的缺点</li>
</ul>
<blockquote>
<p>使用装饰模式进行系统设计时产生很多小对象，大量小对象的产生势必会占用更多的系统资源，在一定程度上影响程序的性能；比继承更加容易出错，拍错也更加困难，对于多次装饰的对象，调试的需找错误可能需要主机排查，较为繁琐。</p>
</blockquote>
<ul>
<li>装饰适用环境</li>
</ul>
<blockquote>
<p>在不影响其他对象的情况下，以动态、透明的方式传给单个对象添加职责，但不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。</p>
</blockquote>
<h3 id="7-代理模式"><a href="#7-代理模式" class="headerlink" title="7. 代理模式"></a>7. 代理模式</h3><h3 id="8-适配器模式"><a href="#8-适配器模式" class="headerlink" title="8. 适配器模式"></a>8. 适配器模式</h3><blockquote>
<p>为了解决接口不兼容的问题，引进一种接口的兼容机制，就是适配器模式，其通过提供一种适配类将第三方提供的接口转换为客户希望的接口。例如：假如你正在开发一款股票市场监测程序， 它会从不同来源下载 XML 格式的股票数据， 然后向用户呈现出美观的图表。在开发过程中， 你决定在程序中整合一个第三方智能分析函数库，但是遇到了一个问题， 那就是分析函数库只兼容 JSON 格式的数据。可以修改程序库来支持 XML，这可能需要修改部分依赖该程序库的现有代码，甚至还有更糟糕的情况， 你可能根本没有程序库的源代码， 从而无法对其进行修改。这时就可以创建一个适配器，能够转换对象接口，使其能与其他对象交互。</p>
</blockquote>
<blockquote>
<p>适配器模式：讲一个类的接口装换成客户希望的另一个接口，适配器模式让那些接口不兼容的类可以一起工作。适配器模式别名包装器(Wrapper)模式，定义中所提及的接口是指广义的接口，它可以表示一个方法的集合。</p>
</blockquote>
<ul>
<li>适配器模式的实现</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码来源：https://www.cnblogs.com/onepiece-andy/p/python-adapter-pattern.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">适配器模式(Adapter Pattern):将一个类的接口转换成为客户希望的另外一个接口.Adapter Pattern使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</span></span><br><span class="line"><span class="string">应用场景:系统数据和行为都正确,但接口不符合时,目的是使控制范围之外的一个原有对象与某个接口匹配,适配器模式主要应用于希望复用一些现存的类,但接口又与复用环境不一致的情况。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"普通请求"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">specific_request</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"特殊请求"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span><span class="params">(Target)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.adaptee = Adaptee()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.adaptee.specific_request()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    target = Adapter()</span><br><span class="line">    target.request()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">特殊请求</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>适配器模式的结构</li>
</ul>
<blockquote>
<p>目标抽象类(Target)：是客户希望调用接口</p>
</blockquote>
<blockquote>
<p>适配器类(Adapter)：通过内部包装的一个Adaptee对象把源接口转换成目标接口</p>
</blockquote>
<blockquote>
<p>适配者类(Adaptee)：需要适配的类</p>
</blockquote>
<ul>
<li>适配器模式的优点</li>
</ul>
<blockquote>
<p>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配器类，无需修改原有的结构；</p>
</blockquote>
<blockquote>
<p>增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中进行复用；</p>
</blockquote>
<blockquote>
<p>灵活性和扩展性非常好；其中类适配器模式置换一些适配者方法很方便，而对象适配者模式可以把多个不同适配者适配到同一个目标，还可以适配一个适配者的子类。</p>
</blockquote>
<ul>
<li>适配器模式的缺点</li>
</ul>
<blockquote>
<p>一次最多只能适配一个适配者类，不能同时适配多个适配者；</p>
</blockquote>
<blockquote>
<p>适配者类不能为最终类；</p>
</blockquote>
<blockquote>
<p>目标抽象类只能为接口，不能为类</p>
</blockquote>
<blockquote>
<p>对象适配器模式在适配器中置换适配者类的某些方法比较麻烦。</p>
</blockquote>
<ul>
<li>适配器模式的适用环境</li>
</ul>
<blockquote>
<p>系统需要使用一些现有的类，而这些类的就扣不符合系统的需要，甚至没有这些类的源代码；创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作。</p>
</blockquote>
<ul>
<li>适配器模式和装饰模式比较</li>
</ul>
<blockquote>
<p>适配器模式和装饰模式有一定的相似性，都起包装的作用，但二者本质上又是不同的，装饰模式的结果，是给一个对象增加了一些额外的职责，而适配器模式，则是将另一个对象进行了“伪装”。适配器可以任务是对现在业务的补偿式应用，所以尽量不要在设计阶段就使用适配器模式，在两个系统需要兼容时可以考虑使用适配器模式。</p>
</blockquote>
<h3 id="9-外观模式"><a href="#9-外观模式" class="headerlink" title="9. 外观模式"></a>9. 外观模式</h3><h3 id="10-享元模式"><a href="#10-享元模式" class="headerlink" title="10. 享元模式"></a>10. 享元模式</h3><ul>
<li>问题引出</li>
</ul>
<blockquote>
<p>如果一个软件系统在运行时所创建的相同或相似对象数量太多，将导致运行代价过高，代开系统资源浪费、性能下降等问题。如何避免系统从出现大量相同或相似的对象，同时又不影响客户端程序通过面向对象的方式对这些对象进行操作呢。例如在文字编辑软件中，把每个字符单层对象处理，并分配相应的系统空间，但是随着字符串数量的增加将会逐渐耗尽系统资源，有大量细粒度的对象从此在系统中，导致系统运行效率低下。解决上述问题就可以使用享元模式，通过共享机制来解决系统资源消耗问题。</p>
</blockquote>
<ul>
<li><p>享元模式的原理</p>
<ul>
<li><p>内部状态(Intrinic State)：存储在享元对象内部并且不会随着环境改变而改变状态，内部状态可以共享。</p>
</li>
<li><p>外部状态(Extrinsic State)：随着环境改变而改变、不可以共享状态。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后，需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。</p>
</li>
<li><p>(1). 将具有相同内部状态的对象存储在享元池中，享元池中的对象是可以实现共享的；</p>
</li>
<li><p>(2). 需要的时候将对象从享元池中取出，即可以实现对象的复用；</p>
</li>
<li><p>(3). 通过向取出的对象注入不同的外部状态，可以得到一些列相似的对象，而这些对象在内存中实际上只存储一份。</p>
</li>
</ul>
</li>
<li><p>享元模式的结构</p>
<ul>
<li>抽象享元类(Flyweight)：包含原始对象中部分能在多个对象中共享的状态。</li>
<li>具体享元类(Concrete Flyweight)：定义一个借口绑定中介者。</li>
<li>非共享具体享元类(Unshared Concrete Flyweight)：不同共享的享元类子类。</li>
<li>享元工厂类(Flyweight Factory)：用于创建并管理享元对象，确保合理的共享享元对象，当用户请求一个享元对象时，享元工厂对象提供或创建一个。</li>
</ul>
</li>
<li><p>享元模式实例</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设又一个网上咖啡选购平台，客户可以在该平台上下订单订购咖啡，平台会根据用户的位置进行线下配送</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 咖啡对象构造如下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span>:</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    price = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.price = len(name)</span><br><span class="line">        <span class="comment"># 在实际业务中，咖啡价格应该是由配置表进行配置，或者调用接口获取等但是得到，此处为了说明享元模式，将咖啡价格定位名称长度，只是简化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f"咖啡<span class="subst">&#123;self.name&#125;</span>的价格是：<span class="subst">&#123;self.price: <span class="number">.2</span>f&#125;</span> 元"</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># 对应客户顾客类</span></span><br><span class="line"><span class="string">class Customer:</span></span><br><span class="line"><span class="string">    name = ''</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __init__(self, name):</span></span><br><span class="line"><span class="string">        self.name = name</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def order(self, coffee_name):</span></span><br><span class="line"><span class="string">        print(f"顾客&#123;self.name&#125;订购了一杯&#123;coffee_name&#125;咖啡")</span></span><br><span class="line"><span class="string">        return Coffee(coffee_name)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">按照一般的处理流程，客户在网上预订咖啡，其代表用户的Customer类中生成一个Coffee类，直到交易流程结束。整个流程是没有问题的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">但是在高并发的情况下，也就是单位时间内购买咖啡的用户越来越多，生成的咖啡实例就回越来越多，系统资源消耗越来越大，避免重复实例的出现，引入咖啡工厂类能够节约系统资源。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入咖啡工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeFactory</span><span class="params">()</span>:</span></span><br><span class="line">    coffee_dict = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCoffee</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.coffee_dict.__contains__(name) == <span class="literal">False</span>:</span><br><span class="line">            self.coffee_dict[name] = Coffee(name)</span><br><span class="line">        <span class="keyword">return</span> self.coffee_dict[name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCoffeeCount</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.coffee_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 咖啡工厂中，getCoffeeCount直接返回当前实例个数，重写Customer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>:</span></span><br><span class="line">    coffee_factory = <span class="string">''</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, coffee_factory)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.coffee_factory = coffee_factory</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">order</span><span class="params">(self, coffee_name)</span>:</span></span><br><span class="line">        print(<span class="string">f"顾客<span class="subst">&#123;self.name&#125;</span>订购了一杯<span class="subst">&#123;coffee_name&#125;</span>咖啡"</span>)</span><br><span class="line">        <span class="keyword">return</span> self.coffee_factory.getCoffee(coffee_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设实际业务中，短时间很多人订了咖啡，则</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    coffee_factory = CoffeeFactory()</span><br><span class="line">    customer_1 = Customer(<span class="string">"李先生"</span>, coffee_factory)</span><br><span class="line">    customer_2 = Customer(<span class="string">"刘小姐"</span>, coffee_factory)</span><br><span class="line">    customer_3 = Customer(<span class="string">"王老板"</span>, coffee_factory)</span><br><span class="line">    c1 = customer_1.order(<span class="string">"卡布奇诺"</span>)</span><br><span class="line">    c1.show()</span><br><span class="line">    c2 = customer_2.order(<span class="string">"雀巢咖啡"</span>)</span><br><span class="line">    c2.show()</span><br><span class="line">    c3 = customer_3.order(<span class="string">"美式咖啡"</span>)</span><br><span class="line">    c3.show()</span><br><span class="line">    print(<span class="string">f"创建了<span class="subst">&#123;coffee_factory.getCoffeeCount()&#125;</span>个实例"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">顾客李先生订购了一杯卡布奇诺咖啡</span></span><br><span class="line"><span class="string">咖啡卡布奇诺的价格是： 4.00 元</span></span><br><span class="line"><span class="string">顾客刘小姐订购了一杯雀巢咖啡咖啡</span></span><br><span class="line"><span class="string">咖啡雀巢咖啡的价格是： 4.00 元</span></span><br><span class="line"><span class="string">顾客王老板订购了一杯美式咖啡咖啡</span></span><br><span class="line"><span class="string">咖啡美式咖啡的价格是： 4.00 元</span></span><br><span class="line"><span class="string">创建了3个实例</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>享元模式的优点</p>
<ul>
<li>可以减少内存中对象的数量，使得相同或者相似的对象在内存中只保存一份，从而可以节约系统资源，提高系统性能；</li>
<li>外部状态相对独立，而不会影响内部状态，从而使得享元对象可以在不同的环境中被共享。</li>
</ul>
</li>
<li><p>享元模式的缺点</p>
<ul>
<li>使得系统变得复杂，需要分析出内部状态和外部状态，这使得程序的逻辑复杂化；</li>
<li>为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态使得运行时间变长。</li>
</ul>
</li>
<li><p>享元模式的适用环境</p>
<ul>
<li>一个系统有大量相同或者相似的对象，造成内存的大量消费；对象的大部分状态可以外部化，可以将这些外部状态传入对象中；在使用享元模式是需要维护一个存储对象的享元池，而这需要耗费一定的系统资源，因此在需要多次重复使用享元对象时才值得使用享元模式。</li>
</ul>
</li>
</ul>
<h3 id="11-桥接模式"><a href="#11-桥接模式" class="headerlink" title="11. 桥接模式"></a>11. 桥接模式</h3><h3 id="12-组合模式"><a href="#12-组合模式" class="headerlink" title="12. 组合模式"></a>12. 组合模式</h3><h3 id="13-命令模式"><a href="#13-命令模式" class="headerlink" title="13. 命令模式"></a>13. 命令模式</h3><h3 id="14-访问者模式"><a href="#14-访问者模式" class="headerlink" title="14. 访问者模式"></a>14. 访问者模式</h3><h3 id="15-责任链模式"><a href="#15-责任链模式" class="headerlink" title="15. 责任链模式"></a>15. 责任链模式</h3><h3 id="16-备忘录模式"><a href="#16-备忘录模式" class="headerlink" title="16. 备忘录模式"></a>16. 备忘录模式</h3><h3 id="17-中介者模式"><a href="#17-中介者模式" class="headerlink" title="17. 中介者模式"></a>17. 中介者模式</h3><h3 id="18-状态模式"><a href="#18-状态模式" class="headerlink" title="18. 状态模式"></a>18. 状态模式</h3><h3 id="19-模板方法模式"><a href="#19-模板方法模式" class="headerlink" title="19. 模板方法模式"></a>19. 模板方法模式</h3><ul>
<li>模版方法模式的引入</li>
</ul>
<blockquote>
<p>模板方法模式时行为模式中比较简单的设计模式之一。模版方法关注这样的一类行为：该行为在执行过程中拥有大致相同的动作次序，只是动作在实现的具体细节有所差异。如泡茶和泡咖啡，过程操作步骤都是相似的，可以把这一类行为抽象成一个算法，并将其中的动作序列按先后顺序也抽象出来作为该算法的步骤，至于这些步骤中你那个的实现细节，则由算法发的子类去实现。</p>
</blockquote>
<blockquote>
<p>模版方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类不改变一个算法结构即可重定义该算法的某些特定步骤。</p>
</blockquote>
<blockquote>
<p>模版方法模式是一种基于继承的代码复用技术，将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称之为模版方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。</p>
</blockquote>
<ul>
<li><p>模板方法模式的结构</p>
<ul>
<li>抽象类(AbstractClass)：会声明作为算法步骤的方法，以及一次调用它们的实际模版方法。</li>
<li>具体子类(ConcreteClass)：可以重写所有步骤，但是不能重写模版方法自身。</li>
</ul>
</li>
<li><p>模板方法模式的实现</p>
<ul>
<li>(1). 分析目标算法，确定是否能够将其分解为多个步骤。从所有子类角度出发，考虑哪些步骤能够通用，哪些步骤各不相同。</li>
<li>(2). 创建抽象基类并声明一个模板方法和代表算法步骤的一些列抽象方法。在模版方法中根据算法结构一次调用相应步骤，可以用final最终修饰模版方法以防止之类对其进行重写。</li>
<li>(3). 虽然可将所有步骤全都设为抽象类型，但默认实现可能会给部分步骤带来好处，因为之类无需实现那些方法。</li>
<li>(4). 可以考虑在算法的关键步骤之间添加“钩子”。</li>
<li>(5). 为每个算法变体新建一个具体子类，它必须实现所有的抽象步骤，也可以重写部分可选步骤。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码来源：https://www.cnblogs.com/onepiece-andy/p/python-template-method-pattern.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">模板方法模式(Template Method Pattern):定义一个操作中的算法骨架，将一些步骤延迟至子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">使用场景:当不变和可变的行为在方法的子类实现中混合在一起时,不变的行为就会在子类中重复出现，用模板方法模式把这些不变的行为搬到单一的地方，帮助子类摆脱重复不变的行为纠缠。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewPaper</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">question1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"题目1"</span>)</span><br><span class="line">        print(self.answer1())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">question2</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"题目2"</span>)</span><br><span class="line">        print(self.answer2())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">answer1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">answer2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPaperA</span><span class="params">(NewPaper)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">answer1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"答案A1"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">answer2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"答案A2"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPaperB</span><span class="params">(NewPaper)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">answer1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"答案B1"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">answer2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"答案B2"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    test1 = TestPaperA()</span><br><span class="line">    test2 = TestPaperB()</span><br><span class="line">    print(<span class="string">"试卷A"</span>)</span><br><span class="line">    test1.question1()</span><br><span class="line">    test1.question2()</span><br><span class="line">    print(<span class="string">"试卷B"</span>)</span><br><span class="line">    test2.question1()</span><br><span class="line">    test2.question2()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">试卷A</span></span><br><span class="line"><span class="string">题目1</span></span><br><span class="line"><span class="string">答案A1</span></span><br><span class="line"><span class="string">题目2</span></span><br><span class="line"><span class="string">答案A2</span></span><br><span class="line"><span class="string">试卷B</span></span><br><span class="line"><span class="string">题目1</span></span><br><span class="line"><span class="string">答案B1</span></span><br><span class="line"><span class="string">题目2</span></span><br><span class="line"><span class="string">答案B2</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>模版方法模式的优点</p>
<ul>
<li>在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时，并不会改变算法中步骤的执行顺序；</li>
<li>提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为；</li>
<li>可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行；</li>
<li>更换和增加新的子类很方便，符合单一职责和开闭原则。</li>
</ul>
</li>
<li><p>模版方法模式的缺点</p>
<ul>
<li>需要为每个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将导致类的个数增加，系统更加庞大，设计也会更加抽象；</li>
<li>模版方法中步骤越多，其维护工作就可能也困难。</li>
</ul>
</li>
<li><p>模版方法模式的适用环境</p>
<ul>
<li>当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式；</li>
<li>当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。</li>
</ul>
</li>
</ul>
<h3 id="20-解释器模式"><a href="#20-解释器模式" class="headerlink" title="20. 解释器模式"></a>20. 解释器模式</h3><h3 id="21-迭代器模式"><a href="#21-迭代器模式" class="headerlink" title="21. 迭代器模式"></a>21. 迭代器模式</h3><blockquote>
<p>迭代器模式提供一种顺序访问一个聚合对象（聚合对象的两个职责：存储数据和遍历数据）中各个元素，且不用暴露该对象的内部表示。</p>
</blockquote>
<ul>
<li>迭代器模式的实现</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码来源：https://www.cnblogs.com/onepiece-andy/p/python-iterator-pattern.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">迭代器模式(Iterator Pattern):提供方法顺序访问一个聚合对象中各元素，而又不暴露该对象的内部表示</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代器抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">First</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Isdone</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CurrItem</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 聚集抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aggregate</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CreateIterator</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体迭代器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span><span class="params">(Iterator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, aggregate)</span>:</span></span><br><span class="line">        self.aggregate = aggregate</span><br><span class="line">        self.curr = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">First</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.aggregate[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Next</span><span class="params">(self)</span>:</span></span><br><span class="line">        ret = <span class="literal">None</span></span><br><span class="line">        self.curr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.curr &lt; len(self.aggregate):</span><br><span class="line">            ret = self.aggregate[self.curr]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Isdone</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> self.curr+<span class="number">1</span> &gt;= len(self.aggregate) <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CurItem</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.aggregate[self.curr]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体聚集类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span><span class="params">(Aggregate)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ilist = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CreateIterator</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ConcreteIterator(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIteratorDesc</span><span class="params">(Iterator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, aggregate)</span>:</span></span><br><span class="line">        self.aggregate = aggregate</span><br><span class="line">        self.curr = len(aggregate)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">First</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.aggretegate[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Next</span><span class="params">(self)</span>:</span></span><br><span class="line">        ret = <span class="literal">None</span></span><br><span class="line">        self.curr -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.curr &gt;= <span class="number">0</span>:</span><br><span class="line">            ret = self.aggregate[self.curr]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Isdone</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> self.curr<span class="number">-1</span>&lt; <span class="number">0</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CurrItem</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.aggregate[self.curr]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ca = ConcreteAggregate()</span><br><span class="line">    ca.ilist.append(<span class="string">"aa"</span>)</span><br><span class="line">    ca.ilist.append(<span class="string">"bb"</span>)</span><br><span class="line">    ca.ilist.append(<span class="string">"cc"</span>)</span><br><span class="line">    ca.ilist.append(<span class="string">"dd"</span>)</span><br><span class="line"></span><br><span class="line">    itor = ConcreteIterator(ca.ilist)</span><br><span class="line">    print(itor.First())</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> itor.Isdone():</span><br><span class="line">        print(itor.Next())</span><br><span class="line">    print(<span class="string">"---倒序---"</span>)</span><br><span class="line"></span><br><span class="line">    itordesc = ConcreteIteratorDesc(ca.ilist)</span><br><span class="line">    print(itordesc.First())</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> itordesc.Isdone():</span><br><span class="line">        print(itordesc.Next())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">aa</span></span><br><span class="line"><span class="string">bb</span></span><br><span class="line"><span class="string">cc</span></span><br><span class="line"><span class="string">dd</span></span><br><span class="line"><span class="string">---倒序---</span></span><br><span class="line"><span class="string">dd</span></span><br><span class="line"><span class="string">cc</span></span><br><span class="line"><span class="string">bb</span></span><br><span class="line"><span class="string">aa</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>迭代器模式的优点</p>
<ul>
<li>(1). 支持一下不同方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式；</li>
<li>(2). 简化了聚合类，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，符合开闭原则。</li>
</ul>
</li>
<li><p>迭代器模式的缺点</p>
<ul>
<li>(1). 在增加新的聚合类时需要对应地增加新的迭代器类，类的个数成对增加，这一定程度上增加了系统的复杂性；</li>
<li>(2). 抽象迭代器的设计难度较大，需要充分考虑到系统的扩展；</li>
<li>(3). 在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是一件很容易的事情。</li>
</ul>
</li>
<li><p>迭代器模式的适用环境</p>
</li>
</ul>
<blockquote>
<p>访问一个聚合对象的内容而无需暴露它的内部表示；需要为一个聚合对象提供多种遍历方式；为遍历不同的聚合结构提供一个统一的接口，在该就扣的实现类中为不同的聚合结构提供不同的遍方式，而客户端可以一致性地操作该接口。</p>
</blockquote>
<h3 id="22-观察者模式"><a href="#22-观察者模式" class="headerlink" title="22. 观察者模式"></a>22. 观察者模式</h3><h3 id="23-策略模式"><a href="#23-策略模式" class="headerlink" title="23. 策略模式"></a>23. 策略模式</h3><h2 id="23-GIL全局解释器锁"><a href="#23-GIL全局解释器锁" class="headerlink" title="23. GIL全局解释器锁"></a>23. GIL全局解释器锁</h2><p><strong><a href="https://www.oschina.net/translate/pythons-hardest-problem" target="_blank" rel="noopener">Python的底层</a></strong></p>
<blockquote>
<p>要理解GIL的含义，我们需要从Python的基础讲起。像C++这样的语言是编译型语言，所谓编译型语言，是指程序输入到编译器，编译器再根据语言的语法进行解析，然后翻译成语言独立的中间表示，最终链接成具有高度优化的机器码的可执行程序。编译器之所以可以深层次的对代码进行优化，是因为它可以看到整个程序（或者一大块独立的部分）。这使得它可以对不同的语言指令之间的交互进行推理，从而给出更有效的优化手段。</p>
</blockquote>
<blockquote>
<p>与此相反，Python是解释型语言。程序被输入到解释器来运行。解释器在程序执行之前对其并不了解；它所知道的只是Python的规则，以及在执行过程中怎样去动态的应用这些规则。它也有一些优化，但是这基本上只是另一个级别的优化。由于解释器没法很好的对程序进行推导，Python的大部分优化其实是解释器自身的优化。更快的解释器自然意味着程序的运行也能“免费”的更快。也就是说，解释器优化后，Python程序不用做修改就可以享受优化后的好处。</p>
</blockquote>
<blockquote>
<p>要想利用多核系统，Python必须支持多线程运行。作为解释型语言，Python的解释器必须做到既安全又高效，但多线程编程会遇到问题，解释器要留意的是避免在不同的线程操作内部共享的数据，同时它还要保证在管理用户线程时保证总是有最大化的计算资源。这时，为了不同线程同时访问时保护数据，当一个线程运行python程序的时候会霸占整个python解释器，也就是给解释器加了一把全局锁，这使得对于任何python程序，不管有多少处理器，多少线程，任何时候都自由一个线程在执行，其他线程在等待正在运行的线程完成才能运行。</p>
</blockquote>
<blockquote>
<p>如果线程运行过程中遇到耗时操作，超时时间超过一个固定值，则单线线程将会解开全局解释器锁，使其他线程运行。所以在多线程中是有先后顺序的，并不是同时运行的。多进程因每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现多个进程同时运行，缺点就是系统资源开销大。</p>
</blockquote>
<h2 id="24-函数是一等公民？"><a href="#24-函数是一等公民？" class="headerlink" title="24. 函数是一等公民？"></a>24. 函数是一等公民？</h2><blockquote>
<p>在python中一切皆对象，num、list、dict、tuple、function、class和模块等都是对象，如公民一样地位平等，可以在运行时创建，并能被赋值给变量，作为集合对象的元素，还能够作为函数的参数和返回值。</p>
</blockquote>
<blockquote>
<p>Python 中函数是一等公民，意思是 Python 中的函数和整数、字符串等常见概念的地位是平等的，一个整数和一个字符串等对象可以干的事，一个函数也可以办到。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    returns n!</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Domo</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">items = [<span class="number">1</span>, <span class="number">1.0</span>, <span class="string">'hello'</span>, [<span class="number">1</span>], &#123;<span class="string">'a'</span>: <span class="number">1</span>&#125;, &#123;<span class="number">1</span>&#125;, factorial, Domo(), re, <span class="literal">None</span>, object]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    print(<span class="string">f'对象 <span class="subst">&#123;item&#125;</span> 的类型是 <span class="subst">&#123;type(item).__name__&#125;</span>,'</span>, <span class="string">f'对象 <span class="subst">&#123;type(item).__name__&#125;</span>类 的类型是 <span class="subst">&#123;type(type(item)).__name__&#125;</span>.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">对象 1 的类型是 int, 对象 int类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 1.0 的类型是 float, 对象 float类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 hello 的类型是 str, 对象 str类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 [1] 的类型是 list, 对象 list类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 &#123;'a': 1&#125; 的类型是 dict, 对象 dict类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 &#123;1&#125; 的类型是 set, 对象 set类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 &lt;function factorial at ...&gt; 的类型是 function, 对象 function类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 &lt;__main__.Dumb object at ...&gt; 的类型是 Dumb, 对象 Dumb类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 &lt;module 're' from 'C:\\...\\re.py'&gt; 的类型是 module, 对象 module类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 None 的类型是 NoneType, 对象 NoneType类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 &lt;class 'object'&gt; 的类型是 type, 对象 type类 的类型是 type</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    print(<span class="string">f'类对象 <span class="subst">&#123;item.__class__.__name__&#125;</span> 的基类是: <span class="subst">&#123;item.__class__.__bases__&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'类对象 <span class="subst">&#123;object.__name__&#125;</span> 的基类是: <span class="subst">&#123;object.__bases__&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">类对象 int 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 float 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 str 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 list 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 dict 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 set 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 function 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 Dumb 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 module 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 NoneType 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 type 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 object 的基类是: ()</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="25-函数与方法的区别"><a href="#25-函数与方法的区别" class="headerlink" title="25. 函数与方法的区别"></a>25. 函数与方法的区别</h2><blockquote>
<p>函数的本质是FunctionObject，其中包括内置函数、匿名函数、递归函数、自定义函数。<br>函数的作用域是从函数调用开始至函数执行完成，返回给调用者后，在执行过程中开辟的空间会自动释放，即函数执行完成后，函数体内部通过赋值等方式修改变量的值不会保留，会随着返回给调用者后，开辟的空间自动释放。<br>函数通过”函数名()”形式调用。</p>
</blockquote>
<blockquote>
<p>方法的本质是PyMethodObject，其中包括普通方法（直接用self调用的方法）、私有方法（<strong>函数名,只能在类中被调用的方法）、属性方法（@property，将方法伪装成属性）、特殊方法（`</strong>init__, <strong>call</strong>,<strong>getattr</strong>`等）、类方法、静态方法。<br>方法的作用域是通过实例化的对象进行方法的调用，调用后开辟的空间不会释放，即调用方法中对变量的修改值会一直保留。<br>方法是通过”对象.方法名”的方式进行调用。</p>
</blockquote>
<h2 id="26-range与Xrange的区别"><a href="#26-range与Xrange的区别" class="headerlink" title="26. range与Xrange的区别"></a>26. range与Xrange的区别</h2><blockquote>
<p>range()是Python的内置函数，用于创建整数的列表，可以生成递减或者递增的数列。<br>用法：<code>range(start, stop, step)</code>，生成一个序列。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python3下的range，其实已经把xrange合并过来了</span></span><br><span class="line">x = range(<span class="number">0</span>，<span class="number">5</span>)</span><br><span class="line">print(type(x))</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python3结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;class 'range'&gt;</span></span><br><span class="line"><span class="string">range(0, 5)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python2结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;type 'list'&gt;</span></span><br><span class="line"><span class="string">[0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>xrange()在python3中已经移除，xrange用法与range完全相同，但是得到的是一个生成器对象，惰性求值，xrange()函数比range()函数更快。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xrange</span></span><br><span class="line">x = xrange(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">print(type(xrange(<span class="number">0</span>, <span class="number">5</span>)))</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;class 'range'&gt;</span></span><br><span class="line"><span class="string">range(0, 5)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="27-search与match的区别"><a href="#27-search与match的区别" class="headerlink" title="27. search与match的区别"></a>27. search与match的区别</h2><blockquote>
<p>search()函数会在整个字符串内查找模式匹配，直到找到第一个匹配，然后返回一个包含匹配信息的对象，该对象可以通过group()方法得到匹配的字符串，如果没有字符串没有匹配到，则返回None。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">print(re.search(<span class="string">"time"</span>, <span class="string">"datetime"</span>))</span><br><span class="line">print(re.search(<span class="string">"time"</span>, <span class="string">"datetime"</span>).span())</span><br><span class="line">print(re.search(<span class="string">"time1"</span>, <span class="string">"datetime"</span>))</span><br><span class="line">print(re.search(<span class="string">"hello"</span>, <span class="string">"hihelloworld"</span>).span())</span><br><span class="line">print(re.search(<span class="string">"hello"</span>, <span class="string">"hihelloworld"</span>).group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;re.Match object; span=(4, 8), match='time'&gt;</span></span><br><span class="line"><span class="string">(4, 8)</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">(2, 7)</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>match()函数只检测字符串开头位置是否匹配，匹配成功才会返回结果，否则返回None。</p>
</blockquote>
<ul>
<li>group() 返回被 RE 匹配的字符串</li>
<li>start() 返回匹配开始的位置</li>
<li>end() 返回匹配结束的位置</li>
<li>span()返回一个元组包含匹配 (开始,结束) 的位置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">print(re.match(<span class="string">"time"</span>, <span class="string">"datetime"</span>))</span><br><span class="line">print(re.match(<span class="string">"time"</span>, <span class="string">"timedate"</span>))</span><br><span class="line">print(re.match(<span class="string">"time"</span>, <span class="string">"timedate"</span>).span())</span><br><span class="line">print(re.match(<span class="string">"time"</span>, <span class="string">"timedate"</span>).group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">&lt;re.Match object; span=(0, 4), match='time'&gt;</span></span><br><span class="line"><span class="string">(0, 4)</span></span><br><span class="line"><span class="string">time</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h2 id="28-面向对象编程OOP"><a href="#28-面向对象编程OOP" class="headerlink" title="28. 面向对象编程OOP"></a>28. 面向对象编程OOP</h2><blockquote>
<p>面向对象编程OOP（Object Oriented Programming）是一种程序设计思想，把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。面向对象的程序设计过程吧计算机程序视为一组对象的集合，而每个对象都可以接受其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在对象之间传递。</p>
</blockquote>
<blockquote>
<p>在Python中，一切皆对象，当然也可以自定义对象。自定义对象的数据类型就是面向对象中的类的概念，面向对象的设计思想是抽象出类(Class)，根据类(Class)创建实例(instance)。面向对象的抽象程度又比函数要高，因为一个类(Class)既包含数据又包含操作数据的方法。</p>
</blockquote>
<blockquote>
<p>面向对象的三大特性：封装、继承、多态。</p>
</blockquote>
<h2 id="29-面向切面编程AOP"><a href="#29-面向切面编程AOP" class="headerlink" title="29. 面向切面编程AOP"></a>29. 面向切面编程AOP</h2><blockquote>
<p>AOP(Aspect Oriented Programming)是一种编程方式，就是在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</p>
</blockquote>
<blockquote>
<p>AOP主要作用就是将类似于日志记录，性能统计，安全控制，事务处理，异常处理等重复性的代码块从业务逻辑代码中划分出来，对这些行为的分离。并且将它们独立到非知道业务逻辑的方法中，从而做到改变这些行为的时候不影响业务逻辑代码。</p>
</blockquote>
<blockquote>
<p>AOP带来的优点：</p>
</blockquote>
<ul>
<li>降低系统的反复代码</li>
<li>降低模块间的耦合度</li>
<li>提高系统可扩展性</li>
<li>增加代码可维护性</li>
</ul>
<blockquote>
<p>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，装饰器的作用就是为已经存在的对象添加额外的功能，所以python中使用装饰器实现AOP。</p>
</blockquote>
<h2 id="30-封装"><a href="#30-封装" class="headerlink" title="30. 封装"></a>30. 封装</h2><p><strong><a href="https://blog.csdn.net/max_like/article/details/81346484" target="_blank" rel="noopener">python 类的封装</a></strong></p>
<blockquote>
<p>面向对象编程的一个重要特点就是数据封装。类的封装包含数据封装、方法封装、属性封装。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据封装，将程序中需要的数据按照统一的格式封装在类型的内部，通过该类型的对象包装使用数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法封装，函数和方法混合开发，  处理和某个数据关联的功能-&gt; 功能代码封装成函数，将函数封装在类型中处理具体功能的方法，就和对应的数据强制关联，方便统一管理维护</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">student = Student(<span class="string">"张三"</span>, <span class="string">"18"</span>, get_name())</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>属性封装</strong>(重点重点重点)</li>
</ul>
<blockquote>
<p>属性是属于对象的特征，对象的特征是属于对象的数据，对象的数据一般不让外界直接访问。但是默认<code>self.name</code>不做任何添加的是公共的public，允许内部和外部的访问。</p>
</blockquote>
<blockquote>
<p>受保护的protected：在对象成员前面加一个下划线<code>self._name</code>，允许类中或子类中都可以进行访问，但外部不可以访问。</p>
</blockquote>
<blockquote>
<p>私有的private：在成员前面添加两个下划线<code>self.__name</code>，私有成员是高级别的封装，只有当前类对象自己能访问，连子类对象也不能访问到这个数据。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 属性封装的装饰器(https://blog.csdn.net/MrNoboday/article/details/89371430)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = <span class="number">0</span></span><br><span class="line">        self.__gender = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property  # 只读</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.__age == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"you haven't set age!"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gender</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.__gender <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">"you haven't set gender!"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.__gender</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter  # 只写</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt; age &lt; <span class="number">120</span>:</span><br><span class="line">            self.__age = age</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"age set failure!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @gender.setter  # 只写</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gender</span><span class="params">(self, gender)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> gender.lower() <span class="keyword">in</span> [<span class="string">'man'</span>, <span class="string">'wowan'</span>]:</span><br><span class="line">            self.__gender = gender.lower()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'gender set failure!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    user = User(<span class="string">'zhangsan'</span>)</span><br><span class="line">    print(<span class="string">'name:'</span>, user.name, <span class="string">'gender:'</span>, user.gender, <span class="string">'age:'</span>,user.age)</span><br><span class="line">    user.age = <span class="number">18</span></span><br><span class="line">    user.gender = <span class="string">'man'</span></span><br><span class="line">    print(<span class="string">'name:'</span>, user.name, <span class="string">'gender:'</span>, user.gender, <span class="string">'age:'</span>,user.age)</span><br><span class="line">    user.age = <span class="number">1000</span></span><br><span class="line">    user.gender = <span class="string">'double'</span></span><br><span class="line">    print(<span class="string">'name:'</span>, user.name, <span class="string">'gender:'</span>, user.gender, <span class="string">'age:'</span>,user.age)</span><br><span class="line">    user.age = <span class="number">99</span>  <span class="comment"># 这里用了@property装饰器把方法变成属性调用的，所以直接赋值</span></span><br><span class="line">    print(<span class="string">"间接修改的年龄: %s"</span> % user.age)</span><br><span class="line">    print(user._User__age = <span class="number">88</span>)</span><br><span class="line">    print(<span class="string">"直接修改的年龄: %s"</span> % user.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">you haven't set gender!</span></span><br><span class="line"><span class="string">you haven't set age!</span></span><br><span class="line"><span class="string">name: zhangsan gender: None age: None</span></span><br><span class="line"><span class="string">name: zhangsan gender: man age: 18</span></span><br><span class="line"><span class="string">age set failure!</span></span><br><span class="line"><span class="string">gender set failure!</span></span><br><span class="line"><span class="string">name: zhangsan gender: man age: 18</span></span><br><span class="line"><span class="string">间接修改的年龄: 99</span></span><br><span class="line"><span class="string">直接修改的年龄: 88</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以通过属性封装的装饰器去更改私有变量的值。当然还有两种常用的方法：</p>
</blockquote>
<ul>
<li>间接：为这个私有变量提供一个操作方法，如<code>def age(self, age)</code></li>
<li>直接：实例名._类名<strong>私有变量名 = 值，如`user_User</strong>age = 100`</li>
</ul>
<h2 id="31-继承"><a href="#31-继承" class="headerlink" title="31. 继承"></a>31. 继承</h2><blockquote>
<p>继承是一种创建新类的方式，新创建的类加子类，继承的叫父类、超类、基类。继承是类与类之间的关系，继承的作用是减少代码冗余、提高重用性。</p>
</blockquote>
<blockquote>
<p>继承的特征：所有的类都继承自object类，即所有的类都是object类的子类；<br>            子类一旦继承父类，则可以使用父类中除了私有成员外的所有内容；<br>            子类继承父类后，并没有捡父类成员完全复制到子类中，而是通过引用关系访问调用；<br>            子类可以定义独有的成员属性和方法；<br>            子类中定义的成员和父类成员如果同名，则优先使用子类成员；<br>            子类如果想扩充父类的方法，可以再定义新方法的同时访问父类的成员进行代码重用；</p>
</blockquote>
<ul>
<li>单继承</li>
</ul>
<blockquote>
<p>每个类只能继承一个类，优点是传承有序、逻辑清晰、语法简单、隐患少；缺点是功能不能无限扩展，只能在当前唯一的继承链中扩展。</p>
</blockquote>
<ul>
<li>多继承</li>
</ul>
<blockquote>
<p>每个类允许继承多个类，优点是类功能扩展方便；缺点是继承关系混乱。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swim</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am swimming..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am flying..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am working..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alien</span><span class="params">(Fish, Bird, Person)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">print(<span class="string">"="</span> * <span class="number">10</span> + <span class="string">" 单继承 "</span> + <span class="string">"="</span> * <span class="number">10</span>)</span><br><span class="line">student = Student(<span class="string">"zhangsan"</span>)</span><br><span class="line">student.work()</span><br><span class="line">print(<span class="string">"="</span> * <span class="number">10</span> + <span class="string">" 多继承 "</span> + <span class="string">"="</span> * <span class="number">10</span>)</span><br><span class="line">alien = Alien(<span class="string">"&amp;%$#^@"</span>)</span><br><span class="line">alien.swim()</span><br><span class="line">alien.fly()</span><br><span class="line">alien.work()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">========== 单继承 ==========</span></span><br><span class="line"><span class="string">I am working...</span></span><br><span class="line"><span class="string">========== 多继承 ==========</span></span><br><span class="line"><span class="string">I am swimming...</span></span><br><span class="line"><span class="string">I am flying...</span></span><br><span class="line"><span class="string">I am working...</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>继承变量函数的查找顺序：<br>    优先查找自己的变量，没有则继续往上（父类）查找；构造函数如果本类中没定义，则自动查找调用父类构造函数，如果本类中有定义，则不用继续向上查找。</p>
</blockquote>
<blockquote>
<p>构造函数：是一类特使的函数，在类进行实例化之前调用，如果定义了构造函数，则实例化的时候使用此构造函数，而不查找父类构造函数；如果没有定义构造函数，则自动向上查找父类构造函数；如果子类没有定义构造函数，而父类的构造函数带参数，则实例化子类时，应该按父类构造函数参数进行传参。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span><span class="params">(Animal)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">"我是一只宠物 %s"</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Pet)</span>:</span></span><br><span class="line">    <span class="comment"># __init__就是构造函数，记住一定要有这个参数</span></span><br><span class="line">    <span class="comment"># 每次进行实例化的时候，第一个被自动调用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"我初始化为一只小狗"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化的时候，括号内的参数要与构造函数的参数匹配</span></span><br><span class="line">dog = Dog()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Pet)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Cat类中，没有找到构造函数，自动从继承的父类Pet中查找</span></span><br><span class="line">cat = Cat(<span class="string">"嘟嘟"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">我初始化为一只小狗</span></span><br><span class="line"><span class="string">我是一只宠物 嘟嘟</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>super<br>    不是一个关键数字，而是一个类。super的作用是获取MRO（Method Resolution Order）方法解析顺序列表中的第一个类，而这个类往往就是它的父类，和父类没有任何实质性关系，可以用super()调用父类的初始化构造函数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(type(super))</span><br><span class="line">help(super)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;class 'type'&gt;</span></span><br><span class="line"><span class="string">Help on class super in module builtins:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class super(object)</span></span><br><span class="line"><span class="string"> |  super() -&gt; same as super(__class__, &lt;first argument&gt;)</span></span><br><span class="line"><span class="string"> |  super(type) -&gt; unbound super object</span></span><br><span class="line"><span class="string"> |  super(type, obj) -&gt; bound super object; requires isinstance(obj, type)</span></span><br><span class="line"><span class="string"> |  super(type, type2) -&gt; bound super object; requires issubclass(type2, type)</span></span><br><span class="line"><span class="string"> |  Typical use to call a cooperative superclass method:</span></span><br><span class="line"><span class="string"> |  class C(B):</span></span><br><span class="line"><span class="string"> |      def meth(self, arg):</span></span><br><span class="line"><span class="string"> |          super().meth(arg)</span></span><br><span class="line"><span class="string"> |  This works for class methods too:</span></span><br><span class="line"><span class="string"> |  class C(B):</span></span><br><span class="line"><span class="string"> |      @classmethod</span></span><br><span class="line"><span class="string"> |      def cmeth(cls, arg):</span></span><br><span class="line"><span class="string"> |          super().cmeth(arg)</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  Methods defined here:</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  __get__(self, instance, owner, /)</span></span><br><span class="line"><span class="string"> |      Return an attribute of instance, which is of type owner.</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  __getattribute__(self, name, /)</span></span><br><span class="line"><span class="string"> |      Return getattr(self, name).</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  __init__(self, /, *args, **kwargs)</span></span><br><span class="line"><span class="string"> |      Initialize self.  See help(type(self)) for accurate signature.</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  __repr__(self, /)</span></span><br><span class="line"><span class="string"> |      Return repr(self).</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  ----------------------------------------------------------------------</span></span><br><span class="line"><span class="string"> |  Static methods defined here:</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  __new__(*args, **kwargs) from builtins.type</span></span><br><span class="line"><span class="string"> |      Create and return a new object.  See help(type) for accurate signature.</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  ----------------------------------------------------------------------</span></span><br><span class="line"><span class="string"> |  Data descriptors defined here:</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  __self__</span></span><br><span class="line"><span class="string"> |      the instance invoking super(); may be None</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  __self_class__</span></span><br><span class="line"><span class="string"> |      the type of the instance invoking super(); may be None</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  __thisclass__</span></span><br><span class="line"><span class="string"> |      the class invoking super()</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>菱形继承/钻石继承问题：<br>    （1）多个子类继承自同一个父类，这些子类又被同一个类继承，于是继承关系图形成了一个菱形图谱。<br>    （2）多继承的MRO用于保存继承顺序的一个列表，MRO列表的计算原则：子类永远在父类前面；如果多个父类，则根据继承语法中括号内的书写顺序存放；如果多个类继承了同一个父类，孙子类中只会选取继承语法括号中的第一个父类的父类。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(D.__mro__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>派生类：派生就是子类在继承父类的基础上衍生出新的属性，子类中独有的，父类中没有的；或子类定义与父类重名的东西，子类有不同于父类的属性，这个子类叫做派生类。通常情况下，子类和派生类是同一个概念，因为子类都是有不同于父类的属性，如果子类和父类属性相同，就没必要创建子类了。</p>
</blockquote>
<h2 id="32-多态与多态性"><a href="#32-多态与多态性" class="headerlink" title="32. 多态与多态性"></a>32. 多态与多态性</h2><blockquote>
<p>多态：指的是以类事物有多种形态，如一个抽象类有多个子类，多态的概念依赖于继承；如在java中，一个函数由于函数签名不同，可以有同名的不同函数存在，调用的时候根据函数签名不同自动找到相应的函数执行。简单来说，就是同一事物的多种形态。Python中的多态不是语法，而是一种设计思想，多态的设计就是要完成对不同类型对象使用相同方法调用能得到各自期望的结果。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多态：同一种事物的多种形态，动物分为人、猪、狗等等</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">'子类必须实现这个方法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'人正在走'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'猪正在散步'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'狗正在走'</span>)</span><br><span class="line"></span><br><span class="line">people = People()</span><br><span class="line">pig = Pig()</span><br><span class="line">dog = Dog()</span><br><span class="line"></span><br><span class="line">people.run()</span><br><span class="line">pig.run()</span><br><span class="line">dog.run()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">人正在走</span></span><br><span class="line"><span class="string">猪正在散步</span></span><br><span class="line"><span class="string">狗正在走</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同一类事物：文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span> </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件的形态之一：文本文件 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span><span class="params">(File)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'open file'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#文件的形态之二：可执行文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExeFile</span><span class="params">(File)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'execute file'</span>)</span><br><span class="line"></span><br><span class="line">text = Text()</span><br><span class="line">exefile = ExeFile()</span><br><span class="line"></span><br><span class="line">text.click()</span><br><span class="line">exefile.click()</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">open file</span></span><br><span class="line"><span class="string">execute file</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>多态性：指具有不同功能的函数可以使用相同的函数名，这样可以用一个函数名调用不同内容的函数（如向不同的对象发送同一条消息，不同的对象接受时会执行不同的行为）。简单来说，就是一种调用方式，产生不同的执行效果。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多态性：一种调用方式，不同的执行效果（多态性）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">'子类必须实现这个方法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'人正在走'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'猪正在散步'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'狗正在走'</span>)</span><br><span class="line"></span><br><span class="line">people = People()</span><br><span class="line">pig = Pig()</span><br><span class="line">dog = Dog()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多态性：定义统一的接口</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(obj)</span>:</span>  <span class="comment"># obj这个参数没有类型限制，可以传入不同类型的值</span></span><br><span class="line">    obj.run()  <span class="comment"># 调用的逻辑都一样，执行的结果却不一样</span></span><br><span class="line"></span><br><span class="line">func(people)</span><br><span class="line">func(pig)</span><br><span class="line">func(dog)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">人正在走</span></span><br><span class="line"><span class="string">猪正在散步</span></span><br><span class="line"><span class="string">狗正在走</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多态性</span></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同一类事物：文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span> </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件的形态之一：文本文件 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span><span class="params">(File)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'open file'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#文件的形态之二：可执行文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExeFile</span><span class="params">(File)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'execute file'</span>)</span><br><span class="line"></span><br><span class="line">text = Text()</span><br><span class="line">exefile = ExeFile()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(f)</span>:</span></span><br><span class="line">    f.click()</span><br><span class="line"></span><br><span class="line">func(text)</span><br><span class="line">func(exefile)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">open file</span></span><br><span class="line"><span class="string">execute file</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>多态性的好处：<br>    - 增加了程序的灵活性<br>    - 增加程序的可扩展性</p>
</blockquote>
<h2 id="33-重载"><a href="#33-重载" class="headerlink" title="33. 重载"></a>33. 重载</h2><p><strong><a href="https://blog.csdn.net/qq_37049781/article/details/83959365" target="_blank" rel="noopener">python 中的重载</a></strong></p>
<blockquote>
<p>在Python中，具有重载的思想却没有重载的概念。实际上，Python编程中具有重载的目的却无重载的行为，或者说python并不需要重载。python是一门动态语言，不需要声明变量类型，函数中可以接受任何类型的参数也就无法根据参数类型来支持重载，python没有必要去考虑参数的类型问题，这些都可以在函数内部判断处理，并无必要去在写一个函数。python 有多种传参方式，默认参数、可变参数、可变关键字参数，可以处理函数参数中参数可变的问题。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python3.4 中提供的一个转发机制来实现重载</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch  # 只支持根据第一个参数的类型来重载，不支持多参数重载</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">(obj)</span>:</span>  <span class="comment"># 被重载的函数</span></span><br><span class="line">    print(<span class="string">'%r'</span> % (obj))</span><br><span class="line"></span><br><span class="line"><span class="meta">@function.register(int)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_int</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">'Integer: %d'</span> % (obj))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@function.register(str)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_str</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">'String: %s'</span> % (obj))</span><br><span class="line"></span><br><span class="line"><span class="meta">@function.register(list)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_list</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">'List: %r'</span> % (obj))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    function(<span class="number">1</span>)</span><br><span class="line">    function(<span class="string">'hello'</span>)</span><br><span class="line">    function(range(<span class="number">3</span>))</span><br><span class="line">    function(object)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Integer: 1</span></span><br><span class="line"><span class="string">String: hello</span></span><br><span class="line"><span class="string">range(0, 3)</span></span><br><span class="line"><span class="string">&lt;class 'object'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>重载是对继承的父类方法进行重新定义，重载可以重新定义方法还可以重新定义运算符。因为通过继承的类不一定能满足当前类的需求，在当前类中只需要修改部分内容而达到自己的需求。</p>
</blockquote>
<blockquote>
<p>重载的特点：<br>    - 减少代码量和灵活指定型类<br>    - 子类具有父类的方法和属性<br>    - 子类不能继承父类的私有方法或属性<br>    - 子类可以添加新的方法<br>    - 子类可以修改父类的方法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法重载</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span><span class="params">(object)</span>:</span></span><br><span class="line">    __name = <span class="string">''</span>  <span class="comment"># 定义属性</span></span><br><span class="line">    __sex = <span class="number">0</span></span><br><span class="line">    __age = <span class="number">0</span></span><br><span class="line">    __height = <span class="number">0</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sex, age, height, weight)</span>:</span></span><br><span class="line">        self.__sex = sex</span><br><span class="line">        self.__age = age</span><br><span class="line">        self.__height = height</span><br><span class="line">        self.__weight = weight</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.__name, self.__sex, self.__age, self.__height, self.__weight)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Human)</span>:</span></span><br><span class="line">    __classes = <span class="number">0</span></span><br><span class="line">    __grade = <span class="number">0</span></span><br><span class="line">    __num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, classes, grade, num, sex, age, height, weight)</span>:</span>  <span class="comment"># 重载 __init__方法</span></span><br><span class="line">        self.__classes = classes</span><br><span class="line">        self.__grade = grade</span><br><span class="line">        self.__num = num</span><br><span class="line">        Human.__init__(self, sex, age, height, weight)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span>  <span class="comment"># 重载 show 方法</span></span><br><span class="line">        Human.show(self)</span><br><span class="line">        print(self.__classes, self.__grade, self.__num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Student(<span class="number">3</span>, <span class="number">2</span>, <span class="number">19990520</span>, <span class="string">'男'</span>, <span class="number">20</span>, <span class="string">'172'</span>, <span class="number">55</span>)</span><br><span class="line">    s.set_name(<span class="string">'小明'</span>)</span><br><span class="line">    s.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">小明 男 20 172 55</span></span><br><span class="line"><span class="string">3 2 19990520</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运算符重载是在类方法中拦截内置的操作——当类的实例出现在内置操作中，Python自动调用重新定义的方法，并将重新定义方法的返回值变成了相应操作的结果。</p>
</blockquote>
<blockquote>
<p>python对运算符重载的一些限制：</p>
</blockquote>
<ul>
<li>不能重载内置类型的运算符</li>
<li>不能新建运算符，只能重载现有的</li>
<li>某些运算符不是重载：is、and、or、not</li>
</ul>
<p><strong><a href="https://www.cnblogs.com/laolibk/p/8011472.html" target="_blank" rel="noopener">Python中运算符重载</a></strong><br><strong><a href="https://www.cnblogs.com/lht-record/p/10306591.html" target="_blank" rel="noopener">《流畅的python》</a></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运算符重载</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span><span class="params">(object)</span>:</span></span><br><span class="line">    __list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span>  <span class="comment"># 重载 __init__ 方法</span></span><br><span class="line">        self.__list = []</span><br><span class="line">        <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">            self.__list.append(arg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, n)</span>:</span>  <span class="comment"># 重载加法"+"运算符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(self.__list)):</span><br><span class="line">            self.__list[i] +=n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self, n)</span>:</span>  <span class="comment"># 重载减法"-"运算符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(self.__list)):</span><br><span class="line">            self.__list[i] -= n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, n)</span>:</span>  <span class="comment"># 重载乘法"*"运算符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(self.__list)):</span><br><span class="line">            self.__list[i] *= n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__turediv__</span><span class="params">(self, n)</span>:</span>  <span class="comment"># 重载除法"/"运算符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(self.__list)):</span><br><span class="line">            self.__list[i] /= n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__floordiv__</span><span class="params">(self, n)</span>:</span>  <span class="comment"># 重载整除"//"运算符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(self.__list)):</span><br><span class="line">            self.__list[i] //= n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mod__</span><span class="params">(self, n)</span>:</span>  <span class="comment"># 重载求余"%"运算符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(self.__list)):</span><br><span class="line">            self.__list[i] %= n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__pow__</span><span class="params">(self, n)</span>:</span>  <span class="comment"># 重载次幂"**"运算符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(self.__list)):</span><br><span class="line">            self.__list[i] **= n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.__list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data_list = List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">    data_list.show()</span><br><span class="line"></span><br><span class="line">    data_list + <span class="number">2</span></span><br><span class="line">    data_list.show()</span><br><span class="line"></span><br><span class="line">    data_list - <span class="number">2</span></span><br><span class="line">    data_list.show()</span><br><span class="line"></span><br><span class="line">    data_list * <span class="number">2</span></span><br><span class="line">    data_list.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># data_list / 2</span></span><br><span class="line">    <span class="comment"># data_list.show()</span></span><br><span class="line"></span><br><span class="line">    data_list // <span class="number">2</span></span><br><span class="line">    data_list.show()</span><br><span class="line"></span><br><span class="line">    data_list % <span class="number">2</span></span><br><span class="line">    data_list.show()</span><br><span class="line"></span><br><span class="line">    data_list ** <span class="number">2</span></span><br><span class="line">    data_list.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="string">[3, 4, 5, 6, 7, 8, 9, 10, 11]</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="string">[2, 4, 6, 8, 10, 12, 14, 16, 18]</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="string">[1, 0, 1, 0, 1, 0, 1, 0, 1]</span></span><br><span class="line"><span class="string">[1, 0, 1, 0, 1, 0, 1, 0, 1]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>一元运算符重载:</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="left">运算符</th>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">取正</td>
<td align="left">+</td>
<td align="left"><code>__pos__</code></td>
</tr>
<tr>
<td align="center">取负</td>
<td align="left">-</td>
<td align="left"><code>__neg__</code></td>
</tr>
<tr>
<td align="center">按位取反</td>
<td align="left">~</td>
<td align="left"><code>__invert__</code></td>
</tr>
<tr>
<td align="center">取绝对值</td>
<td align="left">`</td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p>常见的算术运算符重载：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="left">运算符</th>
<th align="left">正向方法</th>
<th align="center">反向方法</th>
<th align="center">就地方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">加法</td>
<td align="left">+</td>
<td align="left"><code>__add__</code></td>
<td align="center"><code>__radd__</code></td>
<td align="center"><code>__iadd__</code></td>
</tr>
<tr>
<td align="center">减法</td>
<td align="left">-</td>
<td align="left"><code>__sub__</code></td>
<td align="center"><code>__rsub__</code></td>
<td align="center"><code>__isub__</code></td>
</tr>
<tr>
<td align="center">乘法</td>
<td align="left">*</td>
<td align="left"><code>__mul__</code></td>
<td align="center"><code>__rmul__</code></td>
<td align="center"><code>__imul__</code></td>
</tr>
<tr>
<td align="center">除法</td>
<td align="left">/</td>
<td align="left"><code>__truediv__</code></td>
<td align="center"><code>__rtruediv__</code></td>
<td align="center"><code>__itruediv__</code></td>
</tr>
<tr>
<td align="center">整除</td>
<td align="left">//</td>
<td align="left"><code>__floordiv__</code></td>
<td align="center"><code>__rfloordiv__</code></td>
<td align="center"><code>__ifloordiv__</code></td>
</tr>
<tr>
<td align="center">求余</td>
<td align="left">%</td>
<td align="left"><code>__mod__</code></td>
<td align="center"><code>__rmod__</code></td>
<td align="center"><code>__imod__</code></td>
</tr>
<tr>
<td align="center">次幂</td>
<td align="left">**</td>
<td align="left"><code>__pow__</code></td>
<td align="center"><code>__rpow__</code></td>
<td align="center"><code>__ipow__</code></td>
</tr>
</tbody></table>
<blockquote>
<p>位操作运算符重载：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="left">运算符</th>
<th align="left">正向方法</th>
<th align="center">反向方法</th>
<th align="center">就地方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">位与</td>
<td align="left">&amp;</td>
<td align="left"><code>__and__</code></td>
<td align="center"><code>__rand__</code></td>
<td align="center"><code>__iand__</code></td>
</tr>
<tr>
<td align="center">位或</td>
<td align="left">`</td>
<td align="left">`</td>
<td align="center"><code>__or__</code></td>
<td align="center"><code>__ror__</code></td>
</tr>
<tr>
<td align="center">位异或</td>
<td align="left">^</td>
<td align="left"><code>__xor__</code></td>
<td align="center"><code>__rxor__</code></td>
<td align="center"><code>__ixor__</code></td>
</tr>
<tr>
<td align="center">左移</td>
<td align="left">&lt;&lt;</td>
<td align="left"><code>__lshift__</code></td>
<td align="center"><code>__rlshift__</code></td>
<td align="center"><code>__ilshift__</code></td>
</tr>
<tr>
<td align="center">右移</td>
<td align="left">&gt;&gt;</td>
<td align="left"><code>__rshift__</code></td>
<td align="center"><code>__rrshift__</code></td>
<td align="center"><code>__irshift__</code></td>
</tr>
</tbody></table>
<blockquote>
<p>比较运算符重载：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="left">运算符</th>
<th align="left">正向方法</th>
<th align="center">反向方法</th>
<th align="center">后备机制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">相等</td>
<td align="left">a == b</td>
<td align="left"><code>a.__eq__(b)</code></td>
<td align="center"><code>b.__eq__(a)</code></td>
<td align="center">返回id(a) == id(b)</td>
</tr>
<tr>
<td align="center">不相等</td>
<td align="left">a ！= b</td>
<td align="left"><code>a.__ne__(b)</code></td>
<td align="center"><code>b.__ne__(a)</code></td>
<td align="center">返回not (a == b)</td>
</tr>
<tr>
<td align="center">大于</td>
<td align="left">a &gt; b</td>
<td align="left"><code>a.__gt__(b)</code></td>
<td align="center"><code>b.__gt__(a)</code></td>
<td align="center">抛出TypeError</td>
</tr>
<tr>
<td align="center">大于等于</td>
<td align="left">a &gt;= b</td>
<td align="left"><code>a.__ge__(b)</code></td>
<td align="center"><code>b.__ge__(a)</code></td>
<td align="center">抛出TypeError</td>
</tr>
<tr>
<td align="center">小于</td>
<td align="left">a &lt; b</td>
<td align="left"><code>a.__lt__(b)</code></td>
<td align="center"><code>b.__lt__(a)</code></td>
<td align="center">抛出TypeError</td>
</tr>
<tr>
<td align="center">小于等于</td>
<td align="left">a &lt;= b</td>
<td align="left"><code>a.__le__(b)</code></td>
<td align="center"><code>b.__le__(a)</code></td>
<td align="center">抛出TypeError</td>
</tr>
</tbody></table>
<blockquote>
<p>内建函数重载：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(obj)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__reversed__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reversed(obj)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__round__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> round(obj)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数值转换函数重载：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__int__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(obj)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__float__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> float(obj)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__complex__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> complex(obj)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bool(obj)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>成员资格函数in、not in运算符重载</p>
</blockquote>
<p><code>def __contains__(self, e)</code></p>
<blockquote>
<p>索引和切片运算符重载</p>
</blockquote>
<p><code>__getitrm__(self, i)</code>方法<br><code>__setitrm__(self, i, v)</code>方法<br><code>__delitrm__(self, i)</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Indexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> index ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">x = Indexer()</span><br><span class="line">print(x[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>迭代对象重载：</p>
</blockquote>
<p><code>__next__(self)</code> 迭代器<br><code>__iter__(self)</code>可迭代对象</p>
<blockquote>
<p>with环境管理器类内重载:</p>
</blockquote>
<p><code>__enter__</code> 方法将在进入 with 语句时被调用返回由 as 变量管理的对象。<br><code>__exit__</code> 方法将在离开with语句时被调用，且可以用参数来判断离开with语句时是否有异常发生并作出相应的处理。</p>
<blockquote>
<p>属性相关方法重载</p>
</blockquote>
<p><code>__getattr__</code>属性获取<br><code>__setattr__</code>属性赋值<br><code>__delattr__</code>属性删除</p>
<blockquote>
<p>其他</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="left">重载</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>__init__</code></td>
<td align="left">构造函数</td>
<td align="left">对象创建: <code>X = Class(args)</code></td>
</tr>
<tr>
<td align="center"><code>__new__</code></td>
<td align="left">创建</td>
<td align="left">在<strong>init</strong>之前创建对象</td>
</tr>
<tr>
<td align="center"><code>__call__</code></td>
<td align="left">函数调用</td>
<td align="left"><code>X(*args, **kwargs)</code></td>
</tr>
<tr>
<td align="center"><code>__repr__, __str__</code></td>
<td align="left">打印，转换</td>
<td align="left"><code>print(X)，repr(X)，str(X)</code></td>
</tr>
<tr>
<td align="center"><code>__del__</code></td>
<td align="left">析构函数</td>
<td align="left">对X对象收回</td>
</tr>
</tbody></table>
<h2 id="34-函数式编程"><a href="#34-函数式编程" class="headerlink" title="34. 函数式编程"></a>34. 函数式编程</h2><blockquote>
<p>函数是Python内建支持的一种封装，通过把打断代码拆层函数，通过一层层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p>
</blockquote>
<blockquote>
<p>函数式编程（Hunctingal Programming）虽然可以归结到面向过程的程序设计，但其思想更接近数学计算。函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，这种函数是有副作用的。</p>
</blockquote>
<blockquote>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数。Python对函数是编程仅提供部分支持，由于Python允许提供变量，因此python不是纯函数式编程语言。</p>
</blockquote>
<h2 id="35-python中的高阶函数"><a href="#35-python中的高阶函数" class="headerlink" title="35. python中的高阶函数"></a>35. python中的高阶函数</h2><blockquote>
<p>高阶函数：一个函数可以作为参数传给另外一个函数，或者一个函数的返回值为另外一个函数（若返回值为该函数本身，则为递归），满足其一则为高阶函数。</p>
</blockquote>
<ul>
<li>abs</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python内置的绝对值函数</span></span><br><span class="line">a = abs(<span class="number">-10</span>)  <span class="comment"># 直接调用abs()函数</span></span><br><span class="line">f = abs  <span class="comment"># 函数本身赋值给变量，即变量指向函数</span></span><br><span class="line">b = f(<span class="number">-10</span>)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>map</li>
</ul>
<blockquote>
<p>map()函数会根据的函数对指定的序列做映射。<br>map()函数语法：<code>map(function, iterable, ...)</code>，其中第一个参数function表示对序列每个元素进行同样的处理的表达式；iterable表示一个或者多个序列。</p>
</blockquote>
<blockquote>
<p>特别注意，py2返回的是列表，py3返回是一个迭代器。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算平方</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line">data_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">res = map(square, data_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用匿名函数</span></span><br><span class="line">ans = map(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, data_list)</span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line">print(list(res))</span><br><span class="line">print(ans)</span><br><span class="line">print(list(ans))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;map object at 0x0000014F2F0F2A58&gt;</span></span><br><span class="line"><span class="string">[1, 4, 9, 16, 25]</span></span><br><span class="line"><span class="string">&lt;map object at 0x0000014F2F32B860&gt;</span></span><br><span class="line"><span class="string">[1, 4, 9, 16, 25]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>reduce</li>
</ul>
<blockquote>
<p>reduce()函数会对参数序列中元素进行积累。函数将一个数据集合（链表、元组等）中的所有数据进行下列操作：用穿个reduce中的函数function(有两个参数)相对集合中的第1、2个元素进行操作，得到的结果在于第三个数据继续用function函数进行运算，如此循环迭代，最后得到结果。</p>
</blockquote>
<blockquote>
<p>reduce()函数语法：<code>reduce(function, iterable[, initializer])</code>，其中第一个参数是function函数，里面有两个参数；第二个参数iterable是可迭代对象；第三个是可选参数，初始参数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两数相加</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">data_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">res = reduce(add, data_list)  <span class="comment"># 1+2+3+4+5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用匿名函数</span></span><br><span class="line">ans = reduce(<span class="keyword">lambda</span> x, y: x + y, data_list)  <span class="comment"># 1+2+3+4+5</span></span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line">print(ans)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">15</span></span><br><span class="line"><span class="string">15</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>filter</li>
</ul>
<blockquote>
<p>filter()函数用于过滤序列，过滤掉不符合条件的元素，返回符合条件的元素组成的新列表。</p>
</blockquote>
<blockquote>
<p>filter()函数语法：<code>filter(function, iterable)</code>，reduce()接收连个参数，第一个参数function是判断函数，第二个参数iterable是可迭代对象，序列的每个元素作为参数传递给函数进行判断，然后返回True/False，最后将返回True的元素放到新列表中。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 过滤出列表中所有奇数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">data_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">res = filter(is_odd, data_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用匿名函数</span></span><br><span class="line">ans = filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">1</span>, range(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line">print(list(res))</span><br><span class="line">print(ans)</span><br><span class="line">print(list(ans))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;filter object at 0x000001F3A98EB198&gt;</span></span><br><span class="line"><span class="string">[1, 3, 5, 7, 9]</span></span><br><span class="line"><span class="string">&lt;filter object at 0x000001F3A990EB38&gt;</span></span><br><span class="line"><span class="string">[1, 3, 5, 7, 9]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sorted</li>
</ul>
<blockquote>
<p>sort与sorted的区别：</p>
</blockquote>
<ul>
<li>sort是应用在list上的方法，sorted可以对所有可迭代的对象进行排序操作。</li>
<li>list的sort方法返回的是对已经存在的列表进行操作，而内建函数sorted方法返回的是一个新的list，而不是在原来的list上进行的操作。</li>
</ul>
<blockquote>
<p>sorted()函数语法：<code>sorted(iterable, key=None, reverse=False)</code>，其中iterable是可迭代对象；key主要是用来进行比较元素，只有一个参数，具体的函数的参数是取自于可迭代对象中，指定可迭代对象中的一个元素来排序；reverse是排序规则，默认的是False升序，True为降序。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">-1</span>]</span><br><span class="line">b = a</span><br><span class="line">c = [<span class="string">'a'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>, <span class="string">'b'</span>,  <span class="string">'c'</span>, <span class="string">'B'</span>]</span><br><span class="line">d = &#123;<span class="number">1</span>: <span class="string">'D'</span>, <span class="number">3</span>: <span class="string">'B'</span>, <span class="number">5</span>: <span class="string">'A'</span>, <span class="number">4</span>: <span class="string">'E'</span>, <span class="number">2</span>: <span class="string">'C'</span>&#125;</span><br><span class="line">e = [(<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Adam'</span>, <span class="number">92</span>), (<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>)]</span><br><span class="line">a.sort()</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">print(sorted(b))</span><br><span class="line">print(sorted(b, key=<span class="keyword">lambda</span> x: x*<span class="number">-1</span>))  <span class="comment"># 利用key进行倒序排序</span></span><br><span class="line">print(sorted(b, reverse=<span class="literal">True</span>))  <span class="comment"># 利用reverse=True进行倒序排序</span></span><br><span class="line">print(sorted(b, key=abs))  <span class="comment"># 按绝对值大小升序排序</span></span><br><span class="line">print(sorted(c))  <span class="comment"># 字符串排序，按照ASCII大小比较</span></span><br><span class="line">print(sorted(c, key=str.lower))  <span class="comment"># 忽略字符串大小写排序</span></span><br><span class="line">print(sorted(d))  <span class="comment"># 对字典排序默认是对键keys进行排序</span></span><br><span class="line">print(sorted(d.keys()))  <span class="comment"># 对字典按keys值排序</span></span><br><span class="line">print(sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))  <span class="comment"># 还是对字典按keys值排序</span></span><br><span class="line">print(sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]))  <span class="comment"># 对字典按键值value排序升序</span></span><br><span class="line">print(sorted(e,key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))  <span class="comment"># 根据姓名升序排序</span></span><br><span class="line">print(sorted(e,key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)) <span class="comment"># 根据得分降序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[-1, 0, 1, 2, 2, 3, 4]</span></span><br><span class="line"><span class="string">[-1, 0, 1, 2, 2, 3, 4]</span></span><br><span class="line"><span class="string">[4, 3, 2, 2, 1, 0, -1]</span></span><br><span class="line"><span class="string">[4, 3, 2, 2, 1, 0, -1]</span></span><br><span class="line"><span class="string">[0, -1, 1, 2, 2, 3, 4]</span></span><br><span class="line"><span class="string">['A', 'B', 'C', 'a', 'b', 'c']</span></span><br><span class="line"><span class="string">['a', 'A', 'b', 'B', 'C', 'c']</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="string">[(1, 'D'), (2, 'C'), (3, 'B'), (4, 'E'), (5, 'A')]</span></span><br><span class="line"><span class="string">[(5, 'A'), (3, 'B'), (2, 'C'), (1, 'D'), (4, 'E')]</span></span><br><span class="line"><span class="string">[('Adam', 92), ('Bart', 66), ('Bob', 75), ('Lisa', 88)]</span></span><br><span class="line"><span class="string">[('Adam', 92), ('Lisa', 88), ('Bob', 75), ('Bart', 66)]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="36-返回函数"><a href="#36-返回函数" class="headerlink" title="36. 返回函数"></a>36. 返回函数</h2><blockquote>
<p>高阶函数出了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 嵌套函数，内层函数返回值是函数对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">            x += i</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line">res = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)  <span class="comment"># 这里调用的是求和函数，而非求和结果</span></span><br><span class="line">print(res)</span><br><span class="line">print(res())</span><br><span class="line"></span><br><span class="line"><span class="comment">#  结果</span></span><br><span class="line"><span class="string">'''&lt;function lazy_sum.&lt;locals&gt;.sum at 0x000001A4B6E55488&gt;</span></span><br><span class="line"><span class="string">25</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上是一种闭包，详细参见<a href="#19-闭包">19. 闭包</a>。<strong>返回闭包时要牢记：返回函数不要引用任何循环变量，或者后续会发生变化的量。</strong></p>
</blockquote>
<h2 id="37-匿名函数"><a href="#37-匿名函数" class="headerlink" title="37. 匿名函数"></a>37. 匿名函数</h2><p>先观摩下大佬博文<strong><a href="https://blog.csdn.net/PY0312/article/details/88956795" target="_blank" rel="noopener">Python 之 lambda 函数完整详解 &amp; 巧妙运用</a></strong></p>
<blockquote>
<p>匿名函数在python编程语言中使用频率非常高，使用起来非常灵活、巧妙。</p>
</blockquote>
<ul>
<li>python中使用关键字lambda来创建匿名函数，没有函数名字；</li>
<li>lambda只是一个表达式，函数体比def简单很多；</li>
<li>lambda的主体是一个表达式，而不是一个代码块，所以在表达式中只能封装有限的简单的逻辑表达式，复杂的需要函数来实现；</li>
<li>lambda函数拥有自己的命名空间，且不能范围自有列表之外或者全局命名空间里的参数；</li>
</ul>
<blockquote>
<p><strong>注意：</strong>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，内联函数的目的是调用小函数时不占用栈内存从而增加运行效率。</p>
</blockquote>
<blockquote>
<p>lambda函数语法：<code>lambda [arg1 [,arg2,...,argn]]: expression</code></p>
</blockquote>
<ul>
<li>lambda是python关键字，[arg…]和expression由用户自定义</li>
<li>[arg…]是参数列表，形参可以为多个，逗号隔开</li>
<li>expression是个参数表达式，且表达式只能是单行的，只能有一个表达式,且逻辑结束后直接返回数据</li>
<li>返回值在冒号之后设置，返回值和正常的函数一样,可以是任意数据类型。(但是想要返回多个元素要以容器的形式返回)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将lambda函数赋值给一个变量，通过这个变量间接调用该lambda函数</span></span><br><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line">res = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将lambda函数赋值给其他函数，从而将其他函数用该lambda函数替换</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep = <span class="keyword">lambda</span> x: <span class="literal">None</span></span><br><span class="line">t = time.sleep(<span class="number">3</span>)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">s = [<span class="keyword">lambda</span> : i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 嵌套的lambda表达式</span></span><br><span class="line">f = (<span class="keyword">lambda</span> x: (<span class="keyword">lambda</span> y: x + y))</span><br><span class="line">res = f(<span class="number">10</span>)</span><br><span class="line">print(res(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">15</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="38-偏函数"><a href="#38-偏函数" class="headerlink" title="38. 偏函数"></a>38. 偏函数</h2><blockquote>
<p>函数在执行时，要带上所有必要的参数进行调用，有时参数可以在函数被调用之前提前给定，这种情况下，一个函数有一个或多个参数预先就能用上，以便函数能用更少的参数进行调用。</p>
</blockquote>
<blockquote>
<p>偏函数就是将所要承载的函数作为partial()函数的第一个参数，原函数的个参数一次作为partial()函数后续的参数，除非使用关键字参数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对整数100，取得对于不同数m的 100 % m 的余数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mod</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n % m</span><br><span class="line"></span><br><span class="line">mod_by_100 = partial(mod, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">print(mod(<span class="number">100</span>, <span class="number">7</span>))</span><br><span class="line">print(mod_by_100(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大值中每次都有10</span></span><br><span class="line">max_new = partial(max, <span class="number">10</span>)  <span class="comment"># 把10作为max的第一个参数，加到最左边</span></span><br><span class="line">print(max_new(<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">args = (<span class="number">10</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line">print(max(*args))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="39-元编程"><a href="#39-元编程" class="headerlink" title="39. 元编程"></a>39. 元编程</h2><p><strong><a href="https://zhuanlan.zhihu.com/p/114242597" target="_blank" rel="noopener">Python黑魔法：元类和元编程</a></strong><br><strong><a href="https://blog.csdn.net/leongongye/article/details/48343089" target="_blank" rel="noopener">Python 元编程</a></strong></p>
<blockquote>
<p>元编程（Meta Programming）又叫超编程，是指某类计算机程序的编写，这类计算机程序的编写或者超重其他程序（或者自身）作为他们的数据，或者在运行完成部分本应该在编译时完成的工作。多数情况下，与手工编译全部代码相比，程序员可以获得更高的工作效率，或者给与程序员更大的灵活度去处理新的情形而无需重新编译。</p>
</blockquote>
<blockquote>
<p>编写元程序的语言称之为元语言。被操作的程序的语言称之为“目标语言”。一门编程语言可以同时也是自身的元语言的能力称之为“反射”或者“自反”。作为胶水语言的python，对各种语言的库的支持（ctypes、js2py等），就是元编程应用的很好实例。</p>
</blockquote>
<blockquote>
<p>元编程是一种可以将程序当作数据来操作的技术，元编程能够读取，生成，分析或转换其他的程序代码，甚至可以在运行时修改自身。元编程存在的目的，就是多提供了一个抽象层次。</p>
</blockquote>
<blockquote>
<p>在python中，元编程实现通常的手段有：</p>
</blockquote>
<ul>
<li>预定义方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, o)</span>:</span></span><br><span class="line">        self.__obj__ = o</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self.__obj__, name):</span><br><span class="line">            <span class="keyword">return</span> getattr(self.__obj__, name)</span><br><span class="line">        <span class="keyword">return</span> self.__dict__[name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__obj__.iter__()</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line">a = A(l)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">101</span>):</span><br><span class="line">    a.append(i)</span><br><span class="line">print(sum(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是一个简单的agent类，<code>__iter__</code>属于云定义函数，不会调用<code>__getattr__</code>来获得，需要额外定义。在<code>__getattr__</code>和<code>__setattr__</code>两个函数中，可以访问<code>__dict__</code>，而在函数<code>__getattribute__</code>中使用<code>self.__dict__</code>会引发递归，需要用<code>object.getattribute(self, name)</code>访问，<code>getattribute</code>只能用于新式类。</p>
</blockquote>
<ul>
<li>函数赋值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># socket.py中的例子</span></span><br><span class="line">_delegate_methods = (<span class="string">"recv"</span>, <span class="string">"recvfrom"</span>, <span class="string">"recv_into"</span>, <span class="string">"recvfrom_into"</span>, <span class="string">"send"</span>, <span class="string">"sendto"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, family=AF_INET, type=SOCK_STREAM, proto=<span class="number">0</span>, _sock=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> _sock <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        _sock = _realsocket(family, type, proto)</span><br><span class="line">    self._sock = _sock</span><br><span class="line">    <span class="keyword">for</span> method <span class="keyword">in</span> _delegate_method:</span><br><span class="line">        setattr(self, method, getattr(_sock, method))</span><br><span class="line"></span><br><span class="line"><span class="comment"># http代理装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">http_proxy</span><span class="params">(proxyaddr, username=None, password=None)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reciver</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">creator</span><span class="params">(family=socket.AF_INET, type=socket.SOCK_STREAM, proto=<span class="number">0</span>)</span>:</span></span><br><span class="line">            sock = func(family, type, proto)</span><br><span class="line">            sock.connect(proxyaddr)</span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">newconn</span><span class="params">(addr)</span>:</span></span><br><span class="line">                http_connect(sock, addr, username, password)</span><br><span class="line">            sock.connect, sock.connect_ex = nerconn, newconn</span><br><span class="line">            <span class="keyword">return</span> sock</span><br><span class="line">        <span class="keyword">return</span> creator</span><br><span class="line">    <span class="keyword">return</span> reciver</span><br></pre></td></tr></table></figure>

<ul>
<li>描述器</li>
</ul>
<blockquote>
<p>所谓描述器(descriptor)就是带有<code>__get__</code>和<code>__set__</code>函数的对象，当访问某个对象的某个属性，这个属性又是descriptor时，返回值是descriptor的<code>__get__</code>调用的返回，<code>__set__</code>也是类似的，带有<code>__set__</code>的称为data descriptor，而只有<code>__get__</code>的称为non data descriptor</p>
</blockquote>
<blockquote>
<p>Python访问某个对象的某个属性时，是按照以下次序的：</p>
</blockquote>
<ul>
<li>类的数据描述器</li>
<li>instance属性，无论其是否是描述器，都不调用<code>__get__</code></li>
<li>类属性，包括non data descriptor</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():</span><br><span class="line">            <span class="keyword">if</span> hasattr(v, <span class="string">'__meta_init__'</span>):</span><br><span class="line">                v.__meta_init__(k)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AttrBase</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__meta_init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        self.name = k</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> obj[self.name]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, value)</span>:</span></span><br><span class="line">        obj[self.name] = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(dict, metaclass = Meta)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(dict)</span>:</span></span><br><span class="line">    name = AttrBase()</span><br><span class="line"></span><br><span class="line">b = User()</span><br><span class="line">b.name = <span class="string">'shell'</span></span><br><span class="line">print(b)</span><br><span class="line">print(b.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;'name': 'shell'&#125;</span></span><br><span class="line"><span class="string">shell</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当访问<code>b.name</code>时，实际上是去访问了<code>b[&#39;name&#39;]</code>，这个过程不是通过User类重载<code>__getattr__</code>实现的，而是通过descriptor。</p>
</blockquote>
<ul>
<li>元类</li>
</ul>
<blockquote>
<p>具体可以参考之前<a href="#3-python中的元类metaclass">python中的元类metaclass</a></p>
</blockquote>
<ul>
<li>eval函数</li>
</ul>
<blockquote>
<p>eval()函数来执行一个字符串表达式，并返回表达式的值。<br>eval()函数的语法：<code>eval(expression[, globals[, locals]])</code>，expression是表达式；globals是变量作用域，全局命名空间，如果被提供，这必须是一个字典对象；locals是变量作用域，局部变量命名空间，如果被提供，可以是任何映射对象。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 =<span class="string">'2 * 6 / 2 + 2'</span></span><br><span class="line">s2 = <span class="string">'pow(2, 3)'</span></span><br><span class="line">s3 = <span class="string">'2 ** 3'</span></span><br><span class="line"></span><br><span class="line">print(eval(s1))</span><br><span class="line">print(eval(s2))</span><br><span class="line">print(eval(s3))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">8.0</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">8</span></span><br></pre></td></tr></table></figure>

<p><strong>经典案例：使用元类在python语言和数据库中间增加一个抽象ORM层</strong>（可参考元类里面给出的<a href="#3-python中的元类metaclass">使用元类创建ORM实例</a>）</p>
<blockquote>
<p>元编程常见的应用场景</p>
</blockquote>
<ul>
<li>扩展重构语法</li>
<li>开发DSL</li>
<li>生成代码</li>
<li>根据特定场景自动选择代码优化</li>
<li>解决一些正交的架构设计问题</li>
<li>面向切面编程AOP</li>
</ul>
<h2 id="40-捕获异常"><a href="#40-捕获异常" class="headerlink" title="40. 捕获异常"></a>40. 捕获异常</h2><p><strong><a href="https://www.cnblogs.com/beile/p/10789333.html" target="_blank" rel="noopener">python捕获异常及方法总结</a></strong></p>
<blockquote>
<p>在编写程序或者调试程序时，或多或少存在BUG或者异常，这时候就需要进行异常的捕获，根据异常Traceback定位出错点，进行处理。</p>
</blockquote>
<ul>
<li><p>异常类型</p>
<p>(1) Python内置异常</p>
<blockquote>
<p>在Python中，异常也是对象，python的异常处理能力很强大，有很多内置异常，可以为用户准确反馈出错信息。BaseException是所有内置异常的基类，但用户自定义的类并不几层BaseException，所有的异常类都是从Exception继承，且都在exceptions模块中定义。python自动降所有的异常名称放在内建命名空间中，所以程序不必导入exceptions模块即可使用异常，一旦引发而且没有捕捉SystemExit异常，程序执行就会终止，如果交互式回话遇到一个为捕捉的SystemExit异常，会话就会终止。</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""python内置异常类的层次结构"""</span></span><br><span class="line">BaseException  <span class="comment"># 所有异常的基类</span></span><br><span class="line"> +-- SystemExit  <span class="comment"># 解释器请求退出</span></span><br><span class="line"> +-- KeyboardInterrupt  <span class="comment"># 用户中断执行(通常是"ctrl+C")</span></span><br><span class="line"> +-- GeneratorExit  <span class="comment"># 生成器(generator)发生异常来通知退出</span></span><br><span class="line"> +-- Exception  <span class="comment"># 常规异常的基类</span></span><br><span class="line">      +-- StopIteration  <span class="comment"># 迭代器没有更多的值</span></span><br><span class="line">      +-- StopAsyncIteration  <span class="comment"># 必须通过异步迭代器对象的__anext__()方法引发以停止迭代</span></span><br><span class="line">      +-- ArithmeticError  <span class="comment"># 各种算术错误引发的内置异常的基类</span></span><br><span class="line">      |    +-- FloatingPointError  <span class="comment"># 浮点计算错误</span></span><br><span class="line">      |    +-- OverflowError  <span class="comment"># 数值运算结果太大无法表示</span></span><br><span class="line">      |    +-- ZeroDivisionError  <span class="comment"># 除(或取模)零 (所有数据类型)</span></span><br><span class="line">      +-- AssertionError  <span class="comment"># 当assert语句失败时引发</span></span><br><span class="line">      +-- AttributeError  <span class="comment"># 属性引用或赋值失败</span></span><br><span class="line">      +-- BufferError  <span class="comment"># 无法执行与缓冲区相关的操作时引发</span></span><br><span class="line">      +-- EOFError  <span class="comment"># 当input()函数在没有读取任何数据的情况下达到文件结束条件(EOF)时引发</span></span><br><span class="line">      +-- ImportError  <span class="comment"># 导入模块/对象失败</span></span><br><span class="line">      |    +-- ModuleNotFoundError  <span class="comment"># 无法找到模块或在在sys.modules中找到None</span></span><br><span class="line">      +-- LookupError  <span class="comment"># 映射或序列上使用的键或索引无效时引发的异常的基类</span></span><br><span class="line">      |    +-- IndexError  <span class="comment"># 序列中没有此索引(index)</span></span><br><span class="line">      |    +-- KeyError  <span class="comment"># 映射中没有这个键</span></span><br><span class="line">      +-- MemoryError  <span class="comment"># 内存溢出错误(对于Python 解释器不是致命的)</span></span><br><span class="line">      +-- NameError  <span class="comment"># 未声明/初始化对象 (没有属性)</span></span><br><span class="line">      |    +-- UnboundLocalError  <span class="comment"># 访问未初始化的本地变量</span></span><br><span class="line">      +-- OSError  <span class="comment"># 操作系统错误(EnvironmentError、IOError、WindowsError、socket.error、select.error、mmap.error已合并到OSError中，构造函数可能返回子类)</span></span><br><span class="line">      |    +-- BlockingIOError  <span class="comment"># 操作将阻塞对象设置为非阻塞操作</span></span><br><span class="line">      |    +-- ChildProcessError  <span class="comment"># 在子进程上的操作失败</span></span><br><span class="line">      |    +-- ConnectionError  <span class="comment"># 与连接相关的异常的基类</span></span><br><span class="line">      |    |    +-- BrokenPipeError  <span class="comment"># 另一端关闭时尝试写入管道或试图在已关闭写入的套接字上写入</span></span><br><span class="line">      |    |    +-- ConnectionAbortedError  <span class="comment"># 连接尝试被对等方中止</span></span><br><span class="line">      |    |    +-- ConnectionRefusedError  <span class="comment"># 连接尝试被对等方拒绝</span></span><br><span class="line">      |    |    +-- ConnectionResetError  <span class="comment"># 连接由对等方重置</span></span><br><span class="line">      |    +-- FileExistsError  <span class="comment"># 创建已存在的文件或目录</span></span><br><span class="line">      |    +-- FileNotFoundError  <span class="comment"># 请求不存在的文件或目录</span></span><br><span class="line">      |    +-- InterruptedError  <span class="comment"># 系统调用被输入信号中断</span></span><br><span class="line">      |    +-- IsADirectoryError  <span class="comment"># 在目录上请求文件操作(例如 os.remove())</span></span><br><span class="line">      |    +-- NotADirectoryError  <span class="comment"># 在不是目录的事物上请求目录操作(例如 os.listdir())</span></span><br><span class="line">      |    +-- PermissionError  <span class="comment"># 尝试在没有足够访问权限的情况下运行操作</span></span><br><span class="line">      |    +-- ProcessLookupError  <span class="comment"># 给定进程不存在</span></span><br><span class="line">      |    +-- TimeoutError  <span class="comment"># 系统函数在系统级别超时</span></span><br><span class="line">      +-- ReferenceError  <span class="comment"># weakref.proxy()函数创建的弱引用试图访问已经垃圾回收了的对象</span></span><br><span class="line">      +-- RuntimeError  <span class="comment"># 在检测到不属于任何其他类别的错误时触发</span></span><br><span class="line">      |    +-- NotImplementedError  <span class="comment"># 在用户定义的基类中，抽象方法要求派生类重写该方法或者正在开发的类指示仍然需要添加实际实现</span></span><br><span class="line">      |    +-- RecursionError  <span class="comment"># 解释器检测到超出最大递归深度</span></span><br><span class="line">      +-- SyntaxError  <span class="comment"># Python语法错误</span></span><br><span class="line">      |    +-- IndentationError  <span class="comment"># 缩进错误</span></span><br><span class="line">      |    |    +-- TabError  <span class="comment"># Tab和空格混用</span></span><br><span class="line">      +-- SystemError  <span class="comment"># 解释器发现内部错误</span></span><br><span class="line">      +-- TypeError  <span class="comment"># 操作或函数应用于不适当类型的对象</span></span><br><span class="line">      +-- ValueError  <span class="comment"># 操作或函数接收到具有正确类型但值不合适的参数</span></span><br><span class="line">      |    +-- UnicodeError  <span class="comment"># 发生与Unicode相关的编码或解码错误</span></span><br><span class="line">      |    |    +-- UnicodeDecodeError  <span class="comment"># Unicode解码错误</span></span><br><span class="line">      |    |    +-- UnicodeEncodeError  <span class="comment"># Unicode编码错误</span></span><br><span class="line">      |    |    +-- UnicodeTranslateError  <span class="comment"># Unicode转码错误</span></span><br><span class="line">      +-- Warning  <span class="comment"># 警告的基类</span></span><br><span class="line">      |    +-- DeprecationWarning  <span class="comment"># 有关已弃用功能的警告的基类</span></span><br><span class="line">      |    +-- PendingDeprecationWarning  <span class="comment"># 有关不推荐用功能的警告的基类</span></span><br><span class="line">      |    +-- RuntimeWarning  <span class="comment"># 有关可疑的运行时行为的警告的基类</span></span><br><span class="line">      |    +-- SyntaxWarning  <span class="comment"># 关于可疑语法警告的基类</span></span><br><span class="line">      |    +-- UserWarning  <span class="comment"># 用户代码生成警告的基类</span></span><br><span class="line">      |    +-- FutureWarning  <span class="comment"># 有关已弃用功能的警告基类</span></span><br><span class="line">      |    +-- ImportWarning  <span class="comment"># 关于模块导入时可能出错的警告的基类</span></span><br><span class="line">      |    +-- UnicodeWarning  <span class="comment"># 与Unicode相关的警告的基类</span></span><br><span class="line">      |    +-- BytesWarning  <span class="comment"># 与bytes和bytearray相关的警告的基类</span></span><br><span class="line">      |    +-- ResourceWarning  <span class="comment"># 与资源使用相关的警告的基类，被默认警告过滤器忽略。</span></span><br></pre></td></tr></table></figure>

<p>  (2) requests模块的相关异常</p>
<blockquote>
<p>python在开发爬虫时，经常用到requests库，要调用requests模块的内置异常，需要<code>from requests.exceptions import xxx</code>，例如: <code>from requests.exceptions import ConnectionError, ReadTimeout</code> 或者 <code>from requests import ConnectionError, ReadTimeout</code>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># requests模块内置异常类的层次结构</span></span><br><span class="line">IOError</span><br><span class="line"> +-- RequestException  <span class="comment"># 处理不确定的异常请求</span></span><br><span class="line">      +-- HTTPError  <span class="comment"># HTTP错误</span></span><br><span class="line">      +-- ConnectionError  <span class="comment"># 连接错误</span></span><br><span class="line">      |    +-- ProxyError  <span class="comment"># 代理错误</span></span><br><span class="line">      |    +-- SSLError  <span class="comment"># SSL错误</span></span><br><span class="line">      |    +-- ConnectTimeout(+-- Timeout)  <span class="comment"># (双重继承，下同)尝试连接到远程服务器时请求超时，产生此错误的请求可以安全的重试</span></span><br><span class="line">      +-- Timeout  <span class="comment"># 请求超时</span></span><br><span class="line">      |    +-- ReadTimeout  <span class="comment"># 服务器未在指定的时间发送任何数据</span></span><br><span class="line">      +-- URLRequired  <span class="comment"># 发出请求需要有效的URL</span></span><br><span class="line">      +-- TooManyRequired  <span class="comment"># 重定向太多</span></span><br><span class="line">      +-- MissingSchema(+-- ValueError)  <span class="comment"># 缺少URL架构(例如http或https)</span></span><br><span class="line">      +-- InvalidSchema(+-- ValueError)  <span class="comment"># 无效的架构，有效架构清常见defaults.py</span></span><br><span class="line">      +-- InvalidURL(+-- ValueError)  <span class="comment"># 无效的RUL</span></span><br><span class="line">      |    +-- InvalidProxyURL(+-- ValueError)  <span class="comment"># 无效的代理RUL</span></span><br><span class="line">      +-- InvalidHeader(+-- ValueError)  <span class="comment"># 无效的Header</span></span><br><span class="line">      +-- ChunkedEncodingError  <span class="comment"># 服务器声明了chunked编码但发送了一个无效的chunk</span></span><br><span class="line">      +-- ContentDecodingError(+-- BaseHTTPError)  <span class="comment"># 无法解码响应内容</span></span><br><span class="line">      +-- StreamCosumedError(+-- TypeError)  <span class="comment"># 此响应的内容已被使用</span></span><br><span class="line">      +-- RetryError  <span class="comment"># 自定义重试逻辑失败</span></span><br><span class="line">      +-- UnrewindableBodyError  <span class="comment"># 尝试倒回正文时，请求遇到错误</span></span><br><span class="line">      +-- FileModeWarning(+-- DeprecationWarning)  <span class="comment"># 文件以文本模式打开，但Requests确定其二进制长度</span></span><br><span class="line">      +-- RequestsDependencyWarning  <span class="comment"># 导入的依赖项与预期的版本范围不匹配</span></span><br><span class="line"></span><br><span class="line">Warning</span><br><span class="line"> +-- RequestsWarning <span class="comment"># 请求的基本警告</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单的requests请求，测试异常</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> ReadTimeout</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, timeout=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Get Page Failed'</span>, response.status_code)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> (ConnectionError, ReadTimeout):</span><br><span class="line">        print(<span class="string">'Crawling Failed'</span>, url)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    url = <span class="string">'https://www.baidu.com'</span></span><br><span class="line">    print(get_page(url))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&lt;/body&gt; &lt;/html&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>  (3) 用户自定义异常</p>
<blockquote>
<p>用户可以通过创建一个异常类，直接或间接继承Exception类。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义一个异常类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span><span class="params">(Exception)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.msg = msg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> MyError(<span class="string">'类型错误'</span>)</span><br><span class="line"><span class="keyword">except</span> MyError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'My exception occured'</span>, e.msg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">My exception occured 类型错误</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>异常捕获</li>
</ul>
<blockquote>
<p>当发生异常时，需要对异常进行捕获，然后进行处理。python的异常捕获常用try…except…结构，把可能发生错误的语句放在try模块里，用except来处理异常，每个try都必须至少对应一个except。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">try/except</td>
<td align="left">捕获异常并处理</td>
</tr>
<tr>
<td align="center">pass</td>
<td align="left">忽略异常</td>
</tr>
<tr>
<td align="center">as</td>
<td align="left">定义异常实例</td>
</tr>
<tr>
<td align="center">else</td>
<td align="left">如果try中的语句没有引发异常，这执行else中的语句</td>
</tr>
<tr>
<td align="center">finally</td>
<td align="left">无论是否出现异常，都执行的代码</td>
</tr>
<tr>
<td align="center">raise</td>
<td align="left">抛出/引发异常</td>
</tr>
</tbody></table>
<p>  (1) 捕获所有异常</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 捕获所有的异常，包含键盘中断和程序退出请求</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  do somethings</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  print(<span class="string">'捕获所有异常'</span>)</span><br></pre></td></tr></table></figure>

<p>  (2) 捕获指定异常</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 捕获指定异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  do somethings</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  print(<span class="string">'捕获指定异常'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 万能异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  do somethings</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">  print(<span class="string">'万能异常'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获指定的IOError</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  f = open(<span class="string">"test.txt"</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">  print(<span class="string">"open exception: %s: %s"</span> % (e.errno, e.strerror))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">open exception: 2: No such file or directory</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>  (3) 捕获多个异常</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># except同时处理多个异常，不区分优先级</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  do somethings</span><br><span class="line"><span class="keyword">except</span> (&lt;Error1&gt;, &lt;Error2&gt;, ...):</span><br><span class="line">  print(<span class="string">'异常说明'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区分优先级进行处理异常</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行try下的语句，如果引发异常，则执行过程会跳到第一个except语句。</span></span><br><span class="line"><span class="string">如果第一个except中定义的异常与引发的异常匹配，则执行该except中的语句。</span></span><br><span class="line"><span class="string">如果引发的异常不匹配第一个except，则会搜索第二个except，允许编写的except数量没有限制。</span></span><br><span class="line"><span class="string">如果所有的except都不匹配，则异常会传递到下一个调用本代码的最高层try代码中。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  do somethings</span><br><span class="line"><span class="keyword">except</span> &lt;Error1&gt;:</span><br><span class="line">  print(<span class="string">'异常说明1'</span>)</span><br><span class="line"><span class="keyword">except</span> &lt;Error2&gt;:</span><br><span class="line">  print(<span class="string">'异常说明2'</span>)</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line"><span class="keyword">except</span> &lt;Errorn&gt;:</span><br><span class="line">  print(<span class="string">'异常说明n'</span>)</span><br></pre></td></tr></table></figure>

<p>  (4) 异常中的else</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果判断完没有某些异常之后还想做其他事情，就可以用else语句</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  do somethings</span><br><span class="line"><span class="keyword">except</span> &lt;Error1&gt;:</span><br><span class="line">  print(<span class="string">'异常说明1'</span>)</span><br><span class="line"><span class="keyword">except</span> &lt;Error2&gt;:</span><br><span class="line">  print(<span class="string">'异常说明2'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  do other things  <span class="comment"># try语句没有异常才会跳到这</span></span><br></pre></td></tr></table></figure>

<p>  (5) 异常中的finally</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无论是否发生异常都要执行的操作代码</span></span><br><span class="line">str1 = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  int(str1)</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">  print(e)</span><br><span class="line"><span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">  print(e)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">  print(e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">'未发生异常'</span>)  <span class="comment"># try语句没有异常才会跳到这</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">  print(<span class="string">'不管前面怎么样，就是要做'</span>)  <span class="comment"># 不管前面是否异常，都做的事情</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">invalid literal for int() with base 10: 'hello world'</span></span><br><span class="line"><span class="string">不管前面怎么样，就是要做</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>  (6) raise主动触发异常</p>
<blockquote>
<p>raise语句用于抛出、触发异常<br>  raise语法格式：<code>raise [Exception [, arg [, traceback]]]</code>，其中，Exception是异常类型，如ValueError，arg是一个可选的异常参数，当不提供时，默认为None，traceback是跟踪异常对象，可选。</p>
</blockquote>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断数是否为0，是的话抛出异常:"参数错误"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_zero</span><span class="params">(num)</span>:</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">      <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">          <span class="keyword">raise</span> ValueError(<span class="string">'参数错误'</span>)</span><br><span class="line">      <span class="keyword">return</span> num</span><br><span class="line">  <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">      print(e)</span><br><span class="line"></span><br><span class="line">not_zero(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">参数错误</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>  (7) 采用Traceback模块查看异常</p>
<blockquote>
<p>发生异常时，python利用traceback记住引发异常的以及程序的当前状态，维护着traceback对象，从而获取含有异常发生时函数调用堆栈有关的信息。<code>traceback.print_exc(file=open(&#39;error_log.txt&#39;,&#39;w+&#39;))</code></p>
</blockquote>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">  traceback.print_exc()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">File "C:/Users/holysll/PycharmProjects/untitled/test/super_parent_class.py", line 12, in &lt;module&gt;</span></span><br><span class="line"><span class="string">  1/0</span></span><br><span class="line"><span class="string">ZeroDivisionError: division by zero</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>traceback.print_exc()与traceback.format_exc()的区别：</p>
</blockquote>
<ul>
<li>format_exc()返回字符串，而print_exc()则直接给打印出来；</li>
<li>print_exc()还可以接受file参数直接写入到一个文件，如:<code>traceback.print_exc(file=open(&#39;error_log.txt&#39;,&#39;w+&#39;))</code></li>
</ul>
<h2 id="41-python常见的内置数据结构"><a href="#41-python常见的内置数据结构" class="headerlink" title="41. python常见的内置数据结构"></a>41. python常见的内置数据结构</h2><ul>
<li><p>字符串(string)</p>
<ul>
<li><p>由字符组成的有序的序列，是字符的集合</p>
</li>
<li><p>使用单引号’’、双引号””、三引号’’’’’’表示</p>
</li>
<li><p>有顺序、能索引、可迭代、元素能重复、不可变对象</p>
</li>
<li><p>python3中，字符串就是Unicode类型</p>
</li>
<li><p>字符串连接：<code>&quot;分隔符&quot;.join(iterable)</code>，如：<code>&quot;&quot;.join([&#39;1&#39;, &#39;2&#39;, &#39;3&#39;])</code>。<strong>注意：可迭代对象iterable必须是字符串</strong></p>
</li>
<li><p>字符串拼接：通过str + str 将两个字符串拼接得到一个新的字符串</p>
</li>
<li><p>字符串分割：</p>
<ul>
<li><code>str.split(sep=None, maxsplit=-1)</code>，seq表示分割符，缺省默认为空格，maxsplit表示分割次数，-1表示遍历整个字符串；</li>
<li><code>str.rsplit(sep=None, maxsplit=-1)</code>表示从右至左分割；</li>
<li><code>str.splitlines([keepends])</code>按照换行符切分字符串，换行符（<code>&#39;\r&#39;, &#39;\r\n&#39;, &#39;\n&#39;</code>），keepends表示是否保留换行符，默认为False不保留，True则保留会输出换行符；</li>
<li><code>str.partition(seq) -&gt; (head, seq ,tail)</code>从左到右，遇到分割符就把字符串分割成两部分，返回头、分隔符、尾三部分；若没找到分隔符，就返回头和两个空元素的三元组；</li>
<li><code>str.rpartition(seq) -&gt; (head, seq ,tail)</code>从右至左分割；</li>
</ul>
</li>
<li><p>字符串大小写：</p>
<ul>
<li><code>str.upper()</code> 全大写</li>
<li><code>str.lower()</code> 全小写</li>
<li><code>str.swapcase()</code>交互大小写</li>
</ul>
</li>
<li><p>字符串排版：</p>
<ul>
<li><code>str.title()</code> 标题的每个单词都大写</li>
<li><code>str.capitalize()</code> 首字母大写</li>
<li><code>str.center(width[, fillchar])</code> 字符串居中，并使用填充符(fillchar)填充至长度(width)，填充符默认为空格</li>
<li><code>str.zfill(width)</code> 返回指定长度(width)的字符串，右对齐，左边前面填充0</li>
<li><code>str.ljust(width[, fillchar])</code> 字符串左对齐，并使用填充符(fillchar)填充至长度(width)，填充符默认为空格</li>
<li><code>str.rjust(width[, fillchar])</code> 字符串右对齐，并使用填充符(fillchar)填充至长度(width)，填充符默认为空格</li>
</ul>
</li>
<li><p>字符串修改：</p>
<ul>
<li><code>str.replace(old, new[,count])</code> 字符串匹配固定字符进行替换，count表示替换次数，默认全部替换</li>
<li><code>str.strip([chars])</code> 字符串两端去除指定的字符集(chars)，默认是空格</li>
<li><code>str.lstrip([chars])</code> 字符串去除左边指定的字符集(chars)，默认是空格</li>
<li><code>str.lstrip([chars])</code> 字符串去除右边指定的字符集(chars)，默认是空格</li>
</ul>
</li>
<li><p>字符串查找：</p>
<ul>
<li><code>str.find(sub[, start[, end]])</code> 在指定区间[start, end]内，从左至右查找子串，找到返回索引，未找到返回-1</li>
<li><code>str.rfind(sub[, start[, end]])</code> 在指定区间[start, end]内，从右至左查找子串，找到返回索引，未找到返回-1</li>
<li><code>str.index(sub[, start[, end]])</code> 在指定区间[start, end]内，从左至右查找子串，找到返回索引，未找到抛出异常ValueError</li>
<li><code>str.rindex(sub[, start[, end]])</code> 在指定区间[start, end]内，从右至左查找子串，找到返回索引，未找到抛出异常ValueError</li>
</ul>
</li>
<li><p>字符串统计：</p>
<ul>
<li><code>str.count(sub[, start[, end]])</code> 在指定区间[start, end]内，从左至右统计子串sub出现的次数</li>
</ul>
</li>
<li><p>字符串判断：</p>
<ul>
<li><code>str.endswith(suffix[, start[, end]])</code> 在指定区间[start, end]内，字符串是否是suffix结尾</li>
<li><code>str.startswith(suffix[, start[, end]])</code> 在指定区间[start, end]内，字符串是否是suffix开头</li>
<li><code>str.isalnum()</code> 是否是字母和数字组成</li>
<li><code>str.isalpha()</code> 是否是字母</li>
<li><code>str.isdecimal()</code> 是否包含十进制数字</li>
<li><code>str.isdigit()</code> 是否全是全部数字（0-9）</li>
<li><code>str.isidentifier()</code> 是否是仅包含字母、数字和下划线</li>
<li><code>str.islower()</code> 是否都是小写</li>
<li><code>str.isupper()</code> 是否都是大写</li>
<li><code>str.isspace()</code> 是否只包含空白字符</li>
</ul>
</li>
<li><p>字符串格式化：</p>
<ul>
<li><code>&quot;This is %s&quot; % &quot;python&quot;</code></li>
<li><code>&quot;This is {}&quot;.format(&quot;python&quot;)</code></li>
<li><code>&quot;This {0[0]} {0[1]}&quot;.format((&quot;is&quot;,&quot;python&quot;))</code></li>
</ul>
</li>
<li><p>字符串翻倍：<code>str * n</code>，例如<code>&#39;py&#39; * 3</code> 结果是<code>&#39;pypypy&#39;</code></p>
</li>
</ul>
</li>
<li><p>列表(list)</p>
<ul>
<li><p>一个排列整齐的队列，由若干个元素组成</p>
</li>
<li><p>元素可以是任意对象，数字、字符串、字典、元组、列表、对象等</p>
</li>
<li><p>列表内的元素有顺序，可以使用索引，元素能重复，可修改</p>
</li>
<li><p>是线性数据结构，使用中括号[]表示</p>
</li>
<li><p>列表初始化：</p>
<ul>
<li><code>s = list()</code>或<code>s = []</code> 生成一个空列表</li>
<li><code>s = list(iterable)</code> 可将可循环的结构转化为列表，如：<code>s = list(range(5))</code>、<code>s = [1, 2, 3]</code></li>
</ul>
</li>
<li><p>列表索引访问</p>
<ul>
<li><code>list[index]</code> index即是list的索引，也叫下标，从左至右，丛0开始到列表长度减一(len(list)-1)；若从右至左，索引从-1开始；索引不可以越界，否则抛出异常indexError</li>
</ul>
</li>
<li><p>列表查询：</p>
<ul>
<li><code>list.index(value, [start, [stop]])</code> 在指定区间[start, stop]查找列表内的元素是否与value匹配，匹配到第一个就返回索引，匹配不到，抛出异常ValueError</li>
</ul>
</li>
<li><p>列表元素统计：</p>
<ul>
<li><code>list.count(value)</code> 返回列表中匹配value的次数</li>
</ul>
</li>
<li><p>列表元素修改：</p>
<ul>
<li><code>list[index] = value</code></li>
</ul>
</li>
<li><p>列表增加、插入元素</p>
<ul>
<li><code>list.append(object)</code> 尾部追加元素</li>
<li><code>list.insert(index, object)</code> 在指定索引位置插入元素</li>
<li><code>list.extend(iterable)</code> 将可迭代对象的元素追加进来</li>
<li><code>list1 + list2</code>连个列表连接操作，本质上是add()方法</li>
</ul>
</li>
<li><p>列表删除元素</p>
<ul>
<li><code>list.remove(value)</code> 从左至右查找第一个value的值，移除该元素</li>
<li><code>list.pop([index])</code> 根据指定的索引index弹出该元素，当index为空时，默认弹出尾部第一个元素即index=-1;</li>
<li><code>list.clear()</code> 清空列表</li>
</ul>
</li>
<li><p>列表元素排序</p>
<ul>
<li><code>list.sort(key=None, reverse=False)</code>key是用来比较的元素，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象的一个元素进行排序；reverse是排序规则，reverse=True降序，默认reverse=False升序</li>
<li><code>list.reverse()</code> 对列表的元素进行反向排序</li>
</ul>
</li>
<li><p>列表元素打乱顺序</p>
<ul>
<li><code>random.shuffle(list)</code> 就地打乱列表元素</li>
</ul>
</li>
<li><p>列表随机取数</p>
<ul>
<li><code>random.randint(a, b)</code> 返回范围[a, b)之间的整数</li>
<li><code>random.choice(seq)</code> 从非空序列的元素中随机选择一个元素</li>
<li><code>random.randrange([start,] stop[, step])</code> 从指定范围[start, stop]内，按指定步长递增的集合中获取一个随机数</li>
<li><code>random.sample(list, k)</code> 从样本空间或总体中随机取出k个不同的元素</li>
</ul>
</li>
<li><p>列表切片 <strong><a href="https://www.jianshu.com/p/15715d6f4dad" target="_blank" rel="noopener">Python切片操作详细例子</a></strong></p>
<ul>
<li>切片基本表达式：<code>object[start_index : end_index : step]</code> step不写的时候默认为1，<strong>注意索引方向必须与step的方向一致，否则返回空列表</strong></li>
<li>s = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</li>
<li><code>s[:]</code> 或<code>s[::]</code> 从左往右，切取完整列表  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</li>
<li><code>s[::-1]</code> 从右往左，切取完整列表  # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</li>
<li><code>s[1:6]</code> 开始索引为1到索引为6，步长为1，从左往右取值  # [1, 2, 3, 4, 5]</li>
<li><code>s[6:1:-1]</code> 开始索引为6到索引为1，步长为-1，从右往左取值  # [6, 5, 4, 3, 2]</li>
<li><code>s[:6]</code> start_index省略时，这时默认从起点开始，索引为0到索引为6，步长为1，从左往右取值  # [0, 1, 2, 3, 4, 5]</li>
<li><code>s[:6:-1]</code> start_index省略时，这时默认从终点开始，索引为9到索引为6，步长为-1，从右往左取值  # [9, 8, 7]</li>
<li><code>s[6:]</code> end_index省略，这时默认为终点，索引为6到索引为9，步长为1，从左往右取值  # [6, 7, 8, 9]</li>
<li><code>s[6:：-1]</code> end_index省略，这时默认为起点，索引为6到索引为0，步长为-1，从右往左取值  # [6, 5, 4, 3, 2, 1, 0]</li>
<li><code>s[-1:-6:-1]</code> end_index省略，默认为终点，索引为-1到索引为-6，步长为-1，从右往左取值  # [9, 8, 7, 6, 5]</li>
<li><code>s[-6:-1]</code> step省略，索引为-6到索引为-1，步长为1，从左往右取值  # [9, 8, 7, 6, 5]</li>
<li><code>s[:-6]</code> step=1，从左往右取值，从索引0开始到索引-6  # [0, 1, 2, 3]</li>
<li><code>s[:-6:-1]</code> start_index省略，这时默认为终点，step=-1，从右往左取值，从索引-1到索引-6  # [9, 8, 7, 6, 5]</li>
<li><code>s[-6:]</code> end_index省略，这时为终点，step=1，从左往右取值，从索引-6开始到终点  # [4, 5, 6, 7, 8, 9]</li>
<li><code>s[-6::-1]</code> end_index省略，这时为起点，step=-1，从右往左取值，从索引-6到索引0  # [4, 3, 2, 1, 0]</li>
<li><code>s[1:-6]</code> step=1，从左往右取值，从索引1到索引为-6  # [1, 2, 3]</li>
<li><code>s[-1:6:-1]</code> step=-1，从右往左取值，从索引-1到索引6  # [9, 8, 7]</li>
</ul>
</li>
<li><p>多层切片操作：</p>
<ul>
<li><code>s[:8][2:5][-1:]</code> 相当于先<code>s[:8]=[0, 1, 2, 3, 4, 5, 6, 7]</code>，然后<code>[0, 1, 2, 3, 4, 5, 6, 7][2:5]=[2, 3, 4]</code>，最后<code>[2, 3, 4][-1:]=[4]</code></li>
</ul>
</li>
<li><p>带表达式的切片操作：</p>
<ul>
<li><code>s[2+1:3*2:7%3]</code> 先计算各表达式可知，切片操作相当于<code>s[3:6:1]=[3, 4, 5]</code></li>
</ul>
</li>
<li><p>常用切片操作</p>
<ul>
<li>取偶数位置：<code>s[::2]=[0, 2, 4, 6, 8]</code></li>
<li>取奇数位置：<code>s[1::2]=[1, 3, 5, 7, 9]</code></li>
<li>for循环里的切片：<code>for i in range(1, 100)[2::3][-5:]:</code> 分解为三步，先生成[1, 2, 3, …, 99]的整数对象，然后step=3，从左往右取值，从索引2（即3）到终点（即99），得到[3, 6, 9, … , 99]，最后里面取最后五个数[99, 96, 93, 90, 87]</li>
</ul>
</li>
</ul>
</li>
<li><p>元组(tuple)</p>
<ul>
<li>一个有序的元素组成的集合</li>
<li>有顺序、能索引、元素能重复、不可变对象</li>
<li>小括号()表示，单个元素定义时：(1,) 必须带逗号</li>
<li>tuple是只读，没有增删改，其他功能和列表差不多</li>
<li>元组初始化：<code>t = tuple()</code>空元组；<code>t = tuple(iterable)</code> 可迭代对象元组</li>
</ul>
</li>
<li><p>字典(dict)</p>
<ul>
<li><p>key-value键值对形式的数据集合</p>
</li>
<li><p>无顺序、key不可重复、可变可迭代</p>
</li>
<li><p>是非线性数据结构，使用大括号{}表示，里面都是键值对key:value的形式</p>
</li>
<li><p>字典的初始化</p>
<ul>
<li><code>d = dict()</code> 或者 <code>d = {}</code> 新建一个空字典</li>
<li><code>d = {&#39;x&#39;: 1, &#39;y&#39;: 2}</code>  # {‘x’: 1, ‘y’: 2}</li>
<li><code>d = dict(x=1, y=2)</code>  # {‘x’: 1, ‘y’: 2}</li>
<li><code>d = dict(zip(&#39;abc&#39;,[1, 2, 3]))</code>  # {‘a’: 1, ‘b’: 2, ‘c’: 3}</li>
<li><code>d = dict.fromkeys(range(2), 3)</code>  # {0: 3, 1: 3}</li>
<li><code>d = dict.fromkeys((&#39;x&#39;, &#39;y&#39;), 2)</code>  # {‘x’: 2, ‘y’: 2}</li>
<li><code>d = dict([(&#39;x&#39;, 1),(&#39;y&#39;, 2)])</code>  # {‘x’: 1, ‘y’: 2}</li>
</ul>
</li>
<li><p>字典的访问</p>
<ul>
<li><code>d[key]</code> 返回key对应的值value，key不存在时抛出异常KeyError</li>
<li><code>get(key[, default])</code> 返回key对应的值value，key不存在时返回缺省值默认为None</li>
<li><code>setdefault(key[, default])</code> 返回key对应的值value，key不存在时添加key，value为default，并返回default，默认为None</li>
</ul>
</li>
<li><p>字典增加和修改：</p>
<ul>
<li><code>d[key] = value</code> 将key对应的值改为value，若key不存在这添加新的kv对</li>
<li><code>update([other])</code> 使用另一个字典的kv对更新本字典，若key存在就覆盖该key对应的值，若key不存在，就添加。如<code>d.update(x=6)</code>或<code>d.update({&#39;red&#39;: 3, &#39;x&#39;: 9})</code>或<code>d.update(((&#39;red&#39;, 666),(&#39;green&#39;, 333)))</code></li>
</ul>
</li>
<li><p>字典删除：</p>
<ul>
<li><code>d.pop(key[, default])</code> 若key存在，移除它，并返回key对应的value；若key不存在，返回给定的default，default未设置，key不存在时抛出异常KeyError</li>
<li><code>d.popitem()</code> 移除并返回字典中最后一个键值对，若字典为空，抛出KeyError异常</li>
<li><code>d.clear()</code> 清空字典</li>
<li><code>del d[&#39;x&#39;]</code> 删除key为x的键值对，本质是删除对象引用</li>
</ul>
</li>
<li><p>字典遍历：</p>
<ul>
<li>遍历key：<code>for k in d: print(k)</code> 打印的是字典中的key</li>
<li>遍历key：<code>for k in d.keys(): print(k)</code> 打印的是字典中的key</li>
<li>遍历key：<code>for k in d.items(): print(k[0])</code> 打印的是字典中的key</li>
<li>遍历value：<code>for k in d: print(d[k])</code> 打印key对应的value</li>
<li>遍历value：<code>for k in d.keys(): print(d.get(k))</code> 打印key对应的value</li>
<li>遍历value：<code>for v in d.values(): print(v)</code> 打印字典中的value</li>
<li>遍历value：<code>for v in d.items(): print(v[1])</code> 打印字典中的value</li>
<li>遍历item：<code>for item in d.items(): print(item)</code> 打印键值对</li>
<li>遍历item：<code>for item in d.items(): print(item[0], item[1])</code> 打印键值对</li>
<li>遍历item：<code>for k, v in d.items(): print(k, v)</code> 打印键值对</li>
</ul>
</li>
<li><p>字典的遍历移除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = dict(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>, e=<span class="string">'sss'</span>)</span><br><span class="line">keys = []</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="keyword">if</span> isinstance(v, str):</span><br><span class="line">        keys.append(k)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> keys:</span><br><span class="line">    d.pop(k)</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>defaultdict类</p>
<ul>
<li><code>collections.defaultdict([default_factory[, ...]])</code> 第一个参数是default_factory，缺省是None，它提供一个初始化函数，当key不存在时，会调用这个工厂函数的<strong>missing</strong>(key)的方法，返回一个根据default_factory参数的默认值给这个key的value</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 常规方法</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">d1 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="string">'abcdef'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(random.randint(<span class="number">1</span>, <span class="number">5</span>)):</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> d1.keys():</span><br><span class="line">            d1[k] = []</span><br><span class="line">        d1[k].append(i)</span><br><span class="line">print(d1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过defaultdict类</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">d2 = defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="string">'abcdef'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(random.randint(<span class="number">1</span>, <span class="number">5</span>)):</span><br><span class="line">        d2[k].append(i)</span><br><span class="line">print(d2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;'a': [0, 1], 'b': [0], 'c': [0, 1, 2, 3], 'd': [0], 'e': [0, 1, 2, 3, 4], 'f': [0, 1]&#125;</span></span><br><span class="line"><span class="string">defaultdict(&lt;class 'list'&gt;, &#123;'a': [0, 1, 2, 3], 'b': [0, 1], 'c': [0], 'd': [0], 'e': [0, 1], 'f': [0, 1, 2]&#125;)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>OrderedDict记录顺序：</p>
<ul>
<li><code>collections.OrderedDict([items])</code> key并不是按照加入的顺序排列的，可以使用OrderedDict来记录顺序</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">'banana'</span>:<span class="number">3</span>, <span class="string">'apple'</span>:<span class="number">4</span>, <span class="string">'pear'</span>:<span class="number">1</span>, <span class="string">'oranger'</span>:<span class="number">2</span>&#125;</span><br><span class="line">print(d)</span><br><span class="line">keys = list(d.keys())  <span class="comment"># 获取key转化为list</span></span><br><span class="line">random.shuffle(keys)  <span class="comment"># 打乱顺序</span></span><br><span class="line">print(keys)</span><br><span class="line">od = OrderedDict()</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">    od[key] = d[key]</span><br><span class="line">print(od)</span><br><span class="line">print(od.keys())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;'banana': 3, 'apple': 4, 'pear': 1, 'oranger': 2&#125;</span></span><br><span class="line"><span class="string">['oranger', 'pear', 'apple', 'banana']</span></span><br><span class="line"><span class="string">OrderedDict([('oranger', 2), ('pear', 1), ('apple', 4), ('banana', 3)])</span></span><br><span class="line"><span class="string">odict_keys(['oranger', 'pear', 'apple', 'banana'])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>集合(set)</p>
<ul>
<li><p>一个无序的不重复的元素序列</p>
</li>
<li><p>是非线性数据结构，使用大括号{}表示</p>
</li>
<li><p>集合的基本应用：元素测试、list和tuple元素去重</p>
</li>
<li><p>集合支持一些数学操作：并集(union)、交集(intersection)、差集(difference)、对称差集(symmetric difference)</p>
</li>
<li><p>集合的创建：</p>
<ul>
<li><code>set_name = {value1, value2, ...}</code> 类似于字典的创建</li>
<li><code>set_name = set()</code> 空集合必须用set()创建，而不能用{}，这样创建出来的是字典</li>
<li><code>set_name = set(list_name)</code> 把list转化为set类型</li>
</ul>
</li>
<li><p>利用集合去重</p>
<ul>
<li>列表去重：<code>set_name = set(list_name)</code></li>
<li>字符串去重：<code>set_name = set(string)</code></li>
<li>元组去重：<code>set_name = set(tuple)</code></li>
</ul>
</li>
<li><p>集合的数学操作</p>
<ul>
<li>并集：<code>A | B</code> 或 <code>A.union(B)</code>  # A和B的元素都有，且不会重复</li>
<li>交集：<code>A &amp; B</code> 或 <code>A.intersection(B)</code>  # A和B的共同有的元素</li>
<li>差集：<code>A - B</code> 或 <code>A.difference(B)</code>  # A中有，但B中没有的元素</li>
<li>对称差集：<code>A ^ B</code> 或 <code>A.symmetric_difference(B)</code>  # A有或B有，但不是它们都有，除开公共有的元素</li>
</ul>
</li>
<li><p>集合判断包含、子集：</p>
<ul>
<li>A包含B：<code>A.issuperset(B)</code> 或 <code>A &gt;= B</code></li>
<li>B是A的子集：<code>B.issubset(A)</code> 或 <code>B &lt;= A</code></li>
</ul>
</li>
<li><p>集合推导式： <code>s = {x for x in &#39;abcdef&#39; if x not in &#39;abc&#39;}</code></p>
</li>
<li><p>集合新增元素</p>
<ul>
<li>增加单个元素：<code>A.add(3)</code></li>
<li>增加一组元素：<code>A.update([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</code></li>
</ul>
</li>
<li><p>删除集合元素</p>
<ul>
<li>直接删除指定元素：<code>A.remove(3)</code>  # 若元素不存在会报错，建议用discard()方法</li>
<li>如果集合存在指定元素，则删除该元素：<code>A.discard(&#39;a&#39;)</code></li>
<li>随机删除元素：<code>A.pop()</code>  # set 集合的 pop 方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除</li>
<li>清空集合：<code>A.clear()</code></li>
</ul>
</li>
<li><p>判断两个集合包含的元素是否相同：<code>A.isdisjoint(B)</code>  # 若相同返回True, 否则返回False</p>
</li>
</ul>
</li>
</ul>
<h2 id="42-python-bytes与bytearray"><a href="#42-python-bytes与bytearray" class="headerlink" title="42. python bytes与bytearray"></a>42. python bytes与bytearray</h2><blockquote>
<p>常识普及：通常在常用的ASCII、utf-8 和unicode 编码中，像 a 这样一个英文字符，在内存中占一个字节。一个汉字在ASCII和unicode编码里占两个字节，在utf-8 编码中占三个字节。一个字节有八位，也就是八个数字，也叫8个bit 。计算机中的最小储存单位就是bit，bit是二进制的，所以计算机中的数据全都是0和1，没有其他的数字。</p>
</blockquote>
<ul>
<li><p>bytes</p>
<ul>
<li><p>bytes是字节组成的有序的不可变序列</p>
</li>
<li><p>字符串按照不同的字符集编码encode返回直接序列bytes</p>
<ul>
<li><code>encode(encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;) -&gt; str</code></li>
</ul>
</li>
<li><p>字节序列bytes按照不同的字符集解码decode返回字符串</p>
<ul>
<li><code>bytes.decode(encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;) -&gt; str</code></li>
</ul>
</li>
<li><p>bytes的语法：<code>class bytes([source[, encoding[, errors]]])</code></p>
<ul>
<li>若没有输入任何参数，默认就是初始化数组为0个元素：<code>b = bytes()</code>  # 空bytes</li>
<li>若source为整数，则返回一个长度为source的初始化数组：<code>b = bytes(3)</code>   # b’\x00\x00\x00’ 创造三个空字节，每个字节为空</li>
<li>若source为字符串，这找找指定的encoding讲字符串转换为字节序列：<code>b = bytes(&#39;hello&#39;, encoding=&quot;utf-8&quot;)</code>  # b’hello’</li>
<li>若source为可迭代类型，这元素必须为[0,255]中的整数：<code>b = bytes([1, 2, 3, 4])</code>  # b’\x01\x02\x03\x04’</li>
<li>若source为与buffer接口一致的对象，从一个字节序列或者buffer复制出一个新的不可变的bytes对象：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复制bytes对象</span></span><br><span class="line">b1 = bytes([<span class="number">0x61</span>, <span class="number">0x62</span>])</span><br><span class="line">b2 = b1</span><br><span class="line">print(b1, b2)</span><br><span class="line">print(id(b1), id(b2))</span><br><span class="line">print(b1 <span class="keyword">is</span> b2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">b'ab' b'ab'</span></span><br><span class="line"><span class="string">3162472152320 3162472152320</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>空bytes对象创建方式：</p>
<ul>
<li>通过构造函数创建空bytes：<code>b = bytes()</code></li>
<li>通过空字符串创建空bytes：<code>b = b&#39;&#39;</code></li>
</ul>
</li>
<li><p>bytes操作：与字符串操作基本一样(string)，都是不可变类型</p>
<ul>
<li>替换：<code>b&#39;Python&#39;.replace(b&#39;P&#39;, b&#39;p&#39;)</code>  # 里面的参数也是bytes类型的</li>
<li>查找：<code>b&#39;Python&#39;.find(b&#39;o&#39;)</code>  # 返回匹配到字节的索引号，未找到返回-1</li>
<li>十六进制数字组成的字符串转换为bytes</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 十六进制数字组成的字符串</span></span><br><span class="line">s = <span class="string">'49 20 6c 69 6b 65 20 50 79 74 68 6f 6e'</span>  <span class="comment"># 空格是无效的，要空格需要用ASCII编码</span></span><br><span class="line">b = bytes.fromhex(s)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">b'I like Python'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串转化为十六进制表达</span></span><br><span class="line">hex_str = <span class="string">'I like Python'</span>.encode().hex()</span><br><span class="line">print(hex_str)</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(hex_str)):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            res.append(hex_str[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            w = <span class="string">' '</span> + hex_str[i]</span><br><span class="line">            res.append(w)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res.append(hex_str[i])</span><br><span class="line"></span><br><span class="line">print(<span class="string">""</span>.join(res))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">49206c696b6520507974686f6e</span></span><br><span class="line"><span class="string">49 20 6c 69 6b 65 20 50 79 74 68 6f 6e</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将一个字节数组bytes妆花为整数：<code>int.from_bytes(bytes, byteorder</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 大端模式将bytes -&gt; int</span></span><br><span class="line">num = int.from_bytes(<span class="string">b'abcd'</span>, <span class="string">'big'</span>)</span><br><span class="line">print(num, hex(num))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大端模式将int -&gt; bytes</span></span><br><span class="line">print(num.to_bytes(<span class="number">4</span>, <span class="string">'big'</span>))  <span class="comment"># 第一个参数是给定字节数，不够会在前面补空字符的ASCII码</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">97</span></span><br><span class="line">print(b.to_bytes(<span class="number">1</span>, <span class="string">'big'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1633837924 0x61626364</span></span><br><span class="line"><span class="string">b'abcd'</span></span><br><span class="line"><span class="string">b'a'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字节序：</p>
<ul>
<li>大端模式(big-endian)：尾巴放在大地址端<ul>
<li>Mac OS使用大端模式</li>
<li>Java虚拟机是大端模式</li>
<li>网络传输更多使用大端模式</li>
</ul>
</li>
<li>小端模式(little-endian)：尾巴放在低地址端<ul>
<li>Intel X86 CPU使用小端模式</li>
<li>Windows、Linux使用小端模式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>bytearray</p>
<ul>
<li><p>bytearray是字节组成的有序的可变数组</p>
</li>
<li><p>字节数组bytearray按照不同的字符集解码decode返回字符串</p>
<ul>
<li><code>bytearray.decode(encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;) -&gt; str</code></li>
</ul>
</li>
<li><p>bytearray()方法语法：<code>class bytearray([source[, encodeing[, errors]]])</code>，返回一个元素可变的新字节数组，每个元素值必须是[0,256]内的整数，其他类型不行</p>
<ul>
<li>若没有输入任何参数，默认就是初始化数组为0个元素：<code>b = bytearray()</code>  # b’’ 空bytearray</li>
<li>若source为整数，则返回一个长度为 source 的初始化数组：<code>b = bytearray(3)</code>  # bytearray(b’\x00\x00\x00’)</li>
<li>若source为字符串，则按照指定的 encoding 将字符串转换为字节序列：<code>b = bytearray(&#39;python&#39;, encoding=&quot;utf-8&quot;)</code>  # bytearray(b’python’)</li>
<li>若source为可迭代类型，则元素必须为[0 ,255]中的整数：<br><code>b = bytearray([1, 2, 3])</code>  # bytearray(b’\x01\x02\x03’)</li>
<li>若source为与buffer接口一致的对象，从一个字节序列或者buffer复制出一个新的不可变的bytes对象：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复制bytes对象</span></span><br><span class="line">b1 = bytearray([<span class="number">0x61</span>, <span class="number">0x62</span>])</span><br><span class="line">b2 = b1</span><br><span class="line">print(b1, b2)</span><br><span class="line">print(id(b1), id(b2))</span><br><span class="line">print(b1 <span class="keyword">is</span> b2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bytearray(b'ab') bytearray(b'ab')</span></span><br><span class="line"><span class="string">1992609708832 1992609708832</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>bytearray操作：与bytes类型方法相同</li>
<li>替换：<code>bytearray(b&#39;Python&#39;).replace(b&#39;P&#39;, b&#39;p&#39;)</code>  # 里面的参数也是bytes类型的</li>
<li>查找：<code>bytearray(b&#39;Python&#39;).find(b&#39;o&#39;)</code>  # 返回匹配到字节的索引号，未找到返回-1</li>
<li>十六进制数字组成的字符串转换为bytearray</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 十六进制数字组成的字符串</span></span><br><span class="line">s = <span class="string">'49 20 6c 69 6b 65 20 50 79 74 68 6f 6e'</span>  <span class="comment"># 空格是无效的，要空格需要用ASCII编码</span></span><br><span class="line">b = bytearray.fromhex(s)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bytearray(b'I like Python')</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串转化为十六进制表达</span></span><br><span class="line">hex_str = bytearray(<span class="string">'I like Python'</span>.encode()).hex()</span><br><span class="line">print(hex_str)</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(hex_str)):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            res.append(hex_str[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            w = <span class="string">' '</span> + hex_str[i]</span><br><span class="line">            res.append(w)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res.append(hex_str[i])</span><br><span class="line"></span><br><span class="line">print(<span class="string">""</span>.join(res))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">49206c696b6520507974686f6e</span></span><br><span class="line"><span class="string">49 20 6c 69 6b 65 20 50 79 74 68 6f 6e</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>索引</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 索引返回的是该字节对应的ASCII编码</span></span><br><span class="line">b1 = bytearray(<span class="string">b'abcdef'</span>)</span><br><span class="line">print(b1)</span><br><span class="line">print(b1[<span class="number">0</span>])  <span class="comment"># 当取单个字符时，返回的字符所对应的ASCII编码</span></span><br><span class="line">print(b1[:<span class="number">3</span>])  <span class="comment"># 当取字符序列的时候，返回的是对应的字符片段</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bytearray(b'abcdef')</span></span><br><span class="line"><span class="string">97</span></span><br><span class="line"><span class="string">bytearray(b'abc')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>bytearray增加、插入元素</p>
<ul>
<li>尾部追加元素：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = bytearray(<span class="string">b'abcd'</span>)</span><br><span class="line">b.append(<span class="number">101</span>)  <span class="comment"># 这里参数是[0,255]内的整数</span></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bytearray(b'abcde')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>指定索引位置插入元素：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = bytearray(<span class="string">b'abcd'</span>)</span><br><span class="line">b.insert(<span class="number">0</span>, <span class="number">65</span>)  <span class="comment"># 这里第一个参数是索引位置，第二个参数是[0,255]内的整数</span></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bytearray(b'Aabcd')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>bytearray追加可迭代的整数集合，在[0,255]范围内</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = bytearray(<span class="string">b'abcd'</span>)</span><br><span class="line">b.extend(range(<span class="number">101</span>, <span class="number">104</span>))  <span class="comment"># 101、102、103</span></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bytearray(b'abcdefg')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>bytearray移除元素</p>
<ul>
<li>指定索引移除， 索引为空时，默认为-1，表示从移除尾部第一个：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = bytearray(<span class="string">b'abcd'</span>)</span><br><span class="line">b.pop()</span><br><span class="line">print(b)</span><br><span class="line">b.pop(<span class="number">0</span>)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bytearray(b'abc')</span></span><br><span class="line"><span class="string">bytearray(b'bc')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>找到第一个value移除，找不到则抛出ValueError异常：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = bytearray(<span class="string">b'abcd'</span>)</span><br><span class="line">b.remove(<span class="number">99</span>)  <span class="comment"># 移除c</span></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bytearray(b'abd')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>bytearray清空元素</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = bytearray(<span class="string">b'abcd'</span>)</span><br><span class="line">b.clear()</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bytearray(b'')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>bytearray元素反转</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = bytearray(<span class="string">b'abcd'</span>)</span><br><span class="line">b.reverse()</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bytearray(b'dcba')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="43-字符串和字节串的区别"><a href="#43-字符串和字节串的区别" class="headerlink" title="43. 字符串和字节串的区别"></a>43. 字符串和字节串的区别</h2><ul>
<li><p>字符串有若干个字符组成，以字符为单位进行操作；字节串由若干个字节组成，以字节为单位进行操作。</p>
</li>
<li><p>字符串和直接传出了操作的数据单元不同之外，它们支持的所有方法基本相同。</p>
</li>
<li><p>字符串和字节串都是不可变序列，不能随意增加和删除数据。</p>
</li>
<li><p>bytes只负责以字节序列的形式（二进制的形式）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。</p>
</li>
<li><p>bytes只是简单记录内存中的原始数据，不在意这些数据的使用。</p>
</li>
<li><p>字符串和字节串可以通过不同字符集进行相互转换。</p>
</li>
<li><p>bytes类型的数据非常适合在互联网上传输，可用于网络通信编程。</p>
</li>
<li><p>bytes也可以用于存储图片、音频、视频等二进制格式的文件。</p>
</li>
<li><p>字符串转换成bytes对象：</p>
<ul>
<li>字符串内容都是ASCII字符，直接在字符串前面添加<code>b</code>前缀就可以将字符串转换为bytes</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串的内容是英文字母，都是ASCII字符</span></span><br><span class="line">s= <span class="string">'abcdefg'</span></span><br><span class="line">b1 = <span class="string">b'abcdefg'</span></span><br><span class="line">print(b1)</span><br><span class="line">print(b1[<span class="number">0</span>])  <span class="comment"># 当取单个字符时，返回的字符所对应的ASCII编码</span></span><br><span class="line">print(b1[:<span class="number">3</span>])  <span class="comment"># 当取字符序列的时候，返回的是对应的字符片段</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">b'abcdefg'</span></span><br><span class="line"><span class="string">97</span></span><br><span class="line"><span class="string">b'abc'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>bytes是一个类，调用构造方法bytes()，可以将字符串按照指定的字符集转换为bytes，若未指定字符集，默认采用utf-8</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用构造方法bytes()，把字符串转换为bytes</span></span><br><span class="line">s = <span class="string">"我喜欢python，今年25岁"</span></span><br><span class="line">b2 = bytes(s, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">print(b2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">b'\xe6\x88\x91\xe5\x96\x9c\xe6\xac\xa2python\xef\xbc\x8c\xe4\xbb\x8a\xe5\xb9\xb425\xe5\xb2\x81'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过encode()方法见字符串按照指定的字符集转换成对应的字节串，若未指定字符集，默认采用utf-8</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过encode()的方法将字符串转换为bytes</span></span><br><span class="line">s = <span class="string">"我喜欢python，今年25岁"</span></span><br><span class="line">b3 = s.encode(<span class="string">"utf-8"</span>)  <span class="comment"># 如果未指定字符集，默认为utf-8，括号里可不填</span></span><br><span class="line">print(b3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">b'\xe6\x88\x91\xe5\x96\x9c\xe6\xac\xa2python\xef\xbc\x8c\xe4\xbb\x8a\xe5\xb9\xb425\xe5\xb2\x81'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过调用bytes类中的decode()方法，可以将btyes对象按照指定的字符集转换为字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过decode()方法，将bytes转换成字符串</span></span><br><span class="line">b4 = <span class="string">b'\xe6\x88\x91\xe5\x96\x9c\xe6\xac\xa2python\xef\xbc\x8c\xe4\xbb\x8a\xe5\xb9\xb425\xe5\xb2\x81'</span></span><br><span class="line">s = b4.decode(<span class="string">"utf-8"</span>)  <span class="comment"># 如果未指定字符集，默认为utf-8，括号里可不填</span></span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">我喜欢python，今年25岁</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="44-字符集（字符编码）"><a href="#44-字符集（字符编码）" class="headerlink" title="44. 字符集（字符编码）"></a>44. 字符集（字符编码）</h2><blockquote>
<p>ASCII编码，将符号、数字、英文等存储到计算机</p>
</blockquote>
<blockquote>
<p>GB2312编码和GBK编码，将中文存储到计算机</p>
</blockquote>
<blockquote>
<p>Unicode字符集，将全世界文字存储到计算机</p>
</blockquote>
<h2 id="45-python中参数类型有哪些"><a href="#45-python中参数类型有哪些" class="headerlink" title="45. python中参数类型有哪些"></a>45. python中参数类型有哪些</h2><ul>
<li>位置参数：也叫必备参数，指函数调用时，传入的实参数量和位置、类型必须与函数定义时保持一致，即形参和实参的位置数量必须一致</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在调用func函数时，必须按位置传入name和age，多了少了都不行，否则会抛出TypeError异常</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param name: str</span></span><br><span class="line"><span class="string">    :param age: int</span></span><br><span class="line"><span class="string">    :return: tuple</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(name, age)</span><br><span class="line"></span><br><span class="line">func(<span class="string">'lucy'</span> ,<span class="number">18</span>)</span><br><span class="line">func(*(<span class="string">'lucy'</span> ,<span class="number">18</span>))  <span class="comment"># 使用*解构</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">lucy 18</span></span><br><span class="line"><span class="string">lucy 18</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>默认参数</p>
<ul>
<li>函数定义时，为参数设置一个默认值，当函数调用时，没有传入这个参数值，直接使用这个默认值。指定有默认值的形参，必须是在没有默认值的参数的最后，否则会产生语法错误；而且默认参数必须指向不可变对象，如果指向可变对象，多次调用时，可能得到的不是意料之内的结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, y=<span class="number">0</span>)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  :param x: int</span></span><br><span class="line"><span class="string">  :param x: int</span></span><br><span class="line"><span class="string">  :return:</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">print(func(<span class="number">3</span>))  <span class="comment"># 传入参数x=3</span></span><br><span class="line">print(func(<span class="number">3</span>, <span class="number">4</span>))  <span class="comment"># 传入参数x=3, y=4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">7</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关键字参数：函数调用时，是指使用形式参数的名字来确定输入的参数值,（形参的名字=输入的参数值），通过此方式指定函数实参时，不再需要与形参的位置完全一致，只要将参数名写正确即可；使用位置参数和关键字参数混合传参的方式时，关键字参数必须位于所有的位置参数（即前面必须传位置参数，最后在传关键字参数，位置得对应）。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param x: int</span></span><br><span class="line"><span class="string">    :param x: int</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">print(func(<span class="number">3</span>, <span class="number">4</span>))  <span class="comment"># 位置参数</span></span><br><span class="line">print(func(x=<span class="number">3</span>, y=<span class="number">4</span>))  <span class="comment"># 关键字参数</span></span><br><span class="line">print(func(y=<span class="number">4</span>, x=<span class="number">3</span>))  <span class="comment"># 关键字参数，位置改变</span></span><br><span class="line">print(func(<span class="number">3</span>, y=<span class="number">4</span>))  <span class="comment"># 位置参数与关键字混合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">7</span></span><br><span class="line"><span class="string">7</span></span><br><span class="line"><span class="string">7</span></span><br><span class="line"><span class="string">7</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可变位置参数：定义参数时前面加一个*，表示这个参数是可变的，可以接受任意多个参数，这些参数构成一个元组，只能通过位置参数传递。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以接收不定参数，返回的类型是元组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param args:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(type(args))</span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">        sum += i</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line">print(func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">print(func(*(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)))  <span class="comment"># 使用*解构</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;class 'tuple'&gt;</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&lt;class 'tuple'&gt;</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可变关键字参数：定义参数时，在前面加<strong>，`</strong>kwargs`表示这个参数可变，可以接受零个或多个关键字参数，并以字典的形式传入函数体，关键字为字典的key，关键字绑定的值为value，如果可变关键字没有接收到任何参数，则传入函数体一个空字典{}。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只接收可变关键字参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param kwargs:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    kwargs_type = (str(type(kwargs))).split(<span class="string">"'"</span>)[<span class="number">1</span>]</span><br><span class="line">    print(<span class="string">"kwargs: 类型为&#123;0&#125;, 值为&#123;1&#125;"</span>.format(kwargs_type, kwargs))</span><br><span class="line"></span><br><span class="line">func()  <span class="comment"># 未传任何参数，返回空字典</span></span><br><span class="line">func(x=<span class="number">1</span>, y=<span class="number">2</span>, z=<span class="number">3</span>)  <span class="comment"># 关键字对传参</span></span><br><span class="line">func(**&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">3</span>&#125;)  <span class="comment"># 使用**解包字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">kwargs: 类型为dict, 值为&#123;&#125;</span></span><br><span class="line"><span class="string">kwargs: 类型为dict, 值为&#123;'x': 1, 'y': 2, 'z': 3&#125;</span></span><br><span class="line"><span class="string">kwargs: 类型为dict, 值为&#123;'x': 1, 'y': 2, 'z': 3&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可变位置参数与可变关键字参数一起使用，这是可变位置参数必须在前面</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param args:</span></span><br><span class="line"><span class="string">    :param kwargs:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    args_type = (str(type(args))).split(<span class="string">"'"</span>)[<span class="number">1</span>]</span><br><span class="line">    kwargs_type = (str(type(kwargs))).split(<span class="string">"'"</span>)[<span class="number">1</span>]</span><br><span class="line">    print(<span class="string">"args: 类型为&#123;0&#125;, 值为&#123;1&#125;"</span>.format(args_type, args))</span><br><span class="line">    print(<span class="string">"kwargs: 类型为&#123;0&#125;, 值为&#123;1&#125;"</span>.format(kwargs_type, kwargs))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"未传任何参数："</span>)</span><br><span class="line">func()  <span class="comment"># 未传任何参数，返回args为空元组，kwargs我空字典</span></span><br><span class="line">print(<span class="string">"只传入可变位置参数："</span>)</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(<span class="string">"只传入可变关键字参数："</span>)</span><br><span class="line">func(x=<span class="string">'a'</span>, y=<span class="string">'b'</span>, z=<span class="string">'c'</span>)</span><br><span class="line">print(<span class="string">"传入可变位置参数和可变关键字参数："</span>)</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, x=<span class="string">'a'</span>, y=<span class="string">'b'</span>, z=<span class="string">'c'</span>)</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, **&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">3</span>&#125;)  <span class="comment"># 使用 **解包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">未传任何参数：</span></span><br><span class="line"><span class="string">args: 类型为tuple, 值为()</span></span><br><span class="line"><span class="string">kwargs: 类型为dict, 值为&#123;&#125;</span></span><br><span class="line"><span class="string">只传入可变位置参数：</span></span><br><span class="line"><span class="string">args: 类型为tuple, 值为(1, 2, 3)</span></span><br><span class="line"><span class="string">kwargs: 类型为dict, 值为&#123;&#125;</span></span><br><span class="line"><span class="string">只传入可变关键字参数：</span></span><br><span class="line"><span class="string">args: 类型为tuple, 值为()</span></span><br><span class="line"><span class="string">kwargs: 类型为dict, 值为&#123;'x': 'a', 'y': 'b', 'z': 'c'&#125;</span></span><br><span class="line"><span class="string">传入可变位置参数和可变关键字参数：</span></span><br><span class="line"><span class="string">args: 类型为tuple, 值为(1, 2, 3)</span></span><br><span class="line"><span class="string">kwargs: 类型为dict, 值为&#123;'x': 'a', 'y': 'b', 'z': 'c'&#125;</span></span><br><span class="line"><span class="string">args: 类型为tuple, 值为(1, 2, 3)</span></span><br><span class="line"><span class="string">kwargs: 类型为dict, 值为&#123;'x': 1, 'y': 2, 'z': 3&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 位置参数，可变位置参数、默认参数、可变关键字参数结合</span></span><br><span class="line"><span class="comment"># 参数定义顺序：位置参数-&gt;*args-&gt;默认参数-&gt;**kwargs</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(m, n, *args, flag=<span class="number">0</span>, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param args:</span></span><br><span class="line"><span class="string">    :param kwargs:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"m: %s"</span> % m)</span><br><span class="line">    print(<span class="string">"n: %s"</span> % n)</span><br><span class="line">    print(<span class="string">"flag: %s"</span> % flag)</span><br><span class="line">    args_type = (str(type(args))).split(<span class="string">"'"</span>)[<span class="number">1</span>]</span><br><span class="line">    kwargs_type = (str(type(kwargs))).split(<span class="string">"'"</span>)[<span class="number">1</span>]</span><br><span class="line">    print(<span class="string">"args: 类型为&#123;0&#125;, 值为&#123;1&#125;"</span>.format(args_type, args))</span><br><span class="line">    print(<span class="string">"kwargs: 类型为&#123;0&#125;, 值为&#123;1&#125;"</span>.format(kwargs_type, kwargs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">"只传位置参数："</span>)</span><br><span class="line">func(<span class="number">22</span>, <span class="number">33</span>)  <span class="comment"># 这时默认参数flag=0</span></span><br><span class="line">print(<span class="string">"以关键字参数形式传入位置参数："</span>)</span><br><span class="line">func(m=<span class="number">22</span>, n=<span class="number">33</span>)</span><br><span class="line">print(<span class="string">"传入位置参数和可变位置参数："</span>)</span><br><span class="line">func(<span class="number">22</span>, <span class="number">33</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(<span class="string">"位置参数、可变位置参数、默认参数："</span>)</span><br><span class="line">func(<span class="number">22</span>, <span class="number">33</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, flag=<span class="number">666</span>)</span><br><span class="line">print(<span class="string">"位置参数、可变位置参数、默认参数和可变关键字参数："</span>)</span><br><span class="line">func(<span class="number">22</span>, <span class="number">33</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, flag=<span class="number">666</span>, x=<span class="string">'a'</span>, y=<span class="string">'b'</span>, z=<span class="string">'c'</span>)</span><br><span class="line">print(<span class="string">"以**解包形式传入位置参数："</span>)</span><br><span class="line">func(<span class="number">22</span>, <span class="number">33</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, flag=<span class="number">666</span>, **&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">只传位置参数：</span></span><br><span class="line"><span class="string">m: 22</span></span><br><span class="line"><span class="string">n: 33</span></span><br><span class="line"><span class="string">flag: 0</span></span><br><span class="line"><span class="string">args: 类型为tuple, 值为()</span></span><br><span class="line"><span class="string">kwargs: 类型为dict, 值为&#123;&#125;</span></span><br><span class="line"><span class="string">以关键字参数形式传入位置参数：</span></span><br><span class="line"><span class="string">m: 22</span></span><br><span class="line"><span class="string">n: 33</span></span><br><span class="line"><span class="string">flag: 0</span></span><br><span class="line"><span class="string">args: 类型为tuple, 值为()</span></span><br><span class="line"><span class="string">kwargs: 类型为dict, 值为&#123;&#125;</span></span><br><span class="line"><span class="string">传入位置参数和可变位置参数：</span></span><br><span class="line"><span class="string">m: 22</span></span><br><span class="line"><span class="string">n: 33</span></span><br><span class="line"><span class="string">flag: 0</span></span><br><span class="line"><span class="string">args: 类型为tuple, 值为(1, 2, 3)</span></span><br><span class="line"><span class="string">kwargs: 类型为dict, 值为&#123;&#125;</span></span><br><span class="line"><span class="string">位置参数、可变位置参数、默认参数：</span></span><br><span class="line"><span class="string">m: 22</span></span><br><span class="line"><span class="string">n: 33</span></span><br><span class="line"><span class="string">flag: 666</span></span><br><span class="line"><span class="string">args: 类型为tuple, 值为(1, 2, 3)</span></span><br><span class="line"><span class="string">kwargs: 类型为dict, 值为&#123;&#125;</span></span><br><span class="line"><span class="string">位置参数、可变位置参数、默认参数和可变关键字参数：</span></span><br><span class="line"><span class="string">m: 22</span></span><br><span class="line"><span class="string">n: 33</span></span><br><span class="line"><span class="string">flag: 666</span></span><br><span class="line"><span class="string">args: 类型为tuple, 值为(1, 2, 3)</span></span><br><span class="line"><span class="string">kwargs: 类型为dict, 值为&#123;'x': 'a', 'y': 'b', 'z': 'c'&#125;</span></span><br><span class="line"><span class="string">以**解包形式传入位置参数：</span></span><br><span class="line"><span class="string">m: 22</span></span><br><span class="line"><span class="string">n: 33</span></span><br><span class="line"><span class="string">flag: 666</span></span><br><span class="line"><span class="string">args: 类型为tuple, 值为(1, 2, 3)</span></span><br><span class="line"><span class="string">kwargs: 类型为dict, 值为&#123;'x': 1, 'y': 2, 'z': 3&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>仅限关键字参数：在*号之后的参数只能通过关键字参数传递的叫keyword-only参数。其中，可变位置参数之后的参数也是keyword-only参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># *号的参数用关键字参数形式传参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*, x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param x:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line">func(x=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可变位置参数后的参数，也是仅限关键字参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param args:</span></span><br><span class="line"><span class="string">    :param x:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    args_type = (str(type(args))).split(<span class="string">"'"</span>)[<span class="number">1</span>]</span><br><span class="line">    print(<span class="string">"args: 类型为&#123;0&#125;, 值为&#123;1&#125;"</span>.format(args_type, args))</span><br><span class="line">    print(<span class="string">"x: %s"</span> % x)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---- 只传关键字参数: ----"</span>)</span><br><span class="line">func(x=<span class="number">3</span>)</span><br><span class="line">print(<span class="string">"---- 传入可变位置参数和关键字参数：----"</span>)</span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, x=<span class="number">666</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">---- 只传关键字参数: ----</span></span><br><span class="line"><span class="string">args: 类型为tuple, 值为()</span></span><br><span class="line"><span class="string">x: 3</span></span><br><span class="line"><span class="string">---- 传入可变位置参数和关键字参数：----</span></span><br><span class="line"><span class="string">args: 类型为tuple, 值为(1, 2, 3)</span></span><br><span class="line"><span class="string">x: 666</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可变位置参数、普通参数、默认参数组成仅限关键字参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, x, y=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param args:</span></span><br><span class="line"><span class="string">    :param x:</span></span><br><span class="line"><span class="string">    :param y:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    args_type = (str(type(args))).split(<span class="string">"'"</span>)[<span class="number">1</span>]</span><br><span class="line">    print(<span class="string">"args: 类型为&#123;0&#125;, 值为&#123;1&#125;"</span>.format(args_type, args))</span><br><span class="line">    print(<span class="string">"x: %s"</span> % x)</span><br><span class="line">    print(<span class="string">"y: %s"</span> % y)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---- 只传关键字参数: ----"</span>)</span><br><span class="line">func(x=<span class="number">3</span>)</span><br><span class="line">print(<span class="string">"---- 传入可变位置参数和关键字参数：----"</span>)</span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, x=<span class="number">666</span>)</span><br><span class="line">print(<span class="string">"---- 传入可变位置参数、关键字参数和默认参数：----"</span>)</span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, x=<span class="number">666</span>, y=<span class="number">333</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''---- 只传关键字参数: ----</span></span><br><span class="line"><span class="string">args: 类型为tuple, 值为()</span></span><br><span class="line"><span class="string">x: 3</span></span><br><span class="line"><span class="string">y: 0</span></span><br><span class="line"><span class="string">---- 传入可变位置参数和关键字参数：----</span></span><br><span class="line"><span class="string">args: 类型为tuple, 值为(1, 2, 3)</span></span><br><span class="line"><span class="string">x: 666</span></span><br><span class="line"><span class="string">y: 0</span></span><br><span class="line"><span class="string">---- 传入可变位置参数、关键字参数和默认参数：----</span></span><br><span class="line"><span class="string">args: 类型为tuple, 值为(1, 2, 3)</span></span><br><span class="line"><span class="string">x: 666</span></span><br><span class="line"><span class="string">y: 333</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数解构：参数解构发生在函数调用时，可变参数发生在函数定义的时<ul>
<li>*解构：解构对象是可迭代对象，结构后的结果为位置参数</li>
<li>**解构：解构对象是字典，解构后的结果为关键字参数，这里key必须是str类型，且和函数定义的形参名一致，否则抛出TypeError异常</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 位置参数解构</span></span><br><span class="line">data1 = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(add(*data1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字参数解构</span></span><br><span class="line">data2 = &#123;<span class="string">'x'</span>: <span class="number">3</span>, <span class="string">'y'</span>: <span class="number">4</span>&#125;</span><br><span class="line">print(add(**data2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">7</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="46-args和-kwargs的区别"><a href="#46-args和-kwargs的区别" class="headerlink" title="46. args和*kwargs的区别"></a>46. <em>args和*</em>kwargs的区别</h2><blockquote>
<p>*args用来将参数打包成tuple给函数体调用，传递可变位置参数</p>
</blockquote>
<blockquote>
<p>**kwargs打包关键字参数成dict给函数体调用，传递可变关键字参数</p>
</blockquote>
<h2 id="47-实参和形参的区别"><a href="#47-实参和形参的区别" class="headerlink" title="47. 实参和形参的区别"></a>47. 实参和形参的区别</h2><blockquote>
<p>实参：调用函数时的参数，赋予的实际数值或者变量，实参和形参都是引用同一个对象</p>
</blockquote>
<blockquote>
<p>形参：定义函数时的参数，是一个新的、本地的变量名，在函数的本地作用域内</p>
</blockquote>
<h2 id="48-python中函数传参过程"><a href="#48-python中函数传参过程" class="headerlink" title="48. python中函数传参过程"></a>48. python中函数传参过程</h2><ul>
<li>值传递</li>
</ul>
<blockquote>
<p>值传递实际上就是把实际参数值的副本传入函数，不管函数对该值做了什么操作，而参数本身不会受到任何影响。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    a, b = b, a</span><br><span class="line">    print(<span class="string">"func里交换处理完a的值为&#123;&#125;，b的值为&#123;&#125;"</span>.format(a, b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">    print(<span class="string">"交换前a的值为&#123;&#125;，b的值为&#123;&#125;"</span>.format(a, b))</span><br><span class="line">    func(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    print(<span class="string">"交换后a的值为&#123;&#125;，b的值为&#123;&#125;"</span>.format(a, b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">交换前a的值为3，b的值为4</span></span><br><span class="line"><span class="string">func里交换处理完a的值为4，b的值为3</span></span><br><span class="line"><span class="string">交换后a的值为3，b的值为4</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过上面的例子，看出值传递的实质是当系统开始执行函数时，系统对形参执行初始化，就是把实参变量的值赋值给函数的形参变量，在函数中操作的并不是实际的实参变量，而是复制的副本。</p>
</blockquote>
<ul>
<li>引用传递</li>
</ul>
<blockquote>
<p>果果实际参数的数据类型是可变对象（列表，字典、元组、集合等），则函数传递方式将采用引用传递的方式。<strong>而引用传递方式的低层实现，采用的依然还是值传递的方式。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把字典中的key为a和b所对应的值交换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(d)</span>:</span></span><br><span class="line">    d[<span class="string">'a'</span>], d[<span class="string">'b'</span>] = d[<span class="string">'b'</span>], d[<span class="string">'a'</span>]</span><br><span class="line">    print(<span class="string">"func里交换处理a元素的值为&#123;&#125;，b元素的值为&#123;&#125;"</span>.format(d[<span class="string">'a'</span>], d[<span class="string">'b'</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    d = &#123;<span class="string">'a'</span>:<span class="number">3</span>, <span class="string">'b'</span>:<span class="number">4</span>&#125;</span><br><span class="line">    print(<span class="string">"交换前a元素的值为&#123;&#125;，b元素的值为&#123;&#125;"</span>.format(d[<span class="string">'a'</span>], d[<span class="string">'b'</span>]))</span><br><span class="line">    func(d)</span><br><span class="line">    print(<span class="string">"交换后a元素的值为&#123;&#125;，b元素的值为&#123;&#125;"</span>.format(d[<span class="string">'a'</span>], d[<span class="string">'b'</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">交换前a元素的值为3，b元素的值为4</span></span><br><span class="line"><span class="string">func里交换处理a元素的值为4，b元素的值为3</span></span><br><span class="line"><span class="string">交换后a元素的值为4，b元素的值为3</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面例子中，a元素与b元素的值交换成功，func函数执行完，主程序中字典d的a元素和b元素的值也发生了交换，这很容易造成错觉。实际上，程序开始创建了一个字典对象，并定义了一个d的引用变量（其实就是一个“指针”）指向字典对象，现在内存中有对象本身和指向该对象的引用变量；然后，主程序调用func函数，d变量作为参数传入，把主程序中d变量的值赋给func函数的形参d（这里仍然是值传递），同时把指向这个字典对象的地址值也传进来，他们引用的是同一个字典对象；于是，在func函数中对d这个引用变量进行交换操作时，就等于对这个字典对象进行操作，所以主程序中d变量所引用对象的a元素和b元素的值也被交换。</p>
</blockquote>
<p><strong>总而言之：</strong></p>
<ul>
<li>不管什么类型的参数，在python函数中对参数直接使用”=”等号赋值方式是诶用的，并不能改变参数的值。</li>
<li>把这些数据包装成列表、字典等可变对象，然后传参到函数里进行修改，这样数据会发生改变。</li>
</ul>
<h2 id="49-python中可变对象和不可变对象"><a href="#49-python中可变对象和不可变对象" class="headerlink" title="49. python中可变对象和不可变对象"></a>49. python中可变对象和不可变对象</h2><blockquote>
<p>可变对象：list、dict、set、bytearray、array、collections.deque</p>
</blockquote>
<blockquote>
<p>不可变对象：tuple、str、bytes、bool、int、float</p>
</blockquote>
<p><strong>注意：元组是相对不可变的对象， 元组存储的是对象的引用， 当元组中的存在可变对象的引用时， 引用不可变， 但是引用的对象时可变的。</strong></p>
<h2 id="50-python中正则使用方式"><a href="#50-python中正则使用方式" class="headerlink" title="50. python中正则使用方式"></a>50. python中正则使用方式</h2><blockquote>
<p><strong>正则表达式常用的匹配规则</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="left"><strong><em>\</em>***一般字符*****</strong></td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">匹配除换行符”\n”和”\r”之外的任意字符，在re.S模式下则能匹配任意字符</td>
</tr>
<tr>
<td align="center">\</td>
<td align="left">转义字符，使下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符，如果原始字符串中含有`* . ? + $ ^ [ ] ( ) { }</td>
</tr>
<tr>
<td align="center">[…]</td>
<td align="left">字符集，用来表示一组字符，对应的位置可以是字符集中任意一个字符，字符集中的字符可以逐个列出，也可以给出范围如[abc]或[a-c]，所有的特殊字符在字符集中都失去本原有的含义，需要加\进行转义；常见的字符集[0-9]、[a-z]、[A-Z]、<code>^[\u4e00-\u9fa5]*$</code></td>
</tr>
<tr>
<td align="center">[^…]</td>
<td align="left">在字符集内的开头加入非，表示匹配不在字符集内的其他任意字符，如[^abc]表示匹配除abc之外的任意字符</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><strong><em>\</em>***预定义字符集（可以写在字符集[…]中）*****</strong></td>
</tr>
<tr>
<td align="center">\d</td>
<td align="left">匹配任意数字，等价于[0-9]</td>
</tr>
<tr>
<td align="center">\D</td>
<td align="left">匹配任意非数字的字符，等价于[^\d]</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="left">匹配空白字符，等价于[\t\n\r\f]，如\t(Tab)、\r(回车)、’ ‘(空格)、\f(换页符)、\n(换行符)、\v(垂直制表符)</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="left">匹配非空白字符，等价于[^\s]</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="left">匹配字母数字及下划线，等价于[A-Za-z0-9_]</td>
</tr>
<tr>
<td align="center">\W</td>
<td align="left">匹配非字母数字及下划线的其他字符，等价于[^A-Za-z0-9_]</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><strong><em>\</em>***数量词（用在字符或(…)之后）*****</strong></td>
</tr>
<tr>
<td align="center">*</td>
<td align="left">匹配前一个字符、子表达式0次或多次，例如<code>abc*</code>能匹配ab，也能匹配abc、abcc，*等价于{0,}</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">匹配前一个字符、子表达式1次或多次，例如<code>abc+</code>，能匹配abc、abcc，但是不能匹配到ab，+号前的字符至少要匹配一次，+等价于{1,}</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">匹配前一个字符、子表达式0次或1次，例如<code>do(es)?</code>可以匹配到do或does，?等价于{0,1}</td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="left">精确匹配前一个字符、子表达式n次，例如<code>ab{2}c</code>可以匹配到abbc，n为非负整数</td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="left">匹配前一个字符、子表达式至少n次(即[n,+∞])，例如<code>ab{2,}c</code>可以匹配到abbc或abbbbbbbc，n为非负整数</td>
</tr>
<tr>
<td align="center">{,n}</td>
<td align="left">匹配前一个字符、子表达式至多n次(即[0,n])，例如<code>ab{,2}c</code>可以匹配到ac、abc或abbc，n为非负整数</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="left">匹配前一个字符、子表达式最少匹配n次，最多m次(即[n,m])，例如<code>ab{1,2}c</code>可以匹配到abc或abbc，n, m为非负整数，且n&lt;=m</td>
</tr>
<tr>
<td align="center"><code>*?, +?, ??</code></td>
<td align="left">默认情况下<em>、+和?的匹配模式是贪婪模式，即会尽可能对的匹配符合规则的字符，</em>?、+?和??表示启用对应的非贪婪模式。如对于字符串”Pythonnn”，正则表达式Python+能匹配大整个字符串，而Python+?则匹配Python</td>
</tr>
<tr>
<td align="center"><code>{n,m}?</code></td>
<td align="left">同上，启用非贪婪模式，即只匹配n次，n, m为非负整数，且n&lt;=m</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><strong><em>\</em>***边界匹配（不消耗待匹配字符串中的字符）*****</strong></td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">匹配字符串的开头，在多行模式下(re.M)匹配每一行的开头，如^abc可以匹配abc</td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">匹配字符串的末尾，在多行模式下(re.M)匹配每一行的末尾，如abc$可以匹配abc</td>
</tr>
<tr>
<td align="center">\A</td>
<td align="left">仅匹配字符串开头，如\Aabc可以匹配abc</td>
</tr>
<tr>
<td align="center">\Z</td>
<td align="left">仅匹配字符串末尾，如果存在换行，只匹配到换行前的结束字符串，如abc\Z可以匹配abc</td>
</tr>
<tr>
<td align="center">\z</td>
<td align="left">仅匹配字符串末尾，如果存在换行，同时还会匹配到换行符</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="left">匹配单词边界，也就是指单词和空格间的位置，如<code>er\b</code>可以匹配到never中的er，但不能匹配到verb中的er</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="left">匹配非单词边界，也就是指单词和空格间的位置，如<code>er\B</code>可以匹配到verb中的er，但不能匹配到never中的er，等价于[^\b]</td>
</tr>
<tr>
<td align="center">\G</td>
<td align="left">匹配最后匹配完成的位置</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><strong><em>\</em>***逻辑、分组*****</strong></td>
</tr>
<tr>
<td align="center">`</td>
<td align="left">`</td>
</tr>
<tr>
<td align="center">(…)</td>
<td align="left">匹配圆括号中的正则表达式，或者指定一个子组的开始和结束位置，被括起来的表达式将作为分组，从表达式的左边开始每遇到一个分组的左括号’(‘，编号+1；另外分组表达式作为一个整体，后面可以接数量词；表达式中的`</td>
</tr>
<tr>
<td align="center"><code>(?P&lt;name&gt;...)</code></td>
<td align="left">给分组命名，除了愿有你的编号外在指定一个额外的别名，通过分组名字name既可以访问到子组匹配的字串，例如<code>(?P&lt;id&gt;abc){2}</code>能够匹配到abcabc</td>
</tr>
<tr>
<td align="center"><code>\&lt;number&gt;</code></td>
<td align="left">引用序号为<code>&lt;number&gt;</code>对应的子组所匹配到的字符串，子组的序号从1开始计算；如果序号以0开头，或者3个数字的长度，那么不会被引用对应的子组，而是用于匹配八进制数字所表示的ASCII码值所对应的字符。例如<code>(.+) \1</code>会匹配”python python” 或 “66 66”，但不会匹配holysll”</td>
</tr>
<tr>
<td align="center"><code>(?P=name)</code></td>
<td align="left">引用别名为<code>&lt;name&gt;</code>的分组匹配到的字符串，如<code>(?P&lt;id&gt;\d)abc(?P=id)</code>能够匹配到1abc1、5abc5</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><strong><em>\</em>***特殊构造（不作为分组）*****</strong></td>
</tr>
<tr>
<td align="center"><code>(?:...)</code></td>
<td align="left">(…)的不分组版本，用于使用`</td>
</tr>
<tr>
<td align="center"><code>(?aiLmsux)</code></td>
<td align="left">aiLmsux的每个字符代表一种匹配模式，<code>(?</code> 后可以紧跟着 ‘a’，’i’，’L’，’m’，’s’，’u’，’x’ 中的一个或多个字符，只能在正则表达式的开头使用，如<code>(?i)abc</code>匹配模式是忽略大小写，能够匹配abc、Abc、aBc、abC、ABc、AbC、aBC、ABC</td>
</tr>
<tr>
<td align="center"><code>(?#...)</code></td>
<td align="left">#后的内容将作为主食被忽略，如<code>abc(?#comment)123</code>能够匹配abc123</td>
</tr>
<tr>
<td align="center"><code>(?=...)</code></td>
<td align="left">之后的字符串内容需要匹配表达式才能匹配成功，不消耗字符创的内容。如<code>a(?=\d)</code>能匹配后面全是数字的a</td>
</tr>
<tr>
<td align="center"><code>(?!...)</code></td>
<td align="left">之后的字符串内容需要不匹配表达式才能匹配成功，不消耗字符创的内容。如<code>a(?!\d)</code>能匹配后面不是数字的a</td>
</tr>
<tr>
<td align="center"><code>(?&lt;=...)</code></td>
<td align="left">之前的字符串内容需要匹配表达式才能匹配成功，不消耗字符创的内容。如<code>a(?&lt;=\d)</code>能匹配前面是数字的a</td>
</tr>
<tr>
<td align="center"><code>(?&lt;!...)</code></td>
<td align="left">之前的字符串内容需要不匹配表达式才能匹配成功，不消耗字符创的内容。如<code>a(?&lt;!\d)</code>能匹配后面不是数字的a</td>
</tr>
<tr>
<td align="center">`(?(id/name)yes-pattern</td>
<td align="left">no-pattern)`</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>正则表达式的匹配模式：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">flags</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">re.I(IGNORECASE)</td>
<td align="left">忽略大小写，使匹配对大小写不敏感</td>
</tr>
<tr>
<td align="center">re.L(LOCALE)</td>
<td align="left">做本地化识别（locale-aware）匹配</td>
</tr>
<tr>
<td align="center">re.M(MULTILINE)</td>
<td align="left">多行匹配模式，影响^ 和 $</td>
</tr>
<tr>
<td align="center">re.S(DOTALL)</td>
<td align="left">使 . 匹配包括换行在内的所有任意字符</td>
</tr>
<tr>
<td align="center">re.U</td>
<td align="left">根据Unicode字符集解析字符，这个标志影响\w、\W、\b、\B、\d、\D、\s、\S</td>
</tr>
<tr>
<td align="center">re.X(VERBOSE)</td>
<td align="left">该标志通过给予更灵活的格式以便将正则表达式更易于理解，详细表达式</td>
</tr>
<tr>
<td align="center">re.A</td>
<td align="left">只匹配ASCII字符</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>re分组匹配对象的方法：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">group([group1, …])</td>
<td align="left">用于获得一个或者多个分组匹配的字符串，当要获得整个匹配的子串时，使用group()或group(0)；groups()等价于(group(1), group(2), …)</td>
</tr>
<tr>
<td align="center">start([group])</td>
<td align="left">用于获取分组匹配的子串在整个字符串的起始位置（子串第一个字符的索引），参数值默认为0</td>
</tr>
<tr>
<td align="center">end([group])</td>
<td align="left">用于获取分组匹配的子串在整个字符串的结束位置（子串最后一个字符的索引+1），参数值默认为0</td>
</tr>
<tr>
<td align="center">span([group])</td>
<td align="left">返回(start(group), end(group))；span(0) 返回匹配成功的整个子串的索引；span(1) 返回第一个分组匹配成功的子串的索引</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>re模块中一些重要的函数：</strong></p>
</blockquote>
<ul>
<li>search：扫描整个字符串并返回第一个成功的匹配，匹配成功返回一个匹配的对象，否则返回None。</li>
</ul>
<blockquote>
<p>search()函数语法：<code>re.search(pattern, string[, flags])</code> 其中，参数pattern是匹配的正则表达式；参数string是需要匹配的字符串；参数flags是标志位，用于控制正则表达式的匹配模式。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">res = re.search(<span class="string">r'www\.(.*)\.(.&#123;3&#125;)'</span>, <span class="string">'www.baidu.com'</span>, re.I)  <span class="comment"># 忽略大小写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res:</span><br><span class="line">    print(res.groups())  <span class="comment"># 从分组1算起</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"分组0："</span>)</span><br><span class="line">    print(res.group())</span><br><span class="line">    print(res.group(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"分组1："</span>)</span><br><span class="line">    print(res.group(<span class="number">1</span>))</span><br><span class="line">    print(res.start(<span class="number">1</span>))</span><br><span class="line">    print(res.end(<span class="number">1</span>))</span><br><span class="line">    print(res.span(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"分组2："</span>)</span><br><span class="line">    print(res.group(<span class="number">2</span>))</span><br><span class="line">    print(res.start(<span class="number">2</span>))</span><br><span class="line">    print(res.end(<span class="number">2</span>))</span><br><span class="line">    print(res.span(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">('baidu', 'com')</span></span><br><span class="line"><span class="string">分组0：</span></span><br><span class="line"><span class="string">www.baidu.com</span></span><br><span class="line"><span class="string">www.baidu.com</span></span><br><span class="line"><span class="string">分组1：</span></span><br><span class="line"><span class="string">baidu</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">(4, 9)</span></span><br><span class="line"><span class="string">分组2：</span></span><br><span class="line"><span class="string">com</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">13</span></span><br><span class="line"><span class="string">(10, 13)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>match：尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</li>
</ul>
<blockquote>
<p>match()函数语法：<code>re.match(pattern, string[, flags])</code>其中，参数pattern是匹配的正则表达式；参数string是需要匹配的字符串；参数flags是标志位，用于控制正则表达式的匹配模式。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">res = re.search(<span class="string">r'baidu'</span>, <span class="string">'www.baidu.com'</span>, re.I)</span><br><span class="line"><span class="keyword">if</span> res:</span><br><span class="line">    print(<span class="string">"search匹配成功"</span>)</span><br><span class="line">    print(res.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"search匹配失败"</span>)</span><br><span class="line"></span><br><span class="line">rem = re.match(<span class="string">r'baidu'</span>, <span class="string">'www.baidu.com'</span>, re.I)</span><br><span class="line"><span class="keyword">if</span> rem:</span><br><span class="line">    print(<span class="string">"match匹配成功"</span>)</span><br><span class="line">    print(rem.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"match匹配失败"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">search匹配成功</span></span><br><span class="line"><span class="string">baidu</span></span><br><span class="line"><span class="string">match匹配失败</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>compile：用于编译正则表达式，生成一个正则表达式(pattern)对象，供match()和search()这两个函数使用。</li>
</ul>
<blockquote>
<p>compile()函数语法：<code>re.compile(pattern[, flags])</code>其中，参数pattern是匹配的正则表达式；可选参数flags是匹配模式，用于控制正则表达式的匹配模式。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = re.compile(<span class="string">r'\w+'</span>, re.I)</span><br><span class="line">res = pattern.search(<span class="string">'www.baidu.com'</span>)</span><br><span class="line"><span class="keyword">if</span> res:</span><br><span class="line">    print(<span class="string">"compile search匹配成功"</span>)</span><br><span class="line">    print(res.group(<span class="number">0</span>))</span><br><span class="line">    print(res.start(<span class="number">0</span>))</span><br><span class="line">    print(res.end(<span class="number">0</span>))</span><br><span class="line">    print(res.span(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"compile search匹配失败"</span>)</span><br><span class="line"></span><br><span class="line">rem = pattern.match(<span class="string">'www.baidu.com'</span>, <span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line"><span class="keyword">if</span> rem:</span><br><span class="line">    print(<span class="string">"compile match匹配成功"</span>)</span><br><span class="line">    print(rem.group(<span class="number">0</span>))</span><br><span class="line">    print(rem.start(<span class="number">0</span>))</span><br><span class="line">    print(rem.end(<span class="number">0</span>))</span><br><span class="line">    print(rem.span(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"compile match匹配失败"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">compile search匹配成功</span></span><br><span class="line"><span class="string">www</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">(0, 3)</span></span><br><span class="line"><span class="string">compile match匹配成功</span></span><br><span class="line"><span class="string">baidu</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">(4, 9)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>findall：在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。match 和 search 是匹配一次 findall 匹配所有。</li>
</ul>
<blockquote>
<p>findall()函数语法：<code>re.findall(pattern, string[, flags])</code>其中，参数pattern是匹配的正则表达式；参数string是需要匹配的字符串；参数flags是标志位，用于控制正则表达式的匹配模式。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">res = re.findall(<span class="string">r'\w+'</span>, <span class="string">'Hello World!'</span>, re.I)</span><br><span class="line">print(res)  <span class="comment"># 返回的是一个列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">['Hello', 'World']</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过compile编译正则表达式</span></span><br><span class="line">pattern = re.compile(<span class="string">r'\w+'</span>, re.I)</span><br><span class="line">rec = re.findall(pattern, <span class="string">'Hello World!'</span>)</span><br><span class="line">print(rec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">['Hello', 'World']</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sub：将字符串中与模式pattern匹配的子串都替换为repl。</li>
</ul>
<blockquote>
<p>sub()函数语法：<code>re.sub(pattern, repl, string[, count=0, flags])</code>其中，参数pattern是匹配的正则表达式；参数repl是替换的字符串，也可以是一个函数；参数string是需要匹配的字符串；可选参数count是模式匹配后替换的最大次数，默认0表示替换所有的匹配项；可选参数flags是标志位，用于控制正则表达式的匹配模式。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">res0 = re.sub(<span class="string">r'\D'</span>, <span class="string">''</span>, <span class="string">'abc123#￥@'</span>, <span class="number">0</span>, re.I)  <span class="comment"># 把非数字部分删除</span></span><br><span class="line">res1 = re.sub(<span class="string">r'\D'</span>, <span class="string">''</span>, <span class="string">'abc123#￥@'</span>, <span class="number">1</span>, re.I)</span><br><span class="line">res2 = re.sub(<span class="string">r'\D'</span>, <span class="string">''</span>, <span class="string">'abc123#￥@'</span>, <span class="number">3</span>, re.I)</span><br><span class="line">print(res0)</span><br><span class="line">print(res1)</span><br><span class="line">print(res2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">bc123#￥@</span></span><br><span class="line"><span class="string">123#￥@</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过compile编译正则表达式</span></span><br><span class="line">pattern = re.compile(<span class="string">r'\D'</span>, re.I)</span><br><span class="line">res = re.sub(pattern, <span class="string">''</span>, <span class="string">'abc123#￥@'</span>, <span class="number">0</span>)  <span class="comment"># 这时，不能传入flags匹配模式，而要在compile里传入</span></span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># repl是一个函数时，将匹配到的数字乘以2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(num)</span>:</span></span><br><span class="line">    print(num.group(<span class="string">'value'</span>))</span><br><span class="line">    value = int(num.group(<span class="string">'value'</span>))</span><br><span class="line">    <span class="keyword">return</span> str(value * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">result = re.sub(<span class="string">r'(?P&lt;value&gt;\d+)'</span>, double, <span class="string">'a1B23C456d7890'</span>)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">23</span></span><br><span class="line"><span class="string">456</span></span><br><span class="line"><span class="string">7890</span></span><br><span class="line"><span class="string">a2B46C912d15780</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>split：按照能够匹配的子串将字符串分割后返回列表。</li>
</ul>
<blockquote>
<p>split()函数语法：<code>re.split(pattern, string[, maxsplit=0, flags=0])</code>其中，参数pattern是匹配的正则表达式；参数string是需要匹配的字符串；可选参数maxsplit是分割次数，默认为0表示不限制次数；可选参数flags是标志位，用于控制正则表达式的匹配模式。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">res1 = re.split(<span class="string">'\W+'</span>, <span class="string">'www.baidu.com'</span>)</span><br><span class="line">res2 = re.split(<span class="string">'(\W+)'</span>, <span class="string">'www.baidu.com'</span>)</span><br><span class="line">res3 = re.split(<span class="string">'\W+'</span>, <span class="string">'www.baidu.com'</span>, <span class="number">1</span>)  <span class="comment"># 分割一次</span></span><br><span class="line">res4 = re.split(<span class="string">'p*'</span>, <span class="string">'www.baidu.com'</span>)  <span class="comment"># 匹配不到的正则表达式</span></span><br><span class="line">print(res1)</span><br><span class="line">print(res2)</span><br><span class="line">print(res3)</span><br><span class="line">print(res4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">['www', 'baidu', 'com']</span></span><br><span class="line"><span class="string">['www', '.', 'baidu', '.', 'com']</span></span><br><span class="line"><span class="string">['www', 'baidu.com']</span></span><br><span class="line"><span class="string">['', 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '']</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>escape：将字符串中所有的特殊字正则表达式字符转义，当大量主要加反斜杠\进行转义时，这个函数很有用，避免一些不必要的错误，实际上功能有点类似正则表达式前面加r。</li>
</ul>
<blockquote>
<p>escape()函数语法：<code>re.escape(pattern)</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">res = re.escape(<span class="string">'www.python.org'</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">result = re.findall(re.escape(<span class="string">'.py'</span>), <span class="string">"python www.python.org proxy.py"</span>)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">www\.python\.org</span></span><br><span class="line"><span class="string">['.py', '.py']</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>手写正则邮箱地址：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">email_addr = <span class="string">'Please reply this email to &lt;abc23@sample.com.cn&gt;'</span></span><br><span class="line"><span class="comment"># tool.chinaz.com给出的是：\w[-\w.+]*@([A-Za-z0-9][-A-Za-z0-9]+\.)+[A-Za-z]&#123;2,14&#125;</span></span><br><span class="line">pattern = re.compile(<span class="string">r'([\w\.-]+)@([\w\.-]+)(\.[\w\.]+)'</span>)</span><br><span class="line">res = re.search(pattern, email_addr)</span><br><span class="line"><span class="keyword">if</span> res:</span><br><span class="line">    print(res.group)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"匹配失败"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">abc23@sample.com.cn</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p><strong><a href="http://tool.chinaz.com/regex" target="_blank" rel="noopener">常用正则表达式</a></strong></p>
<table>
<thead>
<tr>
<th align="center">目标</th>
<th align="left">表达式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">中文字符</td>
<td align="left"><code>[\u4e00-\u9fa5]</code></td>
</tr>
<tr>
<td align="center">双字节字符(包括汉字在内)</td>
<td align="left"><code>[^\x00-\xff]</code></td>
</tr>
<tr>
<td align="center">空白行</td>
<td align="left"><code>\n\s*\r</code></td>
</tr>
<tr>
<td align="center">Email地址</td>
<td align="left"><code>\w[-\w.+]*@([A-Za-z0-9][-A-Za-z0-9]+\.)+[A-Za-z]{2,14}</code></td>
</tr>
<tr>
<td align="center">网址URL</td>
<td align="left"><code>[a-zA-z]+://[^\s]*</code> 或 `^((https</td>
</tr>
<tr>
<td align="center">国内电话号码</td>
<td align="left"><code>[0-9-()（）]{7,18}</code></td>
</tr>
<tr>
<td align="center">国内手机号码</td>
<td align="left">`0?(13</td>
</tr>
<tr>
<td align="center">QQ号码</td>
<td align="left"><code>[1-9]([0-9]{5,11})</code></td>
</tr>
<tr>
<td align="center">邮政编码</td>
<td align="left"><code>\d{6}</code></td>
</tr>
<tr>
<td align="center">身份证号</td>
<td align="left">`^(\d{6})(\d{4})(\d{2})(\d{2})(\d{3})([0-9]</td>
</tr>
<tr>
<td align="center">日期格式</td>
<td align="left">`\d{4}(-</td>
</tr>
<tr>
<td align="center">IP地址</td>
<td align="left">`(25[0-5]</td>
</tr>
<tr>
<td align="center">整数</td>
<td align="left"><code>-?[1-9]\d*</code></td>
</tr>
<tr>
<td align="center">正整数</td>
<td align="left"><code>[1-9]\d*</code></td>
</tr>
<tr>
<td align="center">负整数</td>
<td align="left"><code>-[1-9]\d*</code></td>
</tr>
<tr>
<td align="center">正浮点数</td>
<td align="left">`[1-9]\d<em>.\d</em></td>
</tr>
<tr>
<td align="center">负浮点数</td>
<td align="left">`-([1-9]\d<em>.\d</em></td>
</tr>
<tr>
<td align="center">用户名(字母、数字、下划线、-、以及中文)</td>
<td align="left"><code>[A-Za-z0-9_\-\u4e00-\u9fa5]+</code></td>
</tr>
</tbody></table>
<h2 id="51-Numpy、Scipy、Panadas的区别"><a href="#51-Numpy、Scipy、Panadas的区别" class="headerlink" title="51. Numpy、Scipy、Panadas的区别"></a>51. Numpy、Scipy、Panadas的区别</h2><blockquote>
<p>Numpy是数值计算的扩展包，能够高效处理N为数组、复杂函数、线性代数。Numpy专门针对ndarray的操作和运算进行了设计，所以数据的存储效率和输入输出性能远优于Python中的嵌套列表，当数组越大时，Numpy的优势越明显，因此用来存储和处理大型矩阵比嵌套列表结构高效的多，可以说是一种免费而强大的Matlab系统。</p>
</blockquote>
<p><strong><a href="https://blog.csdn.net/holysll/article/details/89350260" target="_blank" rel="noopener">Numpy库里有哪些函数</a></strong></p>
<blockquote>
<p>Scipy是专门用于科学计算的一个常用库，可以插值运算、优化算法、图像处理、常微分方程数值解的求解、信号处理、稀疏矩阵和数学统计等等。Scipy是基于Numpy，并且封装了一些高阶抽象和物理模型，是Numpy和Scipy协同工作，高效解决问题。</p>
</blockquote>
<p><strong><a href="https://www.jianshu.com/p/6c742912047f" target="_blank" rel="noopener">Python机器学习及分析工具：Scipy篇</a></strong></p>
<blockquote>
<p>Pandas是基于Numpy的一种工具，提供了一套名为DataFrame的数据结构，适合统计分析中的表结构，在上层做数据分析，所以也称为表格容器。Pandas 所包含的数据结构和数据处理工具的设计，使得数据清洗和分析非常快捷，并经常和其他Numpy、Scipy数值计算工具、数据可视化工具Matplotlib结合起来使用，其中大量库和一些标准的数据模型、函数和方法，支持着大型数据集的高效处理。</p>
</blockquote>
<p><strong><a href="https://blog.csdn.net/holysll/article/details/89396976" target="_blank" rel="noopener">Pandas库中的函数</a></strong></p>
<h2 id="52-python中反射机制"><a href="#52-python中反射机制" class="headerlink" title="52. python中反射机制"></a>52. python中反射机制</h2><p><strong><a href="https://www.jianshu.com/p/8e62449c936c" target="_blank" rel="noopener">Python的反射机制</a></strong></p>
<blockquote>
<p>反射的核心本质其实就是通过字符串的形式导入模块，通过字符串的形式，去模块中找指定函数，并执行。利用字符串的形式去对象（模块）中操作（增删改查）成员，是一种基于字符串的事件驱动。实现思路：规定用户输入格式 模块名/函数名 通过<strong>import</strong>的形式导入模块，并通过 hasattr和getattr 检查并获取函数返回值。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getattr</td>
<td align="left">根据字符串形式去某个模块中寻找东西</td>
</tr>
<tr>
<td align="center">hasattr</td>
<td align="left">根据字符串形式去某个模块中判断东西是否存在</td>
</tr>
<tr>
<td align="center">setattr</td>
<td align="left">根据字符串形式去某个模块中设置东西</td>
</tr>
<tr>
<td align="center">delattr</td>
<td align="left">根据字符串形式去某个模块中删除东西</td>
</tr>
</tbody></table>
<ul>
<li>实例1：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"f1是这个函数的名字！"</span>)</span><br><span class="line"></span><br><span class="line">s = <span class="string">"f1"</span></span><br><span class="line">print(<span class="string">"%s是个字符串"</span> % s)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面代码中，f1是函数f1()的函数名，”f1”是字符串，两者有本质的区别。可以通过f1()的方式调用函数f1，但是不能”f1”()方式去调用函数f1()，实际上就是不能通过字符串来调用名字看起来相同的函数。</p>
</blockquote>
<blockquote>
<p>利用python反射机制简单实现”f1”调用函数f1()：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"f1是这个函数的名字！"</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过用户输入形式，以字符串形式导入模块</span></span><br><span class="line">module_name = input(<span class="string">"请输入需要导入的模块名："</span>)</span><br><span class="line"><span class="comment"># __import__用于以字符串形式导入模块</span></span><br><span class="line">module = __import__(module_name)</span><br><span class="line"><span class="comment"># 在模块寻找的函数名</span></span><br><span class="line">func = input(<span class="string">"请输入需要自行的函数："</span>)</span><br><span class="line"><span class="comment"># 判断函数该模块中是否有这个函数</span></span><br><span class="line"><span class="keyword">if</span> hasattr(module, func):</span><br><span class="line">    target_func = getattr(module, func)</span><br><span class="line">    target_func()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"&#123;&#125;模块中没有&#123;&#125;函数."</span>.format(module_name, func))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">请输入需要导入的模块名：test</span></span><br><span class="line"><span class="string">请输入需要自行的函数：f1</span></span><br><span class="line"><span class="string">f1是这个函数的名字！</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 这样就实现了通过输入字符串f1，调用test.py的里的f1()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实例2：基于反射模拟Web框架路由系统</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views.py 视图模块</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"这是一个登陆页面！"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"这是一个退出页面！"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"这是网站主页面！"</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据输入网址url访问相应的页面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    url = input(<span class="string">"请输入想要访问页面的url："</span>).strip()</span><br><span class="line">    module_name, func_name = url.split(<span class="string">"/"</span>)</span><br><span class="line">    module = __import__(<span class="string">"lib."</span> + module_name, fromlist=<span class="literal">True</span>)  <span class="comment"># 如果和模块不在同一级目录下面，则需要在前面加目录</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(module, func_name):</span><br><span class="line">        func = getattr(module, func_name)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"404"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    run()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入views/login</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">请输入想要访问页面的url：views/login</span></span><br><span class="line"><span class="string">这是一个登陆页面！</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 输入views/logout</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">请输入想要访问页面的url：views/logout</span></span><br><span class="line"><span class="string">这是一个退出页面！</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 输入views/home</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">请输入想要访问页面的url：views/home</span></span><br><span class="line"><span class="string">这是网站主页面！</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 输入views/find</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">请输入想要访问页面的url：views/find</span></span><br><span class="line"><span class="string">404</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="53-python中如何管理依赖"><a href="#53-python中如何管理依赖" class="headerlink" title="53. python中如何管理依赖"></a>53. python中如何管理依赖</h2><blockquote>
<p>Anaconda是包管理和环境管理器，可以帮助用户很方便的管理大量的第三方架包，但是不一定适合所有项目，在加上很多项目部署在linux服务器上，所以就需要对项目依赖进行独立管理。</p>
</blockquote>
<ul>
<li>配置pip镜像源</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># window系统，在C:\Users\用户名\pip\pip.ini（没有pip文件夹就新建）</span></span><br><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line"><span class="comment"># linux系统，vi ~/.pip/pip.conf</span></span><br><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>

<ul>
<li>每个项目创建独立的虚拟环境</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一种：安装virtualenv</span></span><br><span class="line">pip install virtualenv</span><br><span class="line"><span class="comment"># 检查virtualenv是否安装成功</span></span><br><span class="line">virtualenv --version</span><br><span class="line"><span class="comment"># 如果提示-bash: virtualenv: command not found则</span></span><br><span class="line">find / -name virtualenv  <span class="comment"># 全局查找virtualenv</span></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/virtualenv /usr/bin/virtualenv  <span class="comment"># 添加软链接</span></span><br><span class="line"><span class="comment"># 创建独立干净的项目虚拟环境</span></span><br><span class="line">virtualenv --no-site-packages project1</span><br><span class="line"><span class="comment"># 启动虚拟环境</span></span><br><span class="line"><span class="built_in">source</span> project1/bin/activate</span><br><span class="line">workon project1  <span class="comment"># 这种方式也能启动虚拟环境</span></span><br><span class="line"><span class="comment"># 退出虚拟环境</span></span><br><span class="line">deactivate</span><br><span class="line"><span class="comment"># 删除虚拟环境</span></span><br><span class="line">rmvirtualenv project1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种：安装virtualenvwrapper</span></span><br><span class="line">pip install virtualenvwrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line">vi ~/.bashrc 或者 vi ~/.bash_profile</span><br><span class="line"><span class="comment"># 添加配置信息</span></span><br><span class="line"><span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.virtualenvs</span><br><span class="line"><span class="built_in">export</span> PROJECT_HOME=<span class="variable">$HOME</span>/workspace  <span class="comment"># 添加项目路径，这样切换到虚拟环境时就会自动切换到项目根目录下</span></span><br><span class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/bin/virtualenvwrapper.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存退出后，刷新修改的配置</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建虚拟环境</span></span><br><span class="line">mkvirtualenv -p python3 project1  <span class="comment"># 表示Python的项目</span></span><br><span class="line"><span class="comment"># 查看所有虚拟环境</span></span><br><span class="line">workon Tab Tab</span><br><span class="line"><span class="comment"># 切换、进入虚拟环境</span></span><br><span class="line">workon project1</span><br><span class="line"><span class="comment"># 退出虚环境</span></span><br><span class="line">deactivate</span><br><span class="line"><span class="comment"># 删除虚拟环境</span></span><br><span class="line">rmvirtualenv project1</span><br></pre></td></tr></table></figure>

<ul>
<li>导出项目依赖，锁定版本，迁移</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导出项目依赖</span></span><br><span class="line">pip freeze &gt; requirements.txt</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<h2 id="54-如何分析python代码性能"><a href="#54-如何分析python代码性能" class="headerlink" title="54. 如何分析python代码性能"></a>54. 如何分析python代码性能</h2><p><strong><a href="https://blog.csdn.net/lhh08hasee/article/details/80032193" target="_blank" rel="noopener">python程序代码性能分析和计时统计</a></strong></p>
<blockquote>
<p>以下方法分别针对代码块、代码程序文件、 函数进行性能计时统计:</p>
</blockquote>
<ul>
<li>time.time()或者datetime.datetime.now()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 结束时间-开始时间</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">start = time.time()  <span class="comment"># 或者datetime.datetime.now()</span></span><br><span class="line">func()  <span class="comment"># 需要统计运行时长的函数</span></span><br><span class="line">end = time.time()</span><br><span class="line">print(end - start)</span><br></pre></td></tr></table></figure>

<ul>
<li>time.clock()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">clock() 函数以浮点数计算的秒数返回当前的CPU时间，用来衡量不用程序的耗时，比time.time更有用。在win系统下，这个函数返回的是真实时间(wall time)，而在Unix/Linux下返回的是CPU 时间。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start = time.clock()</span><br><span class="line">func()  <span class="comment"># 需要统计运行时长的函数</span></span><br><span class="line">end = time.time()</span><br><span class="line">print(end - start)</span><br></pre></td></tr></table></figure>

<ul>
<li>time</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在linux下对整个程序做计时统计</span></span><br><span class="line"></span><br><span class="line">/usr/bin/time -p python test.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入内容</span></span><br><span class="line"><span class="comment"># real 0m2.057s  记录了整体的耗时</span></span><br><span class="line"><span class="comment"># user 0m0.033s  记录了CPU花在任务上的时间，但不保罗内核函数花费的时间</span></span><br><span class="line"><span class="comment"># sys 0m0.011s  记录了内核函数花费的时间</span></span><br><span class="line"><span class="comment"># user + sys  即是cpu总共花费的时间</span></span><br><span class="line"><span class="comment"># real - (user + sys)  得到可能是花费在等待IO的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开–verbose开关来获得更多输出信息</span></span><br><span class="line">/usr/bin/time --verbose python test.py</span><br></pre></td></tr></table></figure>

<ul>
<li>cProfile：分析分析cpu使用情况</li>
</ul>
<blockquote>
<p>cProfile：基于lsprof的用C语言实现的扩展应用，运行开销比较合理，适合分析运行时间较长的程序，推荐使用这个模块。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令生成统计文件</span></span><br><span class="line">python -m cProfile test.py  <span class="comment"># 直接输出统计结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面这条命令等价于</span></span><br><span class="line"><span class="keyword">import</span> cProfile</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">cProfile.run(<span class="string">'re.compile("test")'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令生成统计文件(二进制数据文件)</span></span><br><span class="line">python -m cProfile -o stats test.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面这条命令等价于</span></span><br><span class="line"><span class="keyword">import</span> cProfile</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">cProfile.run(<span class="string">'re.compile("test")'</span>, <span class="string">'stats'</span>, <span class="string">'cumtime'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后，通过python分析生成的统计文件</span></span><br><span class="line"><span class="keyword">import</span> pstats</span><br><span class="line"></span><br><span class="line">p = pstats.Stats(<span class="string">"stats"</span>)</span><br><span class="line">p.print_stats()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Hello World</span></span><br><span class="line"><span class="string">         5 function calls in 2.001 seconds</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   Ordered by: standard name</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span></span><br><span class="line"><span class="string">        1    0.000    0.000    2.001    2.001 test.py:10(&lt;module&gt;)</span></span><br><span class="line"><span class="string">        1    0.000    0.000    2.001    2.001 &#123;built-in method builtins.exec&#125;</span></span><br><span class="line"><span class="string">        1    0.000    0.000    0.000    0.000 &#123;built-in method builtins.print&#125;</span></span><br><span class="line"><span class="string">        1    2.001    2.001    2.001    2.001 &#123;built-in method time.sleep&#125;</span></span><br><span class="line"><span class="string">        1    0.000    0.000    0.000    0.000 &#123;method 'disable' of '_lsprof.Profiler' objects&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>统计表中各参数含义：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ncalls</td>
<td align="left">表示函数调用的次数</td>
</tr>
<tr>
<td align="center">tottime</td>
<td align="left">表示指定函数的总的运行时间，除掉函数中调用子函数的运行时间</td>
</tr>
<tr>
<td align="center">percall</td>
<td align="left">第一个percall）等于 tottime/ncalls</td>
</tr>
<tr>
<td align="center">cumtime</td>
<td align="left">表示该函数及其所有子函数的调用运行的时间，即函数开始调用到返回的时间</td>
</tr>
<tr>
<td align="center">percall</td>
<td align="left">（第二个percall）即函数运行一次的平均时间，等于 cumtime/ncalls</td>
</tr>
<tr>
<td align="center">filename:lineno(function)</td>
<td align="left">表示每个函数调用的具体信息</td>
</tr>
</tbody></table>
<p><strong><a href="https://blog.csdn.net/weixin_40304570/article/details/79459811" target="_blank" rel="noopener">cProfile更多用法参考</a></strong></p>
<ul>
<li>timeit</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算小段代码的执行时间的模块</span></span><br><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">print(timeit(<span class="string">'math.sqrt(2)'</span>, <span class="string">'import math'</span>, number=<span class="number">100000</span>))  <span class="comment"># 执行10万次2的开方</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0.023690600000000006</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>装饰器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将给需要计时的函数加上装饰器@time_count</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_count</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time.perf_counter()  <span class="comment"># 使用time.perf_counter() 能够提供给定平台上精度最高的计时器</span></span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        end = time.perf_counter()</span><br><span class="line">        print(<span class="string">'&#123;&#125;.&#123;&#125; : &#123;&#125;'</span>.format(func.__module__, func.__name__, end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@time_count</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_sleep</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"休眠两秒"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    time_sleep()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">休眠两秒</span></span><br><span class="line"><span class="string">__main__.time_sleep : 1.9995934</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>line_profile</li>
</ul>
<blockquote>
<p>用cProfile找到需要分析的函数，然后用line_profiler对函数逐行进行性能分析。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 line_profile</span></span><br><span class="line">pip install line_profiler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行kernprof 逐行分析被修饰函数的CPU开销</span></span><br><span class="line">kernprof.py -l -v test.py  <span class="comment"># -v 显示输出；-l 代表逐行分析而不是逐函数分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果中各参数的含义</span></span><br><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">Total Time：测试代码的总运行时间</span></span><br><span class="line"><span class="string">Hits：表示每行代码运行的次数</span></span><br><span class="line"><span class="string">Time：每行代码运行的总时间</span></span><br><span class="line"><span class="string">Per Hits：每行代码运行一次的时间</span></span><br><span class="line"><span class="string">% Time：每行代码运行时间的百分比</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>memory_profiler：分析内存使用情况</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装memory_profiler和依赖</span></span><br><span class="line">pip install psutil</span><br><span class="line">pip install memory_profiler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令分析内存使用情况</span></span><br><span class="line">python -m memory_profiler test.py</span><br></pre></td></tr></table></figure>

<h2 id="55-列表的顺序访问和随机访问"><a href="#55-列表的顺序访问和随机访问" class="headerlink" title="55. 列表的顺序访问和随机访问"></a>55. 列表的顺序访问和随机访问</h2><blockquote>
<p><strong>顺序访问：</strong>链表在内存中不是按顺序存储的，而是通过指针连在一起，为了访问某一元素，必须从链头还是顺着指针才能找到某一个元素。</p>
</blockquote>
<blockquote>
<p><strong>随机访问：</strong>数组在内存中是按顺序存储的，访问数组中的任意元素可以直接通过下标计算得到元素存放的位置，访问耗时与元素在数组中所处的位置无关。</p>
</blockquote>
<h2 id="56-随机函数"><a href="#56-随机函数" class="headerlink" title="56. 随机函数"></a>56. 随机函数</h2><blockquote>
<p><code>random.random()</code>用于生成一个0到1的随机浮点数: 0 &lt;= n &lt; 1.0 。</p>
</blockquote>
<blockquote>
<p><code>random.uniform(a, b)</code>，用于生成一个指定范围内的随机浮点数，两个参数其中一个是上限，一个是下限。如果a &gt; b，则生成的随机数n: a &lt;= n &lt;= b。如果 a &lt; b， 则 b &lt;= n &lt;= a 。</p>
</blockquote>
<blockquote>
<p><code>random.randint(a, b)</code>，用于生成一个指定范围内的整数。其中参数a是下限，参数b是上限，生成的随机数n: a &lt;= n &lt;= b。</p>
</blockquote>
<blockquote>
<p><code>random.randrange([start], stop[, step])</code>，从指定范围内，按指定基数递增的集合中获取一个随机数。如<code>random.randrange(10, 10, 2)</code>，结果相当于从<code>[10, 12, 14, 16, ..., 96, 98]</code>序列中获取一个随机数。</p>
</blockquote>
<blockquote>
<p><code>random.choice(sequence)</code>从序列中获取一个随机元素，参数sequence表示一个有序类型，list、tuple、字符串等。如<code>random.choice([&quot;Python&quot;, &quot;C++&quot;, &quot;java&quot;])</code>，随机在列表中选取一个元素。</p>
</blockquote>
<blockquote>
<p><code>random.shuffle(x[, random])</code>，用于将一个列表中的元素打乱。如<code>random.shuffle([&quot;Python&quot;, &quot;C++&quot;, &quot;java&quot;])</code>，每次结果是随机排序的。</p>
</blockquote>
<blockquote>
<p><code>random.sample(sequence, k)</code>，从指定序列中随机获取指定长度的片断，sample函数不会修改原有序列。如<code>random.sample([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2)</code>，结果是从列表10个数字中随机选两个元素。</p>
</blockquote>
<h2 id="57-Python中单下划线和双下划线"><a href="#57-Python中单下划线和双下划线" class="headerlink" title="57. Python中单下划线和双下划线"></a>57. Python中单下划线和双下划线</h2><ul>
<li>单下划线开头</li>
</ul>
<blockquote>
<p>一种约定，一般来说，_object被看作“私有的”，在模块或类外不可以使用，不能用from module import *导入，当变量是私有的时候，用_object来表示变量是很好的习惯。</p>
</blockquote>
<ul>
<li>双下划线开头</li>
</ul>
<blockquote>
<p>双下划线开头，__object表示私有成员，只有类对象自己能访问，连子类对象也不能访问到这个数据。</p>
</blockquote>
<p><strong>python中的私有不是真正意义上的private，可以通过<code>对象._类名__object</code>机制访问private.</strong></p>
<ul>
<li>双下划线开头和结尾</li>
</ul>
<blockquote>
<p>“<strong>object</strong>“指的是python中的一些特殊方法，前后双下划线是专用标识，它们是python的魔法函数，编程是不要用这种方式命名自己的变量和函数。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>__str__</code></td>
<td align="left">将对象转换成字符串时会执行</td>
</tr>
<tr>
<td align="center"><code>__init__</code></td>
<td align="left">初始化方法，为对象变量赋值</td>
</tr>
<tr>
<td align="center"><code>__new__</code></td>
<td align="left">构造方法，创建一个对象</td>
</tr>
<tr>
<td align="center"><code>__call__</code></td>
<td align="left">在对象后面加括号会执行该方法</td>
</tr>
<tr>
<td align="center"><code>__getattr__</code></td>
<td align="left">当使用对象.属性时，若属性存在会调用该方法</td>
</tr>
<tr>
<td align="center"><code>__setattr__</code></td>
<td align="left">当使用对象.属性 = value时，会调用该方法</td>
</tr>
<tr>
<td align="center"><code>__iter__</code></td>
<td align="left">类内部定义了该方法，对象就变成了可迭代对象</td>
</tr>
<tr>
<td align="center"><code>__add__</code></td>
<td align="left">当两个对象使用+号时，会调用该方法</td>
</tr>
<tr>
<td align="center"><code>__enter__</code> 和 <code>__exit__</code></td>
<td align="left">上下文管理</td>
</tr>
</tbody></table>
<h2 id="58-Python的作用域以及Python搜索变量的顺序"><a href="#58-Python的作用域以及Python搜索变量的顺序" class="headerlink" title="58. Python的作用域以及Python搜索变量的顺序"></a>58. Python的作用域以及Python搜索变量的顺序</h2><blockquote>
<p>Python作用域简单说就是一个变量的命名空间。代码中变量被赋值的位置，就决定了哪些范围的对象可以访问这个变量，这个范围就是变量的作用域。<br>在Python中，只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域。<br>Python的变量名解析机制也称为 LEGB 法则：本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）</p>
</blockquote>
<h2 id="59-编码与解码"><a href="#59-编码与解码" class="headerlink" title="59. 编码与解码"></a>59. 编码与解码</h2><ul>
<li>基本概念：</li>
</ul>
<blockquote>
<p>比特 / bit：计算机中最小的数据单位，是单个的二进制数值 0 或 1</p>
</blockquote>
<blockquote>
<p>字节 / byte：计算机存储数据的单元，1 个字节由 8 个比特组成</p>
</blockquote>
<blockquote>
<p>字符：人类能够识别的符号</p>
</blockquote>
<blockquote>
<p>编码：将人类可识别的字符转换为机器可识别的字节码 / 字节序列</p>
</blockquote>
<blockquote>
<p>解码：将机器可识别的字节码 / 字节序列转换为人类可识别的字符</p>
</blockquote>
<ul>
<li>编码格式</li>
</ul>
<blockquote>
<p>Python2 的默认编码是ASCII，不能识别中文字符，需要显示指定字符编码。</p>
</blockquote>
<blockquote>
<p>Python3 的默认编码是Unicode，可以识别中文。</p>
</blockquote>
<blockquote>
<p>计算机内存的数据，统一使用Unicode编码；数据传输或保存在硬盘上，是哟还能UTF-8编码。</p>
</blockquote>
<ul>
<li><p>编码和解码</p>
<ul>
<li>编码(encode)：将Unicode字符串转换为特定编码格式对应的字节码的过程。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">"学习python"</span></span><br><span class="line">print(s.encode())  <span class="comment"># encode()函数里参数默认为utf-8</span></span><br><span class="line">print(s.encode(<span class="string">'gbk'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">b'\xe5\xad\xa6\xe4\xb9\xa0python'</span></span><br><span class="line"><span class="string">b'\xd1\xa7\xcf\xb0python'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解码(decode)：将特定编码格式的字节码转换为对应的Unicode字符串的过程。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encode和decode的编码格式必须一致，如gbk编码，必须用gbk解码</span></span><br><span class="line">s1 = <span class="string">b'\xe5\xad\xa6\xe4\xb9\xa0python'</span></span><br><span class="line">s2 = <span class="string">b'\xd1\xa7\xcf\xb0python'</span></span><br><span class="line">print(s1.decode())  <span class="comment"># 用默认的utf-8解码</span></span><br><span class="line">print(s2.decode(<span class="string">'gbk'</span>))  <span class="comment"># 用gbk解码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">学习python</span></span><br><span class="line"><span class="string">学习python</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编码表和适用性</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">编码</th>
<th align="left">适用性</th>
<th align="center">大小</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ASCII码</td>
<td align="left">数字、英文字母、特殊字符</td>
<td align="center">8bit = 1byte</td>
<td align="left">特点编号从0到127，占用空间小</td>
</tr>
<tr>
<td align="center">GB2312码/GBK码</td>
<td align="left">支持中文</td>
<td align="center">16bit = 2byte</td>
<td align="left">GBK码是GB2312码的升级，也支持日文、韩文等</td>
</tr>
<tr>
<td align="center">Unicode码</td>
<td align="left">支持国际语言</td>
<td align="center">32bit = 4byte</td>
<td align="left">占用空间大，适用性强，在ASCII码前面补8个就成了Unicode码</td>
</tr>
<tr>
<td align="center">UTF-8</td>
<td align="left">支持国际语言</td>
<td align="center">英文：8bit = 1byte  中文：24bit =  3byte  欧洲文字：16bit = 2byte</td>
<td align="left">是Unicode的升级，是可变长度的Unicode，两者可以非常容易地互相转换，占用空间小</td>
</tr>
</tbody></table>
<h2 id="60-字符串格式化"><a href="#60-字符串格式化" class="headerlink" title="60. 字符串格式化"></a>60. 字符串格式化</h2><ul>
<li>%格式化: C 语言风格的 sprintf 形式, 用%占位</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># %o 八进制输出</span></span><br><span class="line">print(<span class="string">"八进制：%o"</span> % <span class="number">222</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  %d 十进制整数输出</span></span><br><span class="line">print(<span class="string">"整数：%d, %d, %d"</span> % (<span class="number">1</span>, <span class="number">22.33</span>, <span class="number">0.25</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># %x 十六进制输出</span></span><br><span class="line">print(<span class="string">"十六进制：%x"</span> % <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浮点数保留两位小数</span></span><br><span class="line">print(<span class="string">"浮点数保留两位小数：%.2f"</span> % <span class="number">3.1415926</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 万能格式 %r，把任何类型(str、int、float、list、tuple、set、dict)数据转化为字符串类型</span></span><br><span class="line">print(<span class="string">"%r, %r, %r, %r, %r, %r, %r"</span> % (<span class="string">"abc"</span>, <span class="number">25</span>, <span class="number">3.1415926</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment"># %s 控制输出字符串的长度</span></span><br><span class="line">print(<span class="string">"%.3s"</span> % (<span class="string">"abcdefg"</span>))</span><br><span class="line">print(<span class="string">"%.*s"</span> % (<span class="number">4</span>, <span class="string">"abcdefg"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">八进制：336</span></span><br><span class="line"><span class="string">整数：1, 22, 0</span></span><br><span class="line"><span class="string">十六进制：c</span></span><br><span class="line"><span class="string">浮点数保留两位小数：3.14</span></span><br><span class="line"><span class="string">'abc', 25, 3.1415926, [1, 2, 3], (1, 2, 3), &#123;1, 2, 3&#125;, &#123;'a': 1, 'b': 2, 'c': 3&#125;</span></span><br><span class="line"><span class="string">abc</span></span><br><span class="line"><span class="string">abcd</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无法同时传递一个变量和元组</span></span><br><span class="line"><span class="string">'This is %s'</span> % name</span><br><span class="line"><span class="comment"># 当name=(1, 2, 3)时</span></span><br><span class="line"><span class="string">'This is %s'</span> % (name,)  <span class="comment"># 提供一个单元素的元组，而不是一个参数，逗号必须加</span></span><br></pre></td></tr></table></figure>

<ul>
<li>str.format()格式化：函数把字符串单层一个模版，通过传入的参数进行格式化，用{}占位</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配位置&#123;&#125;</span></span><br><span class="line">print(<span class="string">'This is &#123;&#125;&#123;&#125;'</span>.format(<span class="string">"Python"</span>, <span class="string">"!"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配位置带编号&#123;i&#125;，i从0按位置递增，位置可以多次使用</span></span><br><span class="line">print(<span class="string">'This is &#123;0&#125;&#123;1&#125; &#123;0&#125; is esay&#123;1&#125;'</span>.format(<span class="string">"Python"</span>, <span class="string">"!"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字传参</span></span><br><span class="line">print(<span class="string">'This is &#123;name&#125;&#123;symbol&#125;'</span>.format(name=<span class="string">"Python"</span>, symbol=<span class="string">"!"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典传参</span></span><br><span class="line">print(<span class="string">'This is &#123;name&#125;&#123;symbol&#125;'</span>.format(**&#123;<span class="string">"name"</span>: <span class="string">"Python"</span>, <span class="string">"symbol"</span>: <span class="string">"!"</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数格式化</span></span><br><span class="line">print(<span class="string">"整数：&#123;:d&#125;"</span>.format(<span class="number">123</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浮点数格式化</span></span><br><span class="line">print(<span class="string">"浮点数保留两位小数：&#123;:.2f&#125;"</span>.format(<span class="number">3.1415926</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串格式化</span></span><br><span class="line">print(<span class="string">"字符串：&#123;:s&#125;"</span>.format(<span class="string">"abcdefg"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 八进制格式化</span></span><br><span class="line">print(<span class="string">"八进制：&#123;:o&#125;"</span>.format(<span class="number">222</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 十六进制格式化</span></span><br><span class="line">print(<span class="string">"十六进制：&#123;:x&#125;"</span>.format(<span class="number">12</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合编号的数值格式化</span></span><br><span class="line">print(<span class="string">"编号组合数值格式化：&#123;0:d&#125;, &#123;1:s&#125;"</span>.format(<span class="number">123</span>, <span class="string">"abcdefg"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字结合数值格式化</span></span><br><span class="line">print(<span class="string">"关键字结合数值格式化：&#123;num:d&#125;, &#123;string:s&#125;"</span>.format(num = <span class="number">123</span>, string = <span class="string">"abcdefg"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 百分数精度</span></span><br><span class="line">print(<span class="string">"百分数：&#123;:.2%&#125;"</span>.format(<span class="number">3</span>/<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 金钱的千分隔符</span></span><br><span class="line">print(<span class="string">"金钱分隔符：&#123;:,&#125;"</span>.format(<span class="number">123456789</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出大括号</span></span><br><span class="line">print(<span class="string">"输出大括号：&#123;&#125;为&#123;&#123;1, 2, 3&#125;&#125;"</span>.format(<span class="string">"集合"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">This is Python!</span></span><br><span class="line"><span class="string">This is Python! Python is esay!</span></span><br><span class="line"><span class="string">This is Python!</span></span><br><span class="line"><span class="string">This is Python!</span></span><br><span class="line"><span class="string">整数：123</span></span><br><span class="line"><span class="string">浮点数保留两位小数：3.14</span></span><br><span class="line"><span class="string">字符串：abcdefg</span></span><br><span class="line"><span class="string">八进制：336</span></span><br><span class="line"><span class="string">十六进制：c</span></span><br><span class="line"><span class="string">编号组合数值格式化：123, abcdefg</span></span><br><span class="line"><span class="string">关键字结合数值格式化：123, abcdefg</span></span><br><span class="line"><span class="string">百分数：42.86%</span></span><br><span class="line"><span class="string">金钱分隔符：123,456,789</span></span><br><span class="line"><span class="string">输出大括号：集合为&#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>f-string格式化：Python 3.6 新加入的方法，风格简洁、易读、速度快</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串格式化</span></span><br><span class="line">name, age = <span class="string">"lucy"</span>, <span class="number">20</span></span><br><span class="line">print(<span class="string">f"she is <span class="subst">&#123;name&#125;</span>, <span class="subst">&#123;age&#125;</span> years old."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典格式化</span></span><br><span class="line">info = &#123;<span class="string">'name'</span>: <span class="string">"lucy"</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line">print(<span class="string">f"she is <span class="subst">&#123;info[<span class="string">'name'</span>]&#125;</span>, <span class="subst">&#123;info[<span class="string">'age'</span>]&#125;</span> years old."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浮点数精度限制</span></span><br><span class="line">print(<span class="string">f"she is <span class="subst">&#123;name&#125;</span>, <span class="subst">&#123;age: <span class="number">.2</span>f&#125;</span> years old."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定宽度，为了多行输出时整齐（:&lt; 8左对齐，:&gt; 8右对齐）</span></span><br><span class="line">print(<span class="string">f"she is <span class="subst">&#123;name:&lt;<span class="number">10</span>&#125;</span>, <span class="subst">&#123;age:&lt;<span class="number">3</span>&#125;</span> years old."</span>)</span><br><span class="line">name1, age1 = <span class="string">"Liming"</span>, <span class="number">3</span></span><br><span class="line">print(<span class="string">f"she is <span class="subst">&#123;name1:&lt;<span class="number">10</span>&#125;</span>, <span class="subst">&#123;age1:&lt;<span class="number">3</span>&#125;</span> years old."</span>)</span><br><span class="line">name2, age2 = <span class="string">"Lee"</span>, <span class="number">101</span></span><br><span class="line">print(<span class="string">f"she is <span class="subst">&#123;name2:&lt;<span class="number">10</span>&#125;</span>, <span class="subst">&#123;age2:&lt;<span class="number">3</span>&#125;</span> years old."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数格式化</span></span><br><span class="line">print(<span class="string">f"整数：<span class="subst">&#123;<span class="number">123</span>:d&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浮点数格式化</span></span><br><span class="line">print(<span class="string">f"浮点数保留两位小数：<span class="subst">&#123;<span class="number">3.1415926</span>:<span class="number">.2</span>f&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串格式化</span></span><br><span class="line">print(<span class="string">f"字符串：<span class="subst">&#123;<span class="string">'abcdefg'</span>:s&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 八进制格式化</span></span><br><span class="line">print(<span class="string">f"八进制：<span class="subst">&#123;<span class="number">222</span>:o&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 十六进制格式化</span></span><br><span class="line">print(<span class="string">f"十六进制：<span class="subst">&#123;<span class="number">12</span>:x&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 百分数精度</span></span><br><span class="line">print(<span class="string">f"百分数：<span class="subst">&#123;(<span class="number">3</span>/<span class="number">7</span>):<span class="number">.2</span>%&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 金钱的千分隔符</span></span><br><span class="line">print(<span class="string">f"金钱分隔符：<span class="subst">&#123;<span class="number">123456789</span>:,&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">she is lucy, 20 years old.</span></span><br><span class="line"><span class="string">she is lucy, 20 years old.</span></span><br><span class="line"><span class="string">she is lucy,  20.00 years old.</span></span><br><span class="line"><span class="string">she is lucy      , 20  years old.</span></span><br><span class="line"><span class="string">she is Liming    , 3   years old.</span></span><br><span class="line"><span class="string">she is Lee       , 101 years old.</span></span><br><span class="line"><span class="string">整数：123</span></span><br><span class="line"><span class="string">浮点数保留两位小数：3.14</span></span><br><span class="line"><span class="string">字符串：abcdefg</span></span><br><span class="line"><span class="string">八进制：336</span></span><br><span class="line"><span class="string">十六进制：c</span></span><br><span class="line"><span class="string">百分数：42.86%</span></span><br><span class="line"><span class="string">金钱分隔符：123,456,789</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>相对于%，format()的优点：</p>
</blockquote>
<ul>
<li>(1).在%方法中%s只能替代字符串类型，而.format()方法不用考虑数据类型问题；</li>
<li>(2).单个参数可以多次输出，参数顺序可以不相同；</li>
<li>(3).填充方式十分灵活，对齐方式十分强大；</li>
<li>(4).可以使用列表、元组格式化，可以使用字典格式化(传入用**解构)；</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 几种格式化方法性能比较，性能最好的是f-string</span></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">()</span>:</span></span><br><span class="line">    status = <span class="number">200</span></span><br><span class="line">    body = <span class="string">'hello world'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Status: '</span> + str(status) + <span class="string">'\r\n'</span> + body + <span class="string">'\r\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># % 格式化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">precent_style</span><span class="params">()</span>:</span></span><br><span class="line">    status = <span class="number">200</span></span><br><span class="line">    body = <span class="string">'hello world'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Status: %s\r\n%s\r\n'</span> % (status, body)</span><br><span class="line"></span><br><span class="line"><span class="comment"># str.format()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_style1</span><span class="params">()</span>:</span></span><br><span class="line">    status = <span class="number">200</span></span><br><span class="line">    body = <span class="string">'hello world'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Status: &#123;&#125;\r\n&#123;&#125;\r\n'</span>.format(status, body)</span><br><span class="line"></span><br><span class="line"><span class="comment"># str.format(**dict)字典形式传参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_style2</span><span class="params">()</span>:</span></span><br><span class="line">    status = <span class="number">200</span></span><br><span class="line">    body = <span class="string">'hello world'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Status: &#123;status&#125;\r\n&#123;body&#125;\r\n'</span>.format(status=status, body=body)</span><br><span class="line"></span><br><span class="line"><span class="comment"># f-string格式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f_string</span><span class="params">()</span>:</span></span><br><span class="line">    status = <span class="number">200</span></span><br><span class="line">    body = <span class="string">'hello world'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'Status: <span class="subst">&#123;status&#125;</span>\r\n<span class="subst">&#123;body&#125;</span>\r\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算时间</span></span><br><span class="line">print(<span class="string">'add: '</span>+ str(min(timeit.repeat(<span class="keyword">lambda</span>: add()))))</span><br><span class="line">print(<span class="string">'precent_style: '</span>+ str(min(timeit.repeat(<span class="keyword">lambda</span>: precent_style()))))</span><br><span class="line">print(<span class="string">'format_style1: '</span>+ str(min(timeit.repeat(<span class="keyword">lambda</span>: format_style1()))))</span><br><span class="line">print(<span class="string">'format_style2: '</span>+ str(min(timeit.repeat(<span class="keyword">lambda</span>: format_style2()))))</span><br><span class="line">print(<span class="string">'f_string: '</span>+ str(min(timeit.repeat(<span class="keyword">lambda</span>: f_string()))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">add: 1.0201557999999995</span></span><br><span class="line"><span class="string">precent_style: 0.7589769999999998</span></span><br><span class="line"><span class="string">format_style1: 1.2661715999999998</span></span><br><span class="line"><span class="string">format_style2: 1.2782307000000017</span></span><br><span class="line"><span class="string">f_string: 0.5236783999999979</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="61-增量赋值"><a href="#61-增量赋值" class="headerlink" title="61. 增量赋值"></a>61. 增量赋值</h2><ul>
<li><p><code>+=</code>操作首先会尝试调用对象的<code>__iadd__</code>方法，如果没有该方法，那么尝试调用<code>__add__</code>方法，所以 <code>+=</code> 与 <code>+</code>的区别实质是<code>__iadd__</code>和<code>__add__</code>的区别。</p>
<ul>
<li><code>__add__</code>方法接收两个参数，返回它们的和，两个参数的值均不会改变。</li>
<li><code>__iadd__</code>方法同样接收两个参数，但它是属于in-place操作，即会改变第一个参数的值，所以<code>__iadd__</code>方法的对象只能是可变对象，如list对象提供了<code>__iadd__</code>方法，而int对象是没有。</li>
</ul>
</li>
<li><p><code>*=</code>操作首先会尝试调用对象的<code>__imul__</code>方法，如果没有该方法，那么尝试调用<code>__mul__</code>方法，所以 <code>*=</code> 与 <code>*</code>的区别实质是<code>__imul__</code>和<code>__mul__</code>的区别。</p>
</li>
</ul>
<blockquote>
<p>对不可变序列进行重复拼接操作，效率会很低，因为每次都要新建一个序列，然后把原序列中的元素复制到新的序列里面，然后再追加新的元素。</p>
</blockquote>
<blockquote>
<p>不要把可变对象放在元组里。</p>
</blockquote>
<blockquote>
<p>增量赋值不是一个原子操作，出现异常时，仍然进行了操作。</p>
</blockquote>
<h2 id="62-exec对字符串执行和eval对字符串求值"><a href="#62-exec对字符串执行和eval对字符串求值" class="headerlink" title="62. exec对字符串执行和eval对字符串求值"></a>62. exec对字符串执行和eval对字符串求值</h2><ul>
<li>exec</li>
</ul>
<blockquote>
<p>exec函数主要用于动态地执行代码字符串，exec 返回值永远为 None。exec()不仅可以执行python代码，还可以共享上下文，但需要注意尽量不要在全局作用域下用exec()函数执行python代码，以免发生命名空间冲突。</p>
</blockquote>
<blockquote>
<p>为了解决这个问题，可以在执行之前创建一个空字典<code>scope = {}</code>，作为exec()函数的第二个参数，这样通过exec执行python代码时创建的变量就会存储在字典scope中。</p>
</blockquote>
<blockquote>
<p>如果exec()函数执行的python代码中含有参数，且要传参，则可以在exec()中 以字典形式进行传参，这时exec就有了第三个参数args。当说要执行的代码是多行时，可以用””” “””引起来.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;</span><br><span class="line">scope = &#123;&#125;</span><br><span class="line">print(exec(<span class="string">'print(x + y)'</span>, scope, args))</span><br><span class="line">print(scope.keys())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">dict_keys(['__builtins__'])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>eval</li>
</ul>
<blockquote>
<p>eval()函数来执行一个字符串表达式，实现一个可以计算表达式的计算器，并返回表达式的值。</p>
</blockquote>
<blockquote>
<p>eval()函数的语法：<code>eval(expression[, globals[, locals]])</code>，expression是表达式；globals是变量作用域，全局命名空间，如果被提供，这必须是一个字典对象；locals是变量作用域，局部变量命名空间，如果被提供，可以是任何映射对象。</p>
</blockquote>
<blockquote>
<p>python中查找变量的顺序是：局部 –&gt; 全局 –&gt; 内置</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>  <span class="comment"># 当前变量</span></span><br><span class="line">b = <span class="number">2</span>  <span class="comment"># 当前变量</span></span><br><span class="line">c = <span class="number">3</span>  <span class="comment"># 当前变量</span></span><br><span class="line">globals = &#123;<span class="string">'a'</span>: <span class="number">10</span>, <span class="string">'b'</span>: <span class="number">20</span>&#125;  <span class="comment"># 全局变量</span></span><br><span class="line">locals = &#123;<span class="string">'b'</span>: <span class="number">200</span>, <span class="string">'c'</span>: <span class="number">300</span>&#125;  <span class="comment"># 局部变量</span></span><br><span class="line"></span><br><span class="line">print(eval(<span class="string">'a + b + c'</span>))  <span class="comment"># 后两个参数省略，默认在当前作用域下，即a+b+c = 1+2+3 = 6</span></span><br><span class="line">print(eval(<span class="string">'a + b + c'</span>, globals, locals))  <span class="comment"># 指定globals、locals参数，优先局部，再全局，最后当前作用域，即a+b+c = 10+200+300 = 510</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">510</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="63-raise语句的作用"><a href="#63-raise语句的作用" class="headerlink" title="63. raise语句的作用"></a>63. raise语句的作用</h2><blockquote>
<p>当程序出错时，python会自动触发异常，也可以通过raise语句触发异常；一旦执行了raise语句，之后的语句不再执行；但如果加入了<code>try...excepet...finally</code>语句，except里的语句会被执行，finally一样也会被执行。</p>
</blockquote>
<blockquote>
<p>raise语法格式：<code>raise [Exception [, args [, traceback]]]</code>，参数Exception 是异常的类型数标准异常中任一种（如NameError），args 是自已提供的异常参数；参数traceback可选，是跟踪异常对象。</p>
</blockquote>
<blockquote>
<p>raise 语句有如下三种常用的用法：</p>
</blockquote>
<ul>
<li>单独<code>raise</code>，不加其他参数。在except语句中，引发当前上下文中捕获异常，或默认引发RuntimeError。通俗理解就是，捕捉到了异常，但是又想重新引发它，即传递异常不进行处理，可以调用不带参数的raise。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在except语句中使用raise</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = <span class="string">'a'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s.isdigit():</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"s must be a number！"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"引发异常："</span>, e)</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "C:/../../../test.py", line 13, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    raise ValueError("s must be a number！")</span></span><br><span class="line"><span class="string">ValueError: s must be a number！</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在没有引发过异常的程序使用raise，引发的是默认的RuntimeError</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = <span class="string">'a'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s.isdigit():</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> RuntimeError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"引发异常："</span>, e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">引发异常： No active exception to reraise</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>raise 异常类名称</code>：raise后面带一个异常类名称，表示引发执行类型的异常。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">'s是空对象'</span>)</span><br><span class="line">        <span class="keyword">raise</span> ValueError</span><br><span class="line">    print(len(s))</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    print(<span class="string">'空对象没有长度'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">s是空对象</span></span><br><span class="line"><span class="string">空对象没有长度</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>raise 异常类名称(&quot;描述信息&quot;)</code>：在引发指定类型的异常，同时附带异常的描述信息。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(number)</span>:</span></span><br><span class="line">    print(number)</span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"Invalid number!"</span>)</span><br><span class="line">        <span class="comment"># 触发异常后，后面的代码不会执行</span></span><br><span class="line">    print(number + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        func(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"触发了异常！"</span>, e)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"未触发异常！"</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">"程序执行完毕！"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">触发了异常！ Invalid number!</span></span><br><span class="line"><span class="string">程序执行完毕！</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="64-yield语句的作用"><a href="#64-yield语句的作用" class="headerlink" title="64. yield语句的作用"></a>64. yield语句的作用</h2><p><strong><a href="https://blog.csdn.net/qiuqiuit/article/details/86762747" target="_blank" rel="noopener">python之yield、yield from</a></strong></p>
<blockquote>
<p>该关键字用于函数中会把函数包装为生成器(generator)，调用生成器函数时，会返回一个生成器对象，生成器函数是生成器工厂。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> func():</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">g = func()</span><br><span class="line">print(next(g))</span><br><span class="line">print(next(g))</span><br><span class="line">print(next(g))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>简单理解，yield的功效为暂停和继续。</p>
</blockquote>
<blockquote>
<p>在一个函数中，程序执行到yield语句的时候，程序暂停，返回yield后面表达式的值；在下一次调用的时候，yield语句暂停的地方继续执行，如此循环，直到函数执行完。</p>
</blockquote>
<blockquote>
<p>next函数和send函数很相似，都能获得生成器的下一个yield后面表达式的值，不同的是send函数包含next()方法，不仅可以向生成器传参，然后执行next()，如果下个元素不存在，迭代越界，生成器对象会抛出StopIteration异常。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"starting..."</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">        print(<span class="string">"res:"</span>, res)</span><br><span class="line"></span><br><span class="line">f = foo()</span><br><span class="line">print(next(f))</span><br><span class="line">print(<span class="string">"*"</span>*<span class="number">20</span>)</span><br><span class="line">print(f.send(<span class="number">7</span>))  <span class="comment"># 这里调用send()函数给生成器给res赋值7，然后继续调用next(f)，返回4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">starting...</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">********************</span></span><br><span class="line"><span class="string">res: 7</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>yield from x 表达式替代for循环，对x对象所做的第一件事是调用iter(x)，从中获取迭代器，因此x可以是任何可迭代对象。任何可迭代对象都应该有一个<code>__iter__</code>方法（特殊情况时，只实现了<code>__getitem__</code>，未实现<code>__iter__</code>，对象也可以迭代），<code>__iter__</code>会返回一个迭代器。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_color</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"执行generate_color():"</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"红色"</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"橙色"</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"紫色"</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"黄色"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colors</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"执行__init__():"</span>)</span><br><span class="line">        self.gen_colors = generate_color()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> self.gen_colors</span><br><span class="line"></span><br><span class="line">colors = Colors()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> colors:</span><br><span class="line">    print(color)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行__init__():</span></span><br><span class="line"><span class="string">执行generate_color():</span></span><br><span class="line"><span class="string">红色</span></span><br><span class="line"><span class="string">橙色</span></span><br><span class="line"><span class="string">紫色</span></span><br><span class="line"><span class="string">黄色</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="65-协程与生成器"><a href="#65-协程与生成器" class="headerlink" title="65. 协程与生成器"></a>65. 协程与生成器</h2><p><strong>具体一些例子和详细原理可以参考《流畅的Python》 第16章 协程</strong></p>
<blockquote>
<p>从句法上看，协程与生成器类似，都是定义体中包含 yield 关键字的函数。可是，在协 程中，yield 通常出现在表达式的右边（例如，datum = yield），可以产出值，也可 以不产出——如果 yield 关键字后面没有表达式，那么生成器产出 None。协程可能会从 调用方接收数据，不过调用方把数据提供给协程使用的是 .send(datum) 方法，而不是 next(…) 函数。通常，调用方会把值推送给协程，通过.send()双向交换数据的生成器就是协程。</p>
</blockquote>
<blockquote>
<p>yield 关键字甚至还可以不接收或传出数据。不管数据如何流动，yield 都是一种流程控 制工具，使用它可以实现协作式多任务：协程可以把控制器让步给中心调度程序，从而激活其他的协程。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 产生两个值的协程</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">simple_coro2</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; Started: a ='</span>, a)</span><br><span class="line"><span class="meta">... </span>    b = <span class="keyword">yield</span> a</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; Received: b ='</span>, b)</span><br><span class="line"><span class="meta">... </span>    c = <span class="keyword">yield</span> a + b</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; Received: c ='</span>, c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro2 = simple_coro2(<span class="number">14</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro2)  <span class="comment"># (1)</span></span><br><span class="line"><span class="string">'GEN_CREATED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(my_coro2)  <span class="comment"># (2)</span></span><br><span class="line">-&gt; Started: a = 14</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro2)  <span class="comment"># (3)</span></span><br><span class="line"><span class="string">'GEN_SUSPENDED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(<span class="number">28</span>)  <span class="comment"># (4)</span></span><br><span class="line">-&gt; Received: b = 28</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(<span class="number">99</span>)  <span class="comment"># (5)</span></span><br><span class="line">-&gt; Received: c = 99</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro2)  <span class="comment"># (6)</span></span><br><span class="line"><span class="string">'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>(1) inspect.getgeneratorstate函数指明，处于GEN_CREATED 状态（即协程未启动）。</p>
</blockquote>
<blockquote>
<p>(2) 向前执行协程到以第一个yield表达式，打印 -&gt; Started: a = 14 消息，然后产出a的值，并且暂停，等待为b赋值。</p>
</blockquote>
<blockquote>
<p>(3) getgeneratorstate 函数指明，处于 GEN_SUSPENDED 状态（即协程在yield表达式处暂停）。</p>
</blockquote>
<blockquote>
<p>(4) 把数字28发给暂停的协程；就算yield表达式，得到28，然后把那个数按定给b。打印 -&gt; Received: b = 28 消息，产出 a + b 的值（42），然后协程暂停，等待为 c 赋值。</p>
</blockquote>
<blockquote>
<p>(5) 把数字 99 发给暂停的协程；计算 yield 表达式，得到 99，然后把那个数绑定给 c。打印 -&gt; Received: c = 99 消息，然后协程终止，导致生成器对象抛出StopIteration异常。</p>
</blockquote>
<blockquote>
<p>(6) getgeneratorstate 函数指明，处于 GEN_CLOSED 状态（即协程执行结束）。</p>
</blockquote>
<h2 id="66-python-decimal精确计算"><a href="#66-python-decimal精确计算" class="headerlink" title="66. python decimal精确计算"></a>66. python decimal精确计算</h2><p><strong><a href="https://blog.csdn.net/weixin_37989267/article/details/79473706" target="_blank" rel="noopener">python decimal精确计算</a></strong></p>
<ul>
<li>(1). Decimal接收int和string类型参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不能传入浮点数据，因为浮点数据就不准确</span></span><br><span class="line">a = Decimal(<span class="number">3.33</span>)*<span class="number">100</span></span><br><span class="line">b = Decimal(<span class="string">'3.33'</span>)*<span class="number">100</span></span><br><span class="line">c = Decimal(<span class="number">3</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Decimal('333.0000000000000071054273576')</span></span><br><span class="line"><span class="string">Decimal('333.00')</span></span><br><span class="line"><span class="string">Decimal('3')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>(2). 浮点数据转换为Decimal类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">Decimal.from_float(<span class="number">2.222</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Decimal('2.221999999999999975131004248396493494510650634765625')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>(3). 设定有效数字</li>
</ul>
<blockquote>
<p>特别注意，如果prec的长度比数字的长度小的话，扩充*100时就会出错</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留6个有效数字</span></span><br><span class="line">getcontext().prec = <span class="number">6</span></span><br><span class="line">Decimal(<span class="number">1</span>)/Decimal(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Decimal('0.142857')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>(4). 四舍五入，保留几位小数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留两位小数</span></span><br><span class="line">Decimal(<span class="string">'0.2335662'</span>).quantize(Decimal(<span class="string">'0.00'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Decimal('0.23')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>(5). Decimal转化为字符串类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留两位小数</span></span><br><span class="line">str(Decimal(<span class="string">'0.2335662'</span>).quantize(Decimal(<span class="string">'0.00'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">'0.23'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="67-模块和代码块"><a href="#67-模块和代码块" class="headerlink" title="67. 模块和代码块"></a>67. 模块和代码块</h2><blockquote>
<p>Python 提供了一个办法，把这些定义的方法和变量存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py，可以被别的程序引入，以使用该模块中的函数等功能。</p>
</blockquote>
<blockquote>
<p>代码块就是可作为可执行单元的一段Python程序文本；模块、函数体和类定义都是代码块。不仅如此，每一个交互脚本命令也是一个代码块；一个脚本文件也是一个代码块；一个命令行脚本也是一个代码块。</p>
</blockquote>
<h2 id="68-上下文管理器"><a href="#68-上下文管理器" class="headerlink" title="68. 上下文管理器"></a>68. 上下文管理器</h2><blockquote>
<p>使用上下文管理器最广泛的案例就是with语句，打开文件，对文件进行操作，然后关闭文件，如果在往文件里写数据的时候发生异常，它也会尝试去关闭文件。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># with语句，确保文件会被关闭</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'aaa.txt'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f</span><br><span class="line">    f.write(<span class="string">"sddsa"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">f = open(<span class="string">'aaa.txt'</span>, <span class="string">'wb'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f.write(<span class="string">'sddsa'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用<code>__enter__</code>和<code>__exit__</code>方法实现一个上下文管理类</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, file_name, method)</span>:</span></span><br><span class="line">        self.file_obj = open(file_name, method)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.file_obj</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        self.file_obj.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> File(<span class="string">'aaa.txt'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">"Hello"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行顺序</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">(1) with语句先暂存了File类的__exit__方法</span></span><br><span class="line"><span class="string">(2) 然后吊桶File类的__enter__方法</span></span><br><span class="line"><span class="string">(3) __enter__方法返回打开文件对象</span></span><br><span class="line"><span class="string">(4) 打开文件的对象被传给f</span></span><br><span class="line"><span class="string">(5) 使用write来写文件</span></span><br><span class="line"><span class="string">(6) 调用之前暂存的__exit__</span></span><br><span class="line"><span class="string">(7) __exit__关闭了文件</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>python有个contextlib模块，里面的contextmanager结合生成器可以实现上下文管理</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_file</span><span class="params">(name)</span>:</span></span><br><span class="line">    f = open(name, <span class="string">'w'</span>)</span><br><span class="line">    <span class="keyword">yield</span> f</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open_file(<span class="string">'aaa.txt'</span>) <span class="keyword">as</span> ff:</span><br><span class="line">    ff.write(<span class="string">"sssss"</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言-python</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构知识点总结归纳</title>
    <url>/2020/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>本文主要对数据结构基础知识进行梳理、回顾，解析原理，并通过实际例子深刻理解。</p>
</blockquote>
<a id="more"></a>

<div style='display: none'>

<!-- TOC -->

<ul>
<li><a href="#数据结构">数据结构</a><ul>
<li><a href="#1-字符串string">1. 字符串(String)</a></li>
<li><a href="#2-数组array">2. 数组(Array)</a></li>
<li><a href="#3-堆heap">3. 堆(Heap)</a></li>
<li><a href="#4-栈stack">4. 栈(Stack)</a></li>
<li><a href="#5-队列queue">5. 队列(Queue)</a></li>
<li><a href="#6-链表linked-list">6. 链表(Linked-List)</a></li>
<li><a href="#7-树tree">7. 树(Tree)</a></li>
<li><a href="#8-图graph">8. 图(Graph)</a></li>
<li><a href="#9-哈希表hash">9. 哈希表(Hash)</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

</div>

<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="1-字符串-String"><a href="#1-字符串-String" class="headerlink" title="1. 字符串(String)"></a>1. 字符串(String)</h2><h2 id="2-数组-Array"><a href="#2-数组-Array" class="headerlink" title="2. 数组(Array)"></a>2. 数组(Array)</h2><h2 id="3-堆-Heap"><a href="#3-堆-Heap" class="headerlink" title="3. 堆(Heap)"></a>3. 堆(Heap)</h2><h2 id="4-栈-Stack"><a href="#4-栈-Stack" class="headerlink" title="4. 栈(Stack)"></a>4. 栈(Stack)</h2><h2 id="5-队列-Queue"><a href="#5-队列-Queue" class="headerlink" title="5. 队列(Queue)"></a>5. 队列(Queue)</h2><h2 id="6-链表-Linked-List"><a href="#6-链表-Linked-List" class="headerlink" title="6. 链表(Linked-List)"></a>6. 链表(Linked-List)</h2><h2 id="7-树-Tree"><a href="#7-树-Tree" class="headerlink" title="7. 树(Tree)"></a>7. 树(Tree)</h2><h2 id="8-图-Graph"><a href="#8-图-Graph" class="headerlink" title="8. 图(Graph)"></a>8. 图(Graph)</h2><h2 id="9-哈希表-Hash"><a href="#9-哈希表-Hash" class="headerlink" title="9. 哈希表(Hash)"></a>9. 哈希表(Hash)</h2>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习知识点总结归纳</title>
    <url>/2020/05/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>本文主要对机器学习基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。</p>
</blockquote>
<a id="more"></a>

<div style='display: none'>

<!-- TOC -->

<ul>
<li><a href="#1-机器学习基础">1 机器学习基础</a><ul>
<li><a href="#11-机器学习概述">1.1 机器学习概述</a></li>
<li><a href="#12-监督学习">1.2 监督学习</a></li>
<li><a href="#13-非监督学习">1.3 非监督学习</a></li>
<li><a href="#14-增强学习">1.4 增强学习</a></li>
<li><a href="#15-深度学习">1.5 深度学习</a></li>
</ul>
</li>
<li><a href="#2-分类问题">2 分类问题</a><ul>
<li><a href="#21-knn">2.1 KNN</a></li>
<li><a href="#22-nb">2.2 NB</a></li>
<li><a href="#23-svm">2.3 SVM</a></li>
<li><a href="#24-adaboost">2.4 AdaBoost</a></li>
<li><a href="#25-dt">2.5 DT</a></li>
</ul>
</li>
<li><a href="#3-聚类分析">3 聚类分析</a><ul>
<li><a href="#31-k-means">3.1 K-means</a></li>
<li><a href="#32-dbscan">3.2 DBSCAN</a></li>
<li><a href="#33-lda">3.3 LDA</a></li>
</ul>
</li>
<li><a href="#4-预测分析">4 预测分析</a><ul>
<li><a href="#41-时间序列">4.1 时间序列</a></li>
<li><a href="#42-bp神经网络">4.2 BP神经网络</a></li>
</ul>
</li>
<li><a href="#5-关联分析">5 关联分析</a><ul>
<li><a href="#51-apriori">5.1 Apriori</a></li>
<li><a href="#52-fp-growth">5.2 FP-Growth</a></li>
</ul>
</li>
<li><a href="#6-回归分析">6 回归分析</a><ul>
<li><a href="#61-一元回归">6.1 一元回归</a></li>
<li><a href="#62-多元回归">6.2 多元回归</a></li>
<li><a href="#63-逻辑回归">6.3 逻辑回归</a></li>
</ul>
</li>
<li><a href="#7-集成学习">7 集成学习</a><ul>
<li><a href="#71-bagging">7.1 Bagging</a></li>
<li><a href="#72-随机森林">7.2. 随机森林</a></li>
<li><a href="#73-boosting">7.3 Boosting</a></li>
<li><a href="#74-adaboost">7.4 AdaBoost</a></li>
</ul>
</li>
<li><a href="#8-深度学习">8 深度学习</a><ul>
<li><a href="#81-有监督">8.1 有监督</a></li>
<li><a href="#82-无监督">8.2 无监督</a></li>
<li><a href="#83-tensorflow">8.3 TensorFlow</a></li>
<li><a href="#84-theano">8.4 Theano</a></li>
</ul>
</li>
<li><a href="#9-数据预处理">9 数据预处理</a><ul>
<li><a href="#91-数据清洗">9.1 数据清洗</a><ul>
<li><a href="#911-异常值处理">9.1.1 异常值处理</a></li>
<li><a href="#912-缺失值处理">9.1.2 缺失值处理</a></li>
<li><a href="#913-噪声处理">9.1.3 噪声处理</a></li>
<li><a href="#914-倾斜数据处理">9.1.4 倾斜数据处理</a></li>
</ul>
</li>
<li><a href="#92-数据集成">9.2 数据集成</a></li>
<li><a href="#93-数据变换">9.3 数据变换</a></li>
<li><a href="#94-数据归约">9.4 数据归约</a></li>
</ul>
</li>
<li><a href="#10-数据降维">10 数据降维</a><ul>
<li><a href="#101-主成份分析">10.1 主成份分析</a></li>
<li><a href="#102-奇异值分解">10.2 奇异值分解</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

</div>


<h1 id="1-机器学习基础"><a href="#1-机器学习基础" class="headerlink" title="1 机器学习基础"></a>1 机器学习基础</h1><h2 id="1-1-机器学习概述"><a href="#1-1-机器学习概述" class="headerlink" title="1.1 机器学习概述"></a>1.1 机器学习概述</h2><h2 id="1-2-监督学习"><a href="#1-2-监督学习" class="headerlink" title="1.2 监督学习"></a>1.2 监督学习</h2><h2 id="1-3-非监督学习"><a href="#1-3-非监督学习" class="headerlink" title="1.3 非监督学习"></a>1.3 非监督学习</h2><h2 id="1-4-增强学习"><a href="#1-4-增强学习" class="headerlink" title="1.4 增强学习"></a>1.4 增强学习</h2><h2 id="1-5-深度学习"><a href="#1-5-深度学习" class="headerlink" title="1.5 深度学习"></a>1.5 深度学习</h2><h1 id="2-分类问题"><a href="#2-分类问题" class="headerlink" title="2 分类问题"></a>2 分类问题</h1><h2 id="2-1-KNN"><a href="#2-1-KNN" class="headerlink" title="2.1 KNN"></a>2.1 KNN</h2><h2 id="2-2-NB"><a href="#2-2-NB" class="headerlink" title="2.2 NB"></a>2.2 NB</h2><h2 id="2-3-SVM"><a href="#2-3-SVM" class="headerlink" title="2.3 SVM"></a>2.3 SVM</h2><h2 id="2-4-AdaBoost"><a href="#2-4-AdaBoost" class="headerlink" title="2.4 AdaBoost"></a>2.4 AdaBoost</h2><h2 id="2-5-DT"><a href="#2-5-DT" class="headerlink" title="2.5 DT"></a>2.5 DT</h2><h1 id="3-聚类分析"><a href="#3-聚类分析" class="headerlink" title="3 聚类分析"></a>3 聚类分析</h1><h2 id="3-1-K-means"><a href="#3-1-K-means" class="headerlink" title="3.1 K-means"></a>3.1 K-means</h2><h2 id="3-2-DBSCAN"><a href="#3-2-DBSCAN" class="headerlink" title="3.2 DBSCAN"></a>3.2 DBSCAN</h2><h2 id="3-3-LDA"><a href="#3-3-LDA" class="headerlink" title="3.3 LDA"></a>3.3 LDA</h2><h1 id="4-预测分析"><a href="#4-预测分析" class="headerlink" title="4 预测分析"></a>4 预测分析</h1><h2 id="4-1-时间序列"><a href="#4-1-时间序列" class="headerlink" title="4.1 时间序列"></a>4.1 时间序列</h2><h2 id="4-2-BP神经网络"><a href="#4-2-BP神经网络" class="headerlink" title="4.2 BP神经网络"></a>4.2 BP神经网络</h2><h1 id="5-关联分析"><a href="#5-关联分析" class="headerlink" title="5 关联分析"></a>5 关联分析</h1><h2 id="5-1-Apriori"><a href="#5-1-Apriori" class="headerlink" title="5.1 Apriori"></a>5.1 Apriori</h2><h2 id="5-2-FP-Growth"><a href="#5-2-FP-Growth" class="headerlink" title="5.2 FP-Growth"></a>5.2 FP-Growth</h2><h1 id="6-回归分析"><a href="#6-回归分析" class="headerlink" title="6 回归分析"></a>6 回归分析</h1><h2 id="6-1-一元回归"><a href="#6-1-一元回归" class="headerlink" title="6.1 一元回归"></a>6.1 一元回归</h2><h2 id="6-2-多元回归"><a href="#6-2-多元回归" class="headerlink" title="6.2 多元回归"></a>6.2 多元回归</h2><h2 id="6-3-逻辑回归"><a href="#6-3-逻辑回归" class="headerlink" title="6.3 逻辑回归"></a>6.3 逻辑回归</h2><h1 id="7-集成学习"><a href="#7-集成学习" class="headerlink" title="7 集成学习"></a>7 集成学习</h1><h2 id="7-1-Bagging"><a href="#7-1-Bagging" class="headerlink" title="7.1 Bagging"></a>7.1 Bagging</h2><h2 id="7-2-随机森林"><a href="#7-2-随机森林" class="headerlink" title="7.2. 随机森林"></a>7.2. 随机森林</h2><h2 id="7-3-Boosting"><a href="#7-3-Boosting" class="headerlink" title="7.3 Boosting"></a>7.3 Boosting</h2><h2 id="7-4-AdaBoost"><a href="#7-4-AdaBoost" class="headerlink" title="7.4 AdaBoost"></a>7.4 AdaBoost</h2><h1 id="8-深度学习"><a href="#8-深度学习" class="headerlink" title="8 深度学习"></a>8 深度学习</h1><h2 id="8-1-有监督"><a href="#8-1-有监督" class="headerlink" title="8.1 有监督"></a>8.1 有监督</h2><h2 id="8-2-无监督"><a href="#8-2-无监督" class="headerlink" title="8.2 无监督"></a>8.2 无监督</h2><h2 id="8-3-TensorFlow"><a href="#8-3-TensorFlow" class="headerlink" title="8.3 TensorFlow"></a>8.3 TensorFlow</h2><h2 id="8-4-Theano"><a href="#8-4-Theano" class="headerlink" title="8.4 Theano"></a>8.4 Theano</h2><h1 id="9-数据预处理"><a href="#9-数据预处理" class="headerlink" title="9 数据预处理"></a>9 数据预处理</h1><h2 id="9-1-数据清洗"><a href="#9-1-数据清洗" class="headerlink" title="9.1 数据清洗"></a>9.1 数据清洗</h2><h3 id="9-1-1-异常值处理"><a href="#9-1-1-异常值处理" class="headerlink" title="9.1.1 异常值处理"></a>9.1.1 异常值处理</h3><h3 id="9-1-2-缺失值处理"><a href="#9-1-2-缺失值处理" class="headerlink" title="9.1.2 缺失值处理"></a>9.1.2 缺失值处理</h3><h3 id="9-1-3-噪声处理"><a href="#9-1-3-噪声处理" class="headerlink" title="9.1.3 噪声处理"></a>9.1.3 噪声处理</h3><h3 id="9-1-4-倾斜数据处理"><a href="#9-1-4-倾斜数据处理" class="headerlink" title="9.1.4 倾斜数据处理"></a>9.1.4 倾斜数据处理</h3><h2 id="9-2-数据集成"><a href="#9-2-数据集成" class="headerlink" title="9.2 数据集成"></a>9.2 数据集成</h2><h2 id="9-3-数据变换"><a href="#9-3-数据变换" class="headerlink" title="9.3 数据变换"></a>9.3 数据变换</h2><h2 id="9-4-数据归约"><a href="#9-4-数据归约" class="headerlink" title="9.4 数据归约"></a>9.4 数据归约</h2><h1 id="10-数据降维"><a href="#10-数据降维" class="headerlink" title="10 数据降维"></a>10 数据降维</h1><h2 id="10-1-主成份分析"><a href="#10-1-主成份分析" class="headerlink" title="10.1 主成份分析"></a>10.1 主成份分析</h2><h2 id="10-2-奇异值分解"><a href="#10-2-奇异值分解" class="headerlink" title="10.2 奇异值分解"></a>10.2 奇异值分解</h2>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>分类问题</tag>
        <tag>聚类分析</tag>
        <tag>预测分析</tag>
        <tag>回归分析</tag>
        <tag>关联分析</tag>
        <tag>集成学习</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法编程知识点总结归纳</title>
    <url>/2020/05/08/%E7%AE%97%E6%B3%95%E4%B8%8E%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>本文主要对算法编程基础知识进行梳理、回顾，以及一些常见的算法掌握。</p>
</blockquote>
<a id="more"></a>

<div style='display: none'>

<!-- TOC -->

<ul>
<li><a href="#算法编程">算法编程</a><ul>
<li><a href="#1-反转链表">1. 反转链表</a></li>
<li><a href="#2-dfs">2. DFS</a></li>
<li><a href="#3-bfs">3. BFS</a></li>
<li><a href="#4-冒泡排序">4. 冒泡排序</a></li>
<li><a href="#5-快排">5. 快排</a></li>
<li><a href="#6-堆排序">6. 堆排序</a></li>
<li><a href="#7-二叉树">7. 二叉树</a></li>
<li><a href="#8-二分查找">8. 二分查找</a></li>
<li><a href="#9-求最大树深">9. 求最大树深</a></li>
<li><a href="#10-动态规划问题">10. 动态规划问题</a></li>
<li><a href="#11-01背包问题">11. 01背包问题</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

</div>

<h1 id="算法编程"><a href="#算法编程" class="headerlink" title="算法编程"></a>算法编程</h1><h2 id="1-反转链表"><a href="#1-反转链表" class="headerlink" title="1. 反转链表"></a>1. 反转链表</h2><h2 id="2-DFS"><a href="#2-DFS" class="headerlink" title="2. DFS"></a>2. DFS</h2><h2 id="3-BFS"><a href="#3-BFS" class="headerlink" title="3. BFS"></a>3. BFS</h2><h2 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4. 冒泡排序"></a>4. 冒泡排序</h2><h2 id="5-快排"><a href="#5-快排" class="headerlink" title="5. 快排"></a>5. 快排</h2><h2 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h2><h2 id="7-二叉树"><a href="#7-二叉树" class="headerlink" title="7. 二叉树"></a>7. 二叉树</h2><h2 id="8-二分查找"><a href="#8-二分查找" class="headerlink" title="8. 二分查找"></a>8. 二分查找</h2><h2 id="9-求最大树深"><a href="#9-求最大树深" class="headerlink" title="9. 求最大树深"></a>9. 求最大树深</h2><h2 id="10-动态规划问题"><a href="#10-动态规划问题" class="headerlink" title="10. 动态规划问题"></a>10. 动态规划问题</h2><h2 id="11-01背包问题"><a href="#11-01背包问题" class="headerlink" title="11. 01背包问题"></a>11. 01背包问题</h2><h2 id="12-两个栈实现一个队列"><a href="#12-两个栈实现一个队列" class="headerlink" title="12. 两个栈实现一个队列"></a>12. 两个栈实现一个队列</h2><h2 id="13-二叉树的直径"><a href="#13-二叉树的直径" class="headerlink" title="13. 二叉树的直径"></a>13. 二叉树的直径</h2><h2 id="14-全排列"><a href="#14-全排列" class="headerlink" title="14. 全排列"></a>14. 全排列</h2><ul>
<li>itertools内置permutations方法实现</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            n = int(input().strip())</span><br><span class="line">            s = [str(i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">            res = list(permutations(s))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">                print(<span class="string">" "</span>.join(i))</span><br><span class="line">            print(len(res))</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    func()</span><br></pre></td></tr></table></figure>

<ul>
<li>递归实现</li>
</ul>
<p>具体详细的思路参考：</p>
<p><strong><a href="https://blog.csdn.net/weixin_39910711/article/details/100692318" target="_blank" rel="noopener">递归实现全排列（回溯思想）</a></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(s, begin, end)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    <span class="keyword">if</span> begin == end:</span><br><span class="line">        print(<span class="string">" "</span>.join(s))</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(begin, end):</span><br><span class="line">            s[i], s[begin] = s[begin], s[i]</span><br><span class="line">            permutations(s, begin + <span class="number">1</span>, end)</span><br><span class="line">            s[i], s[begin] = s[begin], s[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = [str(i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(int(input().strip()))]</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    permutations(s, <span class="number">0</span>, len(s))</span><br><span class="line">    print(count)</span><br></pre></td></tr></table></figure>

<ul>
<li>DFS实现</li>
</ul>
<p><strong><a href="https://blog.csdn.net/weixin_39910711/article/details/100692318" target="_blank" rel="noopener">深度优先搜索（DFS）实现全排列</a></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(s, position, visit, num)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> position == len(s):</span><br><span class="line">        print(<span class="string">" "</span>.join(num))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> visit[index] == <span class="literal">True</span>:</span><br><span class="line">                num[position] = s[index]</span><br><span class="line">                visit[index] = <span class="literal">False</span></span><br><span class="line">                permutations(s, position + <span class="number">1</span>, visit, num)</span><br><span class="line">                visit[index] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    n = int(input().strip())</span><br><span class="line">    s = [str(i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    visit = [<span class="literal">True</span>] * n</span><br><span class="line">    num = [<span class="string">""</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    permutations(s, <span class="number">0</span>, visit, num)</span><br></pre></td></tr></table></figure>

<h2 id="15-最大公约数"><a href="#15-最大公约数" class="headerlink" title="15. 最大公约数"></a>15. 最大公约数</h2><h2 id="16-最小公倍数"><a href="#16-最小公倍数" class="headerlink" title="16. 最小公倍数"></a>16. 最小公倍数</h2><p><strong><a href="https://blog.csdn.net/weixin_41980474/article/details/80139275" target="_blank" rel="noopener">最小公倍数</a></strong></p>
<h2 id="17-求素数"><a href="#17-求素数" class="headerlink" title="17. 求素数"></a>17. 求素数</h2><h2 id="18-求质数"><a href="#18-求质数" class="headerlink" title="18. 求质数"></a>18. 求质数</h2><h2 id="19-查并集"><a href="#19-查并集" class="headerlink" title="19. 查并集"></a>19. 查并集</h2><p><strong><a href="https://blog.csdn.net/guoziqing506/article/details/78752557" target="_blank" rel="noopener">并查集(Union-Find)算法详解</a></strong><br><strong><a href="https://blog.csdn.net/qq_41593380/article/details/81146850" target="_blank" rel="noopener">并查集详解</a></strong><br><strong><a href="https://blog.csdn.net/dm_vincent/article/details/7655764" target="_blank" rel="noopener">并查集(Union-Find)算法介绍</a></strong></p>
]]></content>
      <categories>
        <category>算法编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>网络知识点总结归纳</title>
    <url>/2020/05/08/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>本文主要对Web基础和前端框架知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。</p>
</blockquote>
<a id="more"></a>

<div style='display: none'>

<!-- TOC -->

<ul>
<li><a href="#web基础">Web基础</a><ul>
<li><a href="#1-常用的网络传输协议">1. 常用的网络传输协议</a></li>
<li><a href="#2-常见的状态码">2. 常见的状态码</a></li>
<li><a href="#3-三次握手">3. 三次握手</a></li>
<li><a href="#4-四次挥手">4. 四次挥手</a></li>
<li><a href="#5session和cookie的区别">5.session和cookie的区别</a></li>
<li><a href="#6-https的建立连接的过程">6. https的建立连接的过程</a></li>
<li><a href="#7-https的传输数据是否是对称加密">7. https的传输数据是否是对称加密</a></li>
<li><a href="#8-tcp拥堵控制">8. TCP拥堵控制</a></li>
<li><a href="#9-如何高效处理socket">9. 如何高效处理socket</a></li>
<li><a href="#10-http的组成">10. http的组成</a></li>
<li><a href="#11-http的头部keepalive的作用">11. http的头部，keepalive的作用</a></li>
<li><a href="#12-tcp建立连接的方式">12. tcp建立连接的方式</a></li>
<li><a href="#13-本机的socket需要经过协议栈解包么">13. 本机的socket需要经过协议栈解包么</a></li>
<li><a href="#14-socket编程">14. socket编程</a></li>
<li><a href="#15-urllib和urllib2">15. urllib和urllib2</a></li>
<li><a href="#16-xsrf和xss">16. XSRF和XSS</a></li>
<li><a href="#17-post和get">17. POST和GET</a></li>
<li><a href="#18-python中实现io多路复用">18. python中实现IO多路复用</a></li>
<li><a href="#19-selectpoll和epoll">19. select,poll和epoll</a></li>
<li><a href="#20-python常用的并发网络库">20. python常用的并发网络库</a></li>
</ul>
</li>
<li><a href="#django">Django</a></li>
<li><a href="#flask">Flask</a></li>
<li><a href="#tornado">Tornado</a></li>
<li><a href="#jquery">jQuery</a></li>
<li><a href="#vue">Vue</a></li>
<li><a href="#angularjs">AngularJS</a></li>
<li><a href="#react">React</a></li>
</ul>
<!-- /TOC -->

</div>

<h1 id="Web基础"><a href="#Web基础" class="headerlink" title="Web基础"></a>Web基础</h1><h2 id="1-常用的网络传输协议"><a href="#1-常用的网络传输协议" class="headerlink" title="1. 常用的网络传输协议"></a>1. 常用的网络传输协议</h2><ul>
<li>TCP：传输控制协议，可靠传输，面向连接</li>
<li>UDP：用户数据包协议，不可靠传输，面向无连接</li>
<li>FTP：文件传输协议,用于上传和下载文件</li>
<li>HTTP：超文本传输协议，基于TCP/IP通信协议，面向对象</li>
<li>SMTP：邮件传输协议</li>
<li>TELNET：Internet远程登录服务的标准协议和主要方式</li>
<li>DNS：域名系统，将域名解析为ip地址</li>
</ul>
<h2 id="2-常见的状态码"><a href="#2-常见的状态码" class="headerlink" title="2. 常见的状态码"></a>2. 常见的状态码</h2><table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="left">状态</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td align="left">Ok</td>
<td align="left">请求成功</td>
</tr>
<tr>
<td align="center">400</td>
<td align="left">Bad Request</td>
<td align="left">请求语法错误，不能被服务器解析</td>
</tr>
<tr>
<td align="center">401</td>
<td align="left">Unauthorized</td>
<td align="left">未经授权，需与www-Authenticate一起用</td>
</tr>
<tr>
<td align="center">403</td>
<td align="left">Forbidden</td>
<td align="left">服务器收到请求，但拒绝提供服务</td>
</tr>
<tr>
<td align="center">404</td>
<td align="left">Not Found</td>
<td align="left">请求资源不存在</td>
</tr>
<tr>
<td align="center">500</td>
<td align="left">Internal Server Error</td>
<td align="left">服务器发生不可预期的错误</td>
</tr>
<tr>
<td align="center">503</td>
<td align="left">Server Unavailable</td>
<td align="left">服务器当前请求不可用</td>
</tr>
</tbody></table>
<h2 id="3-三次握手"><a href="#3-三次握手" class="headerlink" title="3. 三次握手"></a>3. 三次握手</h2><ul>
<li>第一次握手：建立连接时，客户端发送SYN（SYN=x）到服务器，有主动打开状态进入SYN_SENT状态，等待服务器确认。</li>
<li>第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=x+1）,同时自己也发送一个SYN包（syn=y），即SYN+ACK包，服务器进入SYN_RECV状态。</li>
<li>第三次握手：客户端收到服务器的SYN+ACK包，想服务器发送确认ACK包（ACK=y+1）,发送完毕，客户端和服务器进入ESTABLISHED状态，完成握手。</li>
</ul>
<h2 id="4-四次挥手"><a href="#4-四次挥手" class="headerlink" title="4. 四次挥手"></a>4. 四次挥手</h2><h2 id="5-session和cookie的区别"><a href="#5-session和cookie的区别" class="headerlink" title="5.session和cookie的区别"></a>5.session和cookie的区别</h2><h2 id="6-https的建立连接的过程"><a href="#6-https的建立连接的过程" class="headerlink" title="6. https的建立连接的过程"></a>6. https的建立连接的过程</h2><h2 id="7-https的传输数据是否是对称加密"><a href="#7-https的传输数据是否是对称加密" class="headerlink" title="7. https的传输数据是否是对称加密"></a>7. https的传输数据是否是对称加密</h2><h2 id="8-TCP拥堵控制"><a href="#8-TCP拥堵控制" class="headerlink" title="8. TCP拥堵控制"></a>8. TCP拥堵控制</h2><h2 id="9-如何高效处理socket"><a href="#9-如何高效处理socket" class="headerlink" title="9. 如何高效处理socket"></a>9. 如何高效处理socket</h2><h2 id="10-http的组成"><a href="#10-http的组成" class="headerlink" title="10. http的组成"></a>10. http的组成</h2><h2 id="11-http的头部，keepalive的作用"><a href="#11-http的头部，keepalive的作用" class="headerlink" title="11. http的头部，keepalive的作用"></a>11. http的头部，keepalive的作用</h2><h2 id="12-tcp建立连接的方式"><a href="#12-tcp建立连接的方式" class="headerlink" title="12. tcp建立连接的方式"></a>12. tcp建立连接的方式</h2><h2 id="13-本机的socket需要经过协议栈解包么"><a href="#13-本机的socket需要经过协议栈解包么" class="headerlink" title="13. 本机的socket需要经过协议栈解包么"></a>13. 本机的socket需要经过协议栈解包么</h2><h2 id="14-socket编程"><a href="#14-socket编程" class="headerlink" title="14. socket编程"></a>14. socket编程</h2><h2 id="15-urllib和urllib2"><a href="#15-urllib和urllib2" class="headerlink" title="15. urllib和urllib2"></a>15. urllib和urllib2</h2><h2 id="16-XSRF和XSS"><a href="#16-XSRF和XSS" class="headerlink" title="16. XSRF和XSS"></a>16. XSRF和XSS</h2><h2 id="17-POST和GET"><a href="#17-POST和GET" class="headerlink" title="17. POST和GET"></a>17. POST和GET</h2><h2 id="18-python中实现IO多路复用"><a href="#18-python中实现IO多路复用" class="headerlink" title="18. python中实现IO多路复用"></a>18. python中实现IO多路复用</h2><h2 id="19-select-poll和epoll"><a href="#19-select-poll和epoll" class="headerlink" title="19. select,poll和epoll"></a>19. select,poll和epoll</h2><h2 id="20-python常用的并发网络库"><a href="#20-python常用的并发网络库" class="headerlink" title="20. python常用的并发网络库"></a>20. python常用的并发网络库</h2><ul>
<li>tornado</li>
<li>gevent</li>
<li>asyncio</li>
</ul>
<h1 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h1><h1 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h1><h1 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h1><h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h1 id="AngularJS"><a href="#AngularJS" class="headerlink" title="AngularJS"></a>AngularJS</h1><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1>]]></content>
      <categories>
        <category>前端知识</category>
      </categories>
      <tags>
        <tag>Web基础</tag>
        <tag>前端框架</tag>
        <tag>知识回顾</tag>
      </tags>
  </entry>
  <entry>
    <title>自然语言处理知识点总结归纳</title>
    <url>/2020/05/08/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>本文主要对自然语言处理基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。</p>
</blockquote>
<a id="more"></a>

<div style='display: none'>

<!-- TOC -->

<ul>
<li><a href="#1-情感分析">1. 情感分析</a></li>
<li><a href="#2-文本挖掘">2. 文本挖掘</a></li>
<li><a href="#3-语义分析">3. 语义分析</a></li>
</ul>
<!-- /TOC -->

</div>

<h2 id="1-情感分析"><a href="#1-情感分析" class="headerlink" title="1. 情感分析"></a>1. 情感分析</h2><h2 id="2-文本挖掘"><a href="#2-文本挖掘" class="headerlink" title="2. 文本挖掘"></a>2. 文本挖掘</h2><h2 id="3-语义分析"><a href="#3-语义分析" class="headerlink" title="3. 语义分析"></a>3. 语义分析</h2>]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>情感分析</tag>
        <tag>文本分析</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统知识点总结归纳</title>
    <url>/2020/05/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>本文主要对操作系统和Linux基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。</p>
</blockquote>
<a id="more"></a>

<div style='display: none'>

<!-- TOC -->

<ul>
<li><a href="#操作系统">操作系统</a><ul>
<li><a href="#1-并发与并行">1. 并发与并行</a><ul>
<li><a href="#1-并发">(1) 并发</a></li>
<li><a href="#2-并行">(2) 并行</a></li>
<li><a href="#3-并发与并行的应用场景">(3) 并发与并行的应用场景</a></li>
</ul>
</li>
<li><a href="#2-同步与异步">2. 同步与异步</a></li>
<li><a href="#3-阻塞与非阻塞">3. 阻塞与非阻塞</a></li>
<li><a href="#4-进程线程以及协程间的区别">4. 进程、线程以及协程间的区别</a><ul>
<li><a href="#1-进程process">(1) 进程(process)</a></li>
<li><a href="#2-线程thread">(2) 线程(thread)</a></li>
<li><a href="#3-协程coroutine">(3) 协程(coroutine)</a></li>
<li><a href="#4-协程的优缺点">(4) 协程的优缺点</a></li>
<li><a href="#5-进程和线程的区别和优劣">(5) 进程和线程的区别和优劣</a></li>
<li><a href="#6-协程和线程的差异">(6) 协程和线程的差异</a></li>
</ul>
</li>
<li><a href="#5-python实现多进程">5. python实现多进程</a></li>
<li><a href="#6-python实现多线程">6. python实现多线程</a></li>
<li><a href="#7-python实现协程">7. python实现协程</a><ul>
<li><a href="#1-yield--send实现">(1) yield + send实现</a></li>
<li><a href="#2-asyncio--yield-from实现">(2) asyncio + yield from实现</a></li>
<li><a href="#3-asyncio--asnycawait实现">(3) asyncio + asnyc/await实现</a></li>
<li><a href="#4-greenlet-实现">(4) greenlet 实现</a></li>
</ul>
</li>
<li><a href="#8-进程间通信">8. 进程间通信</a><ul>
<li><a href="#1-消息队列queue">(1) 消息队列Queue</a></li>
<li><a href="#2-管道pipe">(2) 管道Pipe</a></li>
<li><a href="#3-共享内存">(3) 共享内存</a></li>
<li><a href="#4-信号量">(4) 信号量</a></li>
<li><a href="#5-socket套接字">(5) socket套接字</a></li>
<li><a href="#6-信号signal">(6) 信号signal</a></li>
</ul>
</li>
<li><a href="#9-线程间通信">9. 线程间通信</a><ul>
<li><a href="#1-互斥锁">(1) 互斥锁</a></li>
<li><a href="#2-信号量">(2) 信号量</a></li>
<li><a href="#3-条件变量">(3) 条件变量</a></li>
<li><a href="#4-事件">(4) 事件</a></li>
<li><a href="#5-消息队列">(5) 消息队列</a></li>
</ul>
</li>
<li><a href="#10-孤儿进程僵尸进程守护进程">10. 孤儿进程、僵尸进程、守护进程</a></li>
<li><a href="#11-进程池">11. 进程池</a></li>
<li><a href="#12-守护线程">12. 守护线程</a></li>
<li><a href="#13-线程池">13. 线程池</a></li>
<li><a href="#14-线程安全">14. 线程安全</a></li>
<li><a href="#15-多线程资源竞争怎么解决">15. 多线程资源竞争，怎么解决</a></li>
<li><a href="#16-有几种锁">16. 有几种锁</a></li>
<li><a href="#17-调度算法">17. 调度算法</a><ul>
<li><a href="#1-先来先服务fcfs-first-come-first-service">(1) 先来先服务(FCFS, First Come First Service)</a></li>
<li><a href="#2-短作业优先sjf-shortest-job-first">(2) 短作业优先(SJF, Shortest Job First)</a></li>
<li><a href="#3-最高优先权调度priority-scheduling">(3) 最高优先权调度(Priority Scheduling)</a></li>
<li><a href="#4-时间片轮转rr-round-robin">(4) 时间片轮转(RR, Round Robin)</a></li>
<li><a href="#5-多级反馈队列调度multilevel-feedback-queue-scheduling">(5) 多级反馈队列调度(Multilevel Feedback Queue Scheduling)</a></li>
</ul>
</li>
<li><a href="#18-空">18. 空</a></li>
<li><a href="#19-nginx如何处理连接">19. nginx如何处理连接</a></li>
<li><a href="#20-nginx如何做性能优化">20. nginx如何做性能优化</a></li>
<li><a href="#21-nginx与apache的区别">21. nginx与apache的区别</a></li>
<li><a href="#22-nginx超时怎么办">22. nginx超时怎么办</a></li>
</ul>
</li>
<li><a href="#linux">Linux</a><ul>
<li><a href="#1-linux常用命令">1. linux常用命令</a></li>
<li><a href="#2-linux内存管理机制">2. Linux内存管理机制</a></li>
<li><a href="#3使用什么命令查看cpu和内存情况">3.使用什么命令查看cpu和内存情况</a></li>
<li><a href="#4-如何查看进程的线程情况">4. 如何查看进程的线程情况</a></li>
<li><a href="#5-如何查看系统性能性能指标">5. 如何查看系统性能、性能指标</a></li>
<li><a href="#6-查看系统负载">6. 查看系统负载</a></li>
<li><a href="#7-linux文件类型文件管理">7. linux文件类型、文件管理</a></li>
<li><a href="#8-cup负载过高怎么解决">8. cup负载过高怎么解决</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

</div>

<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-并发与并行"><a href="#1-并发与并行" class="headerlink" title="1. 并发与并行"></a>1. 并发与并行</h2><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="(1) 并发"></a>(1) 并发</h3><blockquote>
<p>并发是指同一时间间隔内多个任务都在运行，但是并不会在用一时刻同时运行，存在交替执行的情况，因此也经常存在资源竞争德尔情况。线程是并发的，实现的库有threading。</p>
</blockquote>
<h3 id="2-并行"><a href="#2-并行" class="headerlink" title="(2) 并行"></a>(2) 并行</h3><blockquote>
<p>并行指的是同一时刻多个任务同时运行，进程是并行的，实现的库有multiprocessing。</p>
</blockquote>
<h3 id="3-并发与并行的应用场景"><a href="#3-并发与并行的应用场景" class="headerlink" title="(3) 并发与并行的应用场景"></a>(3) 并发与并行的应用场景</h3><blockquote>
<p>IO密集型操作（程序需要执行较多的读写，请求和回复任务的需要CPU对硬盘、内存进行读写，如爬虫）应使用并发更好，类似于多线程。</p>
</blockquote>
<blockquote>
<p>CPU密集型操作（程序运行需要花大量时间做逻辑判断、运算等消耗CUP资源的操作，如复杂的浮点运算）应使用并行更好，类似于多进程。</p>
</blockquote>
<h2 id="2-同步与异步"><a href="#2-同步与异步" class="headerlink" title="2. 同步与异步"></a>2. 同步与异步</h2><blockquote>
<p>同步和异步都是相对于多任务而言的。</p>
</blockquote>
<blockquote>
<p>同步：多个任务之间有先后顺序执行，一个执行完才能执行下一个。</p>
</blockquote>
<blockquote>
<p>异步：多个任务之间没有先后顺序，可以同时执行，有时候一个任务可能在必要的时候获取另一个同时执行的任务的结果，这叫回调。</p>
</blockquote>
<h2 id="3-阻塞与非阻塞"><a href="#3-阻塞与非阻塞" class="headerlink" title="3. 阻塞与非阻塞"></a>3. 阻塞与非阻塞</h2><blockquote>
<p>阻塞非阻塞是相对于代码执行而言的。</p>
</blockquote>
<blockquote>
<p>阻塞：如果卡住了调用者，调用者不能继续往下执行，当前线程会被挂起，调用线程只有在得到结果之后才会返回，就是说调用者阻塞了，函数只有在得到结果之后才会将阻塞的线程激活。</p>
</blockquote>
<blockquote>
<p>如果不会卡住，可以继续执行就是非阻塞的，非阻塞调用指在不能立刻得到结果之前也会立刻返回，同时该函数不会阻塞当前线程。</p>
</blockquote>
<h2 id="4-进程、线程以及协程间的区别"><a href="#4-进程、线程以及协程间的区别" class="headerlink" title="4. 进程、线程以及协程间的区别"></a>4. 进程、线程以及协程间的区别</h2><p><strong><a href="https://blog.csdn.net/holysll/article/details/89344794" target="_blank" rel="noopener">线程、进程、协程、锁的总结</a></strong></p>
<h3 id="1-进程-process"><a href="#1-进程-process" class="headerlink" title="(1) 进程(process)"></a>(1) 进程(process)</h3><blockquote>
<p>进程是系统进行资源分配和调度的一个独立的最小单位，它是程序执行的一个实例。</p>
</blockquote>
<blockquote>
<p>程序运行时，系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候，就会为它分配CPU、内存、时间片，程序开始真正运行。</p>
</blockquote>
<blockquote>
<p>进程拥有自己独立的内存空间，进程间数据不共享，因此开销大。</p>
</blockquote>
<blockquote>
<p>进程特征：</p>
</blockquote>
<ul>
<li>动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生的，动态消亡的；</li>
<li>并发性：任何进程都可以同其他进程一起并发执行。</li>
<li>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位。</li>
<li>异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。</li>
</ul>
<h3 id="2-线程-thread"><a href="#2-线程-thread" class="headerlink" title="(2) 线程(thread)"></a>(2) 线程(thread)</h3><blockquote>
<p>线程是程序执行的最小单位，它是进程的一个实体，也是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本的单位。</p>
</blockquote>
<blockquote>
<p>一个程序至少有一个进程，一个进程至少有一个线程。一个进程可以由多个线程组成，线程不能够独立执行，必须依存在进程中。</p>
</blockquote>
<blockquote>
<p>线程间共享进程的所有资源（内存共享、数据共享、全局变量共享等），从而极大的提高了程序的运行效率，每个线程有自己的堆栈和局部变量。</p>
</blockquote>
<blockquote>
<p>线程的划分尺度小于进程（资源比进程少，仅仅需要运行中必不可少的程序计数器、寄存器和栈），使得多线程程序的并发性高。</p>
</blockquote>
<blockquote>
<p>线程执行开销小，但不利于资源管理和保护，而进程刚好相反。</p>
</blockquote>
<h3 id="3-协程-coroutine"><a href="#3-协程-coroutine" class="headerlink" title="(3) 协程(coroutine)"></a>(3) 协程(coroutine)</h3><blockquote>
<p>协程是一种用户态的轻量级线程，也称微线程，协程的调度完全由用户控制。</p>
</blockquote>
<blockquote>
<p>协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
</blockquote>
<blockquote>
<p>在合适的实际，gevent实现的协程可以把一个协程切换到另一个协程。只要这个过程中保存或回复CPU上下文那么程序还是可以运行的。</p>
</blockquote>
<blockquote>
<p>通俗解释：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且且换的次数以及什么时候再切换到原来的函数都由开发者自己去确定。</p>
</blockquote>
<blockquote>
<p>协程是程序级别的，由程序员根据需要自己调度。我们把一个线程中的一个个函数叫做子程序，那么子程序在执行过程中可以中断去执行别的子程序；别的子程序也可以中断回来继续执行之前的子程序，这就是协程。</p>
</blockquote>
<h3 id="4-协程的优缺点"><a href="#4-协程的优缺点" class="headerlink" title="(4) 协程的优缺点"></a>(4) 协程的优缺点</h3><ul>
<li><p>协程的优点</p>
<ul>
<li>无需线程上下文切换的开销，协程避免了无意义的调度，由此可以提高性能（但也失去了标准线程使用多CPU的能力，需要用户自己控制调度）；</li>
<li>无需原子操作锁定及同步的开销；</li>
<li>方便切换控制流，简化编程模型；</li>
<li>协程很适合用于高并发处理，一个CPU支持上万的协程不是问题，高并发+高扩展性+低成本。</li>
</ul>
</li>
<li><p>协程的缺点</p>
<ul>
<li>无法利用多核资源，协程的本质是个单线程，它不能同时将单个CPU的多个核上，协程需要和进程配合才能运行在多个CPU上（CPU密集型应用）。</li>
<li>进行阻塞操作时，会阻塞掉整个程序。</li>
</ul>
</li>
</ul>
<h3 id="5-进程和线程的区别和优劣"><a href="#5-进程和线程的区别和优劣" class="headerlink" title="(5) 进程和线程的区别和优劣"></a>(5) 进程和线程的区别和优劣</h3><ul>
<li><p>进程是资源分配的最小单位，线程是程序执行的最小单位；</p>
</li>
<li><p>进程有自己独立的地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，耗费资源多；而线程是共享进程间的资源，使用相同的地址空间，因此CPU 切换和创建一个线程的开销比进程小很多。</p>
</li>
<li><p>线程之间的通信更方便，统一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信的方式进行，不过如何处理好同步与互斥是编写多线程程序的难点。</p>
</li>
<li><p>多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，因为所有线程共享进程的内存；而一个进程死掉并不会对别的进程造成影响，因为进程有独立独立的地址空间，著名的Apache最早就是采用多进程的模式，现在好像使用的是多进程+多线程的混合模式。</p>
</li>
</ul>
<h3 id="6-协程和线程的差异"><a href="#6-协程和线程的差异" class="headerlink" title="(6) 协程和线程的差异"></a>(6) 协程和线程的差异</h3><ul>
<li>(1) 在实现多任务时，线程切换从系统层面远不止保存和恢复cpu上下文这么简单。</li>
<li>(2) 操作系统为了程序运行的高效性，每个线程都有自己缓存Cache等数据，操作系统会自动实现数据恢复操作，所以线程切换非常耗性能。</li>
<li>(3) 协程切换只是单纯的操作CPU上下文，所以一秒秒钟切换上百万次系统都扛得住。</li>
</ul>
<h2 id="5-python实现多进程"><a href="#5-python实现多进程" class="headerlink" title="5. python实现多进程"></a>5. python实现多进程</h2><blockquote>
<p>Unix/Linux操作系统提供了一个<code>fork()</code>系统调用，它非常特殊。普通的函数调用，调用一次返回一次，但是<code>fork()</code>调用一次返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后分别在父进程和子进程内返回。</p>
</blockquote>
<blockquote>
<p>子进程永远返回0，而父进程返回进程的ID。一个父进程可以fork出多个子进程，所以父进程要记下每个子进程的ID，而子进程只主要调用<code>getppid()</code>就可以拿到父进程的ID。</p>
</blockquote>
<blockquote>
<p>父进程、子进程执行的顺序没有规律，完全取决于操作系统的调度算法。各个进程有独立的运行空间，不共享全局变量；有时会因父进程提前退出，子进程的父进程和开始的不一致。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># os模块封装了常见的系统调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(<span class="string">f"Process <span class="subst">&#123;os.getpid()&#125;</span> start..."</span>)  <span class="comment"># unix/linux/mac系统中</span></span><br><span class="line"></span><br><span class="line">pid = os.fork()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pid &lt; <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">"fork()调用失败"</span>)</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">f"父进程pid: <span class="subst">&#123;os.getppid()&#125;</span>, 子进程pid: <span class="subst">&#123;os.gerpid()&#125;</span>."</span>)  <span class="comment"># 子进程在系统的pid不为0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">f"子进程pid: <span class="subst">&#123;os.getpid()&#125;</span>, 父进程pid: <span class="subst">&#123;pid&#125;</span>"</span>)  <span class="comment"># 父进程返回子进程的ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Process 3362 start...</span></span><br><span class="line"><span class="string">父进程pid：3362， 子进程pid：3363</span></span><br><span class="line"><span class="string">子进程pid：3363， 子进程pid：3362</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于Windows没有fork调用，而Python是跨平台的，所以可以调用multiprocessing模块中的Process类来实现跨平台的多进程。</p>
</blockquote>
<blockquote>
<p>Process()的语法：<code>Process([group[, target[, name [, args[, kwargs]]]]])</code>，group参数未使用，默认为None；参数target表示这个进程实例所调用的对象；args表示调用这个对象的位置和参数元组；kwargs表示调用对象的关键子参数字典；name子进程名称。</p>
</blockquote>
<blockquote>
<p>Process属性方法</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法/属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">start()</td>
<td align="left">启动进程，调用进程中的run()方法。</td>
</tr>
<tr>
<td align="center">run()</td>
<td align="left">进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法。</td>
</tr>
<tr>
<td align="center">timinate()</td>
<td align="left">强制终止进程，不会进行任何清理操作。如果该进程终止前，创建了自进程，那么该子进程在其强制结束后变为僵尸进程；如果进程还保存了一个锁，那么也将不会被释放，进而导致死锁。使用时，要注意。</td>
</tr>
<tr>
<td align="center">is_alive()</td>
<td align="left">判断某进程是否存活，存活返回True，否则False。</td>
</tr>
<tr>
<td align="center">join([timeout])</td>
<td align="left">主线程等待子线程终止。timeout为可选超时时间；p.join()只能join住start开启的进程，而不能join住run开启的进程</td>
</tr>
<tr>
<td align="center">daemon()</td>
<td align="left">默认值False, 如果设置为True，代表该进程为后台守护进程；当该进程的父进程终止时，该进程也随之终止；并且设置为True后，该进程不能创建子进程，设置该属性必须在start()之前。</td>
</tr>
<tr>
<td align="center">exitcode</td>
<td align="left">进程运行时为None，如果为-N，表示信号N结束了。</td>
</tr>
<tr>
<td align="center">authkey</td>
<td align="left">进程身份验证，默认是由os.urandom()随机生成32字符的字符串。这个键的用途是设计涉及网络链接的低层进程间的通信提供安全性，这类连接只有在具有相同身份验证才能成功。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">f"子进程<span class="subst">&#123;name&#125;</span>运行中，pid=<span class="subst">&#123;os.getpid()&#125;</span>，父进程的pid=<span class="subst">&#123;os.getppid()&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">f"父进程是<span class="subst">&#123;os.getpid()&#125;</span>."</span>)</span><br><span class="line">    p = Process(target=run_proc, args=(<span class="string">'test'</span>,))</span><br><span class="line">    print(<span class="string">"子进程开始启动."</span>)</span><br><span class="line">    p.start()  <span class="comment"># 启动进程</span></span><br><span class="line">    p.join()  <span class="comment"># 阻塞当前进程，直到调用join方法的那个进程执行完，在继续执行当前进程</span></span><br><span class="line">    print(<span class="string">"子进程运行结束"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">父进程是12324.</span></span><br><span class="line"><span class="string">子进程开始启动.</span></span><br><span class="line"><span class="string">子进程test运行中，pid=4472，父进程的pid=12324</span></span><br><span class="line"><span class="string">子进程运行结束</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建自己的进程类，继承于Process类：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, interval)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.interval = interval</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"子进程"</span>)</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        time.sleep(self.interval)</span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print(<span class="string">f"子进程id: <span class="subst">&#123;os.getpid()&#125;</span>, 父进程id：<span class="subst">&#123;os.getppid()&#125;</span>, 共执行了<span class="subst">&#123;stop_time-start_time: <span class="number">.2</span>f&#125;</span> 秒."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"主进程"</span>)</span><br><span class="line">    startTime = time.time()</span><br><span class="line">    p = MyProcess(<span class="number">2</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    stopTime = time.time()</span><br><span class="line">    print(<span class="string">f"子进程结束，花费了<span class="subst">&#123;stopTime-startTime: <span class="number">.2</span>f&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">主进程</span></span><br><span class="line"><span class="string">子进程</span></span><br><span class="line"><span class="string">子进程id: 3008, 父进程id：13084, 共执行了 2.00 秒.</span></span><br><span class="line"><span class="string">子进程结束，花费了 2.79</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果需要创建很多进程，需要用到进程池Pool方法。初始化进程时，可以指定一个最大进程数(默认为CPU核数)，当池中的进程数达到最大值时，该请求就会等待，直到池中有进程结束，才会创建新的进程来执行。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程类</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(msg)</span>:</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    print(<span class="string">f"<span class="subst">&#123;msg&#125;</span>开始执行，执行进程id为<span class="subst">&#123;os.getpid()&#125;</span>，父进程id为<span class="subst">&#123;os.getppid()&#125;</span>"</span>)</span><br><span class="line">    time.sleep(random.random()*<span class="number">2</span>)</span><br><span class="line">    stop_time = time.time()</span><br><span class="line">    print(msg, <span class="string">f"执行完毕，耗时<span class="subst">&#123;stop_time-start_time: <span class="number">.2</span>f&#125;</span>秒。"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"----开始执行----"</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    pool = Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        pool.apply_async(worker, (i,))  <span class="comment"># 异步非阻塞</span></span><br><span class="line">    pool.close()  <span class="comment"># 关闭进程池，关闭后不再就收新请求</span></span><br><span class="line">    pool.join()  <span class="comment"># 必须放在close语句后面</span></span><br><span class="line">    stop = time.time()</span><br><span class="line">    print(<span class="string">f"执行结束，总耗时<span class="subst">&#123;stop-start:<span class="number">.2</span>f&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">----开始执行----</span></span><br><span class="line"><span class="string">0开始执行，执行进程id为4640，父进程id为7116</span></span><br><span class="line"><span class="string">1开始执行，执行进程id为8，父进程id为7116</span></span><br><span class="line"><span class="string">2开始执行，执行进程id为7728，父进程id为7116</span></span><br><span class="line"><span class="string">0 执行完毕，耗时 0.09秒。</span></span><br><span class="line"><span class="string">3开始执行，执行进程id为4640，父进程id为7116</span></span><br><span class="line"><span class="string">2 执行完毕，耗时 0.10秒。</span></span><br><span class="line"><span class="string">4开始执行，执行进程id为7728，父进程id为7116</span></span><br><span class="line"><span class="string">4 执行完毕，耗时 0.04秒。</span></span><br><span class="line"><span class="string">5开始执行，执行进程id为7728，父进程id为7116</span></span><br><span class="line"><span class="string">3 执行完毕，耗时 0.20秒。</span></span><br><span class="line"><span class="string">6开始执行，执行进程id为4640，父进程id为7116</span></span><br><span class="line"><span class="string">6 执行完毕，耗时 0.12秒。</span></span><br><span class="line"><span class="string">7开始执行，执行进程id为4640，父进程id为7116</span></span><br><span class="line"><span class="string">5 执行完毕，耗时 1.38秒。</span></span><br><span class="line"><span class="string">8开始执行，执行进程id为7728，父进程id为7116</span></span><br><span class="line"><span class="string">1 执行完毕，耗时 1.95秒。</span></span><br><span class="line"><span class="string">9开始执行，执行进程id为8，父进程id为7116</span></span><br><span class="line"><span class="string">8 执行完毕，耗时 0.48秒。</span></span><br><span class="line"><span class="string">7 执行完毕，耗时 1.81秒。</span></span><br><span class="line"><span class="string">9 执行完毕，耗时 1.58秒。</span></span><br><span class="line"><span class="string">执行结束，总耗时4.63</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用进程池pool创建进程的话，就需要使用<code>Manager().Queue()</code>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager, Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># queue，实现多进程间的数据传递，其实是个消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">f"--开始执行写进程 <span class="subst">&#123;os.getpid()&#125;</span>--"</span>)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]:</span><br><span class="line">        print(<span class="string">f"把 <span class="subst">&#123;value&#125;</span> 放入队列"</span>)</span><br><span class="line">        q.put(value)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">f"--开始执行读进程 <span class="subst">&#123;os.getpid()&#125;</span>--"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(q.qsize()):</span><br><span class="line">        print(<span class="string">f"从队列读取 <span class="subst">&#123;q.get(<span class="literal">True</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">f"--开始执行主进程 <span class="subst">&#123;os.getpid()&#125;</span>--"</span>)</span><br><span class="line">    q = Manager().Queue()</span><br><span class="line">    p = Pool()</span><br><span class="line">    p.apply(write, args=(q,))  <span class="comment"># apply 阻塞，上个进程结束才会执行下一个进程</span></span><br><span class="line">    p.apply(read, args=(q,))</span><br><span class="line">    p.close()  <span class="comment"># 关闭pool 不再接收请求</span></span><br><span class="line">    p.join()  <span class="comment"># 主进程阻塞，等待子进程运行结束，必须在close以后</span></span><br><span class="line">    print(<span class="string">"--主进程结束--"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">--开始执行主进程 6012--</span></span><br><span class="line"><span class="string">--开始执行写进程 11524--</span></span><br><span class="line"><span class="string">把 A 放入队列</span></span><br><span class="line"><span class="string">把 B 放入队列</span></span><br><span class="line"><span class="string">把 C 放入队列</span></span><br><span class="line"><span class="string">--开始执行读进程 11524--</span></span><br><span class="line"><span class="string">从队列读取 A</span></span><br><span class="line"><span class="string">从队列读取 B</span></span><br><span class="line"><span class="string">从队列读取 C</span></span><br><span class="line"><span class="string">--主进程结束--</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当子进程不是自身，而是一个外部进程时，创建子进程后，还需要控制子进程的输入和输出。subprocess模块可以非常方便的启动子进程，然后可以通过communicate()方法输入。</p>
</blockquote>
<p><strong><a href="https://www.cnblogs.com/lgj8/p/12132829.html" target="_blank" rel="noopener">python 中subprocess</a></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">print(<span class="string">'$ nslookup'</span>)</span><br><span class="line">p = subprocess.Popen([<span class="string">'nslookup'</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">output, err = p.communicate(<span class="string">b'set q=mx\npython.org\nexit\n'</span>)</span><br><span class="line">print(output.decode(<span class="string">"gbk"</span>))</span><br><span class="line">print(<span class="string">'exit code:'</span>, p.returncode)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">$ nslookup</span></span><br><span class="line"><span class="string">默认服务器:  dnspai-public-dns.dnspai.com</span></span><br><span class="line"><span class="string">Address:  101.226.4.6</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt; &gt; 服务器:  dnspai-public-dns.dnspai.com</span></span><br><span class="line"><span class="string">Address:  101.226.4.6</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">python.org	MX preference = 50, mail exchanger = mail.python.org</span></span><br><span class="line"><span class="string">&gt; </span></span><br><span class="line"><span class="string">exit code: 0</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="6-python实现多线程"><a href="#6-python实现多线程" class="headerlink" title="6. python实现多线程"></a>6. python实现多线程</h2><blockquote>
<p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。线程是操作系统直接支持的执行单元，Python的标准库提供了两个模块_thread（低级模块）和threading（高级模块），大部分情况下选择用threading模块。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新线程执行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(num)</span>:</span></span><br><span class="line">    print(<span class="string">f"线程<span class="subst">&#123;threading.current_thread().name&#125;</span>正在运行..."</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; num:</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        print(<span class="string">f"线程<span class="subst">&#123;threading.current_thread().name&#125;</span> &gt;&gt;&gt; <span class="subst">&#123;n&#125;</span>"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">f"线程<span class="subst">&#123;threading.current_thread().name&#125;</span>结束"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f"线程<span class="subst">&#123;threading.current_thread().name&#125;</span>正在运行..."</span>)</span><br><span class="line">t = threading.Thread(target=loop, name=<span class="string">'LoopThread'</span>, args=(<span class="number">5</span>,))  <span class="comment"># 通过传参的方式调用局部变量</span></span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(<span class="string">f"线程<span class="subst">&#123;threading.current_thread().name&#125;</span>运行结束."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">线程MainThread正在运行...</span></span><br><span class="line"><span class="string">线程LoopThread正在运行...</span></span><br><span class="line"><span class="string">线程LoopThread &gt;&gt;&gt; 1</span></span><br><span class="line"><span class="string">线程LoopThread &gt;&gt;&gt; 2</span></span><br><span class="line"><span class="string">线程LoopThread &gt;&gt;&gt; 3</span></span><br><span class="line"><span class="string">线程LoopThread &gt;&gt;&gt; 4</span></span><br><span class="line"><span class="string">线程LoopThread &gt;&gt;&gt; 5</span></span><br><span class="line"><span class="string">线程LoopThread结束.</span></span><br><span class="line"><span class="string">线程MainThread运行结束.</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个进程中的线程共享相同的内存单元、内存地址空间，可以访问相同的变量和对象，而且他们从同一堆中分配对象，通信、数据交换、同步操作，缺点线程是对全局变量随意修改，可能造成多线程之间对全局变量的混乱（不安全），可以通过传参的方式调用全局变量（不适用可变类型），但是修改次数过多，会有多次线程切换，产生紊乱。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给线程加锁，实现线程按顺序执行</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task1</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> lock1.acquire():  <span class="comment"># 获取锁对象</span></span><br><span class="line">                print(<span class="string">"--Task1--"</span>)</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line">                lock2.release()  <span class="comment"># 释放锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task2</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> lock2.acquire():</span><br><span class="line">                print(<span class="string">"--Task2--"</span>)</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line">                lock3.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task3</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> lock3.acquire():</span><br><span class="line">                print(<span class="string">"--Task3--"</span>)</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line">                lock1.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lock1 = Lock()</span><br><span class="line">lock2 = Lock()</span><br><span class="line">lock2.acquire()</span><br><span class="line">lock3 = Lock()</span><br><span class="line">lock3.acquire()</span><br><span class="line"></span><br><span class="line">t1 = Task1()</span><br><span class="line">t2 = Task2()</span><br><span class="line">t3 = Task3()</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">--Task1--</span></span><br><span class="line"><span class="string">--Task2--</span></span><br><span class="line"><span class="string">--Task3--</span></span><br><span class="line"><span class="string">--Task1--</span></span><br><span class="line"><span class="string">--Task2--</span></span><br><span class="line"><span class="string">--Task3--</span></span><br><span class="line"><span class="string">    .</span></span><br><span class="line"><span class="string">    .</span></span><br><span class="line"><span class="string">    .</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Thread对象的属性和方法</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="left"><strong><em>\</em>***Thread对象数据属性*****</strong></td>
</tr>
<tr>
<td align="center"><code>name</code></td>
<td align="left">线程名</td>
</tr>
<tr>
<td align="center"><code>ident</code></td>
<td align="left">线程的标识符</td>
</tr>
<tr>
<td align="center"><code>daemon</code></td>
<td align="left">布尔标志，表示这个线程是否是守护线程</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><strong><em>\</em>***Thread对象方法*****</strong></td>
</tr>
<tr>
<td align="center"><code>__init__(group=None, target=None, name=None, args=(), kwargs={}, verbose=None, daemon=None)</code></td>
<td align="left">实例化一个线程对象，需要有一个可调用的<code>target</code>，以及其参数<code>args</code>或者<code>kwargs</code>。还可以传递<code>name</code>或者<code>group</code>参数，不过后者还未实现。此外，<code>verbose</code>标志也是可选的，而<code>daemon</code>的值将会设定<code>thread.daemon</code>属性/标志。</td>
</tr>
<tr>
<td align="center"><code>start()</code></td>
<td align="left">开始执行线程</td>
</tr>
<tr>
<td align="center"><code>run()</code></td>
<td align="left">定义线程功能的方法（通常在子类中被应用开发者重写）</td>
</tr>
<tr>
<td align="center"><code>join(timeout=None)</code></td>
<td align="left">直至启动线程终止之前一直挂起，除非给出了timeout，否则会一直阻塞</td>
</tr>
<tr>
<td align="center"><code>getName()</code></td>
<td align="left">返回线程名</td>
</tr>
<tr>
<td align="center"><code>setName(name)</code></td>
<td align="left">设定线程名</td>
</tr>
<tr>
<td align="center"><code>isAlivel/is_alive()</code></td>
<td align="left">布尔标志，表示这个进程是否还存活</td>
</tr>
<tr>
<td align="center"><code>isDaemon()</code></td>
<td align="left">如果是守护线程，则返回True，否则返回False</td>
</tr>
<tr>
<td align="center"><code>setDaemon(daemonic)</code></td>
<td align="left">把线程的守护标志设定为布尔值<code>daemonic</code>（必须在线程<code>start()之前调用</code>）</td>
</tr>
</tbody></table>
<h2 id="7-python实现协程"><a href="#7-python实现协程" class="headerlink" title="7. python实现协程"></a>7. python实现协程</h2><h3 id="1-yield-send实现"><a href="#1-yield-send实现" class="headerlink" title="(1) yield + send实现"></a>(1) yield + send实现</h3><blockquote>
<p>通过“生产者-消费者”模型来看下协程的应用，生产者产生消息后，直接通过yield跳转到消费者开始执行，带消费者执行完毕后，切换回生产者继续生产。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用生成器实现协程</span></span><br><span class="line"><span class="comment"># 来源：https://juejin.im/post/5d888151f265da03dd3db0f5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(<span class="string">f"[CONSUMER] Consuming <span class="subst">&#123;n&#125;</span> ..."</span>)</span><br><span class="line">        r = <span class="string">'200 OK'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(c)</span>:</span></span><br><span class="line">    <span class="comment"># 启动生成器</span></span><br><span class="line">    c.send(<span class="literal">None</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        print(<span class="string">f'[PRODUCER] Producing <span class="subst">&#123;n&#125;</span> ...'</span>)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(<span class="string">f'[PRODUCER] Consumer return: <span class="subst">&#123;r&#125;</span>'</span>)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    c = consumer()</span><br><span class="line">    producer(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[PRODUCER] Producing 1 ...</span></span><br><span class="line"><span class="string">[CONSUMER] Consuming 1 ...</span></span><br><span class="line"><span class="string">[PRODUCER] Consumer return: 200 OK</span></span><br><span class="line"><span class="string">[PRODUCER] Producing 2 ...</span></span><br><span class="line"><span class="string">[CONSUMER] Consuming 2 ...</span></span><br><span class="line"><span class="string">[PRODUCER] Consumer return: 200 OK</span></span><br><span class="line"><span class="string">[PRODUCER] Producing 3 ...</span></span><br><span class="line"><span class="string">[CONSUMER] Consuming 3 ...</span></span><br><span class="line"><span class="string">[PRODUCER] Consumer return: 200 OK</span></span><br><span class="line"><span class="string">[PRODUCER] Producing 4 ...</span></span><br><span class="line"><span class="string">[CONSUMER] Consuming 4 ...</span></span><br><span class="line"><span class="string">[PRODUCER] Consumer return: 200 OK</span></span><br><span class="line"><span class="string">[PRODUCER] Producing 5 ...</span></span><br><span class="line"><span class="string">[CONSUMER] Consuming 5 ...</span></span><br><span class="line"><span class="string">[PRODUCER] Consumer return: 200 OK</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>send(msg)</code>与<code>next()</code>的区别在于<code>send</code>可以传递参数给<code>yield</code>表达式，这时传递的参数会作为<code>yield</code>表达式的值，而<code>yield</code>的参数是返回给调用者的值。换句话说，就是<code>send</code>可以强行修改上一个yield表达式的值。比如函数中有一个<code>yield</code>赋值<code>a = yield 5</code>，第一次迭代到这里会返回5，a还没有赋值。第二次迭代时，使用<code>send(10)</code>，那么就是强行修改<code>yield 5</code>表达式的值为10，本来是5的，结果<code>a = 10</code>。<code>send(msg)</code>与<code>next()</code>都有返回值，它们的返回值是当前迭代遇到<code>yield</code>时，<code>yield</code>后面表达式的值，其实就是当前迭代中<code>yield</code>后面的参数。第一次调用<code>send</code>时必须是<code>send(None)</code>，否则会报错，之所以为<code>None</code>是因为这时候还没有一个<code>yield</code>表达式可以用来赋值。</p>
</blockquote>
<h3 id="2-asyncio-yield-from实现"><a href="#2-asyncio-yield-from实现" class="headerlink" title="(2) asyncio + yield from实现"></a>(2) asyncio + yield from实现</h3><blockquote>
<p>asyncio是Python3.4版本引入的标准库，直接内置了对IO的支持。asyncio的异步操作，需要在coroutine中通过yield from 完成。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(<span class="string">"test_1"</span>, i)</span><br><span class="line">    r = <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'test_2'</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [test(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">test_1 2</span></span><br><span class="line"><span class="string">test_1 1</span></span><br><span class="line"><span class="string">test_1 0</span></span><br><span class="line"><span class="string">test_2 2</span></span><br><span class="line"><span class="string">test_2 1</span></span><br><span class="line"><span class="string">test_2 0</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@asyncio.coroutine</code> 把一个generator标记为coroutine类型，然后就把这个coroutine扔到EventLoop中执行。<code>test()</code>会首先打印出<code>test_1</code>，然后<code>yield from</code>语法可以让我们方便地调用另一个generator。由于<code>asyncio.sleep()</code>也是一个coroutine，所以线程不会等待<code>asyncio.sleep()</code>，而是直接中断并执行下一个消息循环。当<code>asyncio.sleep()</code>返回时，线程就可以从<code>yield from</code>拿到返回值（此处是None），然后接着执行下一行语句。把<code>asyncio.sleep(1)</code>看成是一个耗时1秒的IO操作，在此期间主线程并未等待，而是去执行EventLoop中其他可以执行的coroutine了，因此可以实现并发执行。</p>
</blockquote>
<h3 id="3-asyncio-asnyc-await实现"><a href="#3-asyncio-asnyc-await实现" class="headerlink" title="(3) asyncio + asnyc/await实现"></a>(3) asyncio + asnyc/await实现</h3><blockquote>
<p>为了简化并耕海的标识异步IO，从Python3.5开始，引入了新的语法<code>async</code>和<code>await</code>，可以让coroutine的代码更简洁易读。实际上，就是<code>async</code>替换<code>@asyncio.coroutine</code>，await替换<code>yield from</code>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(<span class="string">'test_1'</span>, i)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'test_2'</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [test(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">test_1 2</span></span><br><span class="line"><span class="string">test_1 1</span></span><br><span class="line"><span class="string">test_1 0</span></span><br><span class="line"><span class="string">test_2 2</span></span><br><span class="line"><span class="string">test_2 1</span></span><br><span class="line"><span class="string">test_2 0</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h3 id="4-greenlet-实现"><a href="#4-greenlet-实现" class="headerlink" title="(4) greenlet 实现"></a>(4) greenlet 实现</h3><blockquote>
<p>Gevent是一个基于Greenlet实现的网络库，通过greenlet实现协程。基本思想是一个greenlet就认为是一个协程，当一个greenlet遇到IO操作的时候，比如访问网络，就会自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO操作。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        print(gevent.getcurrent(), i)</span><br><span class="line">        <span class="comment"># gevent.sleep(1)  # 把3个greenlet依次运行改为交替运行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    g1 = gevent.spawn(test, <span class="number">3</span>)</span><br><span class="line">    g2 = gevent.spawn(test, <span class="number">3</span>)</span><br><span class="line">    g3 = gevent.spawn(test, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    g1.join()</span><br><span class="line">    g2.join()</span><br><span class="line">    g3.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;Greenlet at 0x1ee82d8c268: test(3)&gt; 0</span></span><br><span class="line"><span class="string">&lt;Greenlet at 0x1ee82d8c268: test(3)&gt; 1</span></span><br><span class="line"><span class="string">&lt;Greenlet at 0x1ee82d8c268: test(3)&gt; 2</span></span><br><span class="line"><span class="string">&lt;Greenlet at 0x1ee82d8c378: test(3)&gt; 0</span></span><br><span class="line"><span class="string">&lt;Greenlet at 0x1ee82d8c378: test(3)&gt; 1</span></span><br><span class="line"><span class="string">&lt;Greenlet at 0x1ee82d8c378: test(3)&gt; 2</span></span><br><span class="line"><span class="string">&lt;Greenlet at 0x1ee82d8c488: test(3)&gt; 0</span></span><br><span class="line"><span class="string">&lt;Greenlet at 0x1ee82d8c488: test(3)&gt; 1</span></span><br><span class="line"><span class="string">&lt;Greenlet at 0x1ee82d8c488: test(3)&gt; 2</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然在实际的代码里，我们不会用<code>gevent.sleep()</code>去切换协程，而是在执行到IO操作时gevent会自动完成，所以gevent需要将Python自带的一些标准库的运行方式由阻塞式调用变为协作式运行。这一过程在启动时通过monkey patch完成：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey; monkey.patch_all()</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">f"Get: <span class="subst">&#123;url&#125;</span>"</span>)</span><br><span class="line">    response = request.urlopen(url)</span><br><span class="line">    content = response.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    print(<span class="string">f"<span class="subst">&#123;len(content)&#125;</span> bytes received from <span class="subst">&#123;url&#125;</span>."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    gevent.joinall([</span><br><span class="line">        gevent.spawn(test, <span class="string">'http://httpbin.org/ip'</span>),</span><br><span class="line">        gevent.spawn(test, <span class="string">'http://httpbin.org/uuid'</span>),</span><br><span class="line">        gevent.spawn(test, <span class="string">'http://httpbin.org/user-agent'</span>)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果，3个网络操作是并发操作的，而且结束的顺序不同，但只有一个线程</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Get: http://httpbin.org/ip</span></span><br><span class="line"><span class="string">Get: http://httpbin.org/uuid</span></span><br><span class="line"><span class="string">Get: http://httpbin.org/user-agent</span></span><br><span class="line"><span class="string">46 bytes received from http://httpbin.org/ip.</span></span><br><span class="line"><span class="string">53 bytes received from http://httpbin.org/uuid.</span></span><br><span class="line"><span class="string">40 bytes received from http://httpbin.org/user-agent.</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="8-进程间通信"><a href="#8-进程间通信" class="headerlink" title="8. 进程间通信"></a>8. 进程间通信</h2><blockquote>
<p>Process之间肯定需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue/Pipes等多种方式来交换数据。</p>
</blockquote>
<h3 id="1-消息队列Queue"><a href="#1-消息队列Queue" class="headerlink" title="(1) 消息队列Queue"></a>(1) 消息队列Queue</h3><blockquote>
<p>简单的理解Queue实现进程间通信的方式，就是使用了操作系统给开辟的一个队列空间，各进程可以把数据放到该队列中，当然也可以从队列中把自己需要的信息取走。</p>
</blockquote>
<p><strong>Queue/queue模块常用属性</strong></p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="left"><strong><em>\</em>***Queue/queue模块的类*****</strong></td>
</tr>
<tr>
<td align="center"><code>Queue(maxsize=0)</code></td>
<td align="left">创建一个先入先出队列。如果给定最大值，这在队列没有空间阻塞；否则为无限队列</td>
</tr>
<tr>
<td align="center"><code>LifoQueue(maxsize=0)</code></td>
<td align="left">创建一个后入先出队列。如果给定最大值，这在队列没有空间阻塞；否则为无限队列</td>
</tr>
<tr>
<td align="center"><code>PriorityQueue(maxsize=0)</code></td>
<td align="left">创建一个优先级队列。如果给定最大值，这在队列没有空间阻塞；否则为无限队列</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><strong><em>\</em>***Queue/queue异常*****</strong></td>
</tr>
<tr>
<td align="center"><code>Empty</code></td>
<td align="left">当对空队列调用<code>get*()</code>方法时抛出异常</td>
</tr>
<tr>
<td align="center"><code>Full</code></td>
<td align="left">当对已满的队列调用<code>put*()</code>方法时抛出异常</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><strong><em>\</em>***Queue/queue对象方法*****</strong></td>
</tr>
<tr>
<td align="center"><code>qsize()</code></td>
<td align="left">返回队列大小（由于返回时队列大小可能被其他线程修改，所以该值为近似值）</td>
</tr>
<tr>
<td align="center"><code>empty()</code></td>
<td align="left">如果队列为空，则返回True；否则返回False</td>
</tr>
<tr>
<td align="center"><code>full()</code></td>
<td align="left">如果队列已满，则返回True；否则返回False</td>
</tr>
<tr>
<td align="center"><code>put(obj[, block=True[, timeout=None]])</code></td>
<td align="left">将obj放入队列，如果block参数为True时，一旦队列被写满，则代码就会被阻塞，知道有进程取走数据并腾出空间供obj使用；timeout参数用来设置阻塞的时间，即程序最多在阻塞timeout秒之后，如果还是没有空闲的空间，程序就会抛出<code>queue.Full</code>异常</td>
</tr>
<tr>
<td align="center"><code>put_nowait(obj)</code></td>
<td align="left">该方法等价于<code>put(obj, False)</code></td>
</tr>
<tr>
<td align="center"><code>get([block=True[, timeout=None]])</code></td>
<td align="left">从队列中取数据并返回，当block参数为True且timeout为None时，该方法会阻塞当前进程，知道队列中有可用的数据。如果block为False，则进程会直接做取数据的操作，如果取数据失败，则抛出<code>queue.Empty</code>异常（这种情形下timeout参数将不起作用）。如果设置timeout秒数，则当前进程最多被阻塞timeout秒，如果到时依旧没有可用的数据取出，则会抛出<code>queue.Empty</code>异常。</td>
</tr>
<tr>
<td align="center"><code>get_nowait()</code></td>
<td align="left">该方法等价于<code>get(False)</code></td>
</tr>
<tr>
<td align="center"><code>task_done()</code></td>
<td align="left">用于表示队列中的某个元素已执行完成，该放方法会被下面的<code>join()</code>使用</td>
</tr>
<tr>
<td align="center"><code>join()</code></td>
<td align="left">在队列中所有元素执行完毕并调用上面的<code>task_done()</code>信号钱，保持阻塞</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进程中消息队列读写数据</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">f"写进程：<span class="subst">&#123;os.getpid()&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'ABC'</span>:</span><br><span class="line">        print(<span class="string">f'正在往消息队列写入<span class="subst">&#123;i&#125;</span>'</span>)</span><br><span class="line">        q.put(i)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            i = q.get()</span><br><span class="line">            print(<span class="string">f"从消息队列中读出<span class="subst">&#123;i&#125;</span>"</span>)</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    pw.start()  <span class="comment"># 启动子进程pw，写入</span></span><br><span class="line">    pr.start()  <span class="comment"># 启动子进程pr，读取</span></span><br><span class="line">    pw.join()  <span class="comment"># 等待pw结束</span></span><br><span class="line">    pr.terminate()  <span class="comment"># pr进程里是死循环，无法等待期结束，只能强行终止</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">写进程：3808</span></span><br><span class="line"><span class="string">正在往消息队列写入A</span></span><br><span class="line"><span class="string">从消息队列中读出A</span></span><br><span class="line"><span class="string">正在往消息队列写入B</span></span><br><span class="line"><span class="string">从消息队列中读出B</span></span><br><span class="line"><span class="string">正在往消息队列写入C</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h3 id="2-管道Pipe"><a href="#2-管道Pipe" class="headerlink" title="(2) 管道Pipe"></a>(2) 管道Pipe</h3><blockquote>
<p>通常情况下，管道有两个口，而Pipe也常常用来实现两个进程间的通信，这两个进程分别位于管道的两端，一端用来发送数据，一段用来接收数据。使用Pipe实现进程通信，首先调用<code>multiprocessing.Pipe()</code>函数来创建一个管道。</p>
</blockquote>
<blockquote>
<p>该函数的语法格式如下：<code>conn1, conn2 = multiprocessing.Pipe([duplex=True])</code>，其中conn1和conn2分别用来接收Pipe函数返回的两个端口；duplex参数默认为True，表示该管道是双向的，即位于两个端口的进程既可以发送数据也可以接收数据，若<code>duplex=False</code>，则表示管道是单通道，conn1只能用来接收数据，而conn2只能用来发送数据。</p>
</blockquote>
<p><strong>Pipe对象可调用的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>send(obj)</code></td>
<td align="left">发送一个obj给管道的另一端，另一端使用<code>recv()</code>方法就收。该obj必须是可序列化的对象，如果该对象序列化后超过32MB，则很可能会引发ValueError异常。</td>
</tr>
<tr>
<td align="center"><code>recv()</code></td>
<td align="left">接受另一端通过<code>send()</code>方法发送过来的数据。</td>
</tr>
<tr>
<td align="center"><code>close()</code></td>
<td align="left">关闭连接。</td>
</tr>
<tr>
<td align="center"><code>poll([timeout])</code></td>
<td align="left">返回连接中是否还有数据可以读取。</td>
</tr>
<tr>
<td align="center"><code>send_bytes(buffer[, offset[, size]])</code></td>
<td align="left">发送直接数据，如果 没有指定offset、size参数，则默认发送buffer字节串的全部数据；如果指定offset和size参数，则发送buffer字节串中从offset开始、长度为size的直接数据；通过该方法发送的数据，应该使用<code>recv_bytes()</code>或<code>recv_bytes_info()</code>方法接收。</td>
</tr>
<tr>
<td align="center"><code>recv_bytes([maxlength])</code></td>
<td align="left">接收通过<code>send_bytes()</code>发送的数据，maxlength指定最多接收的字节数，该方法返回接收到的直接数据。</td>
</tr>
<tr>
<td align="center"><code>recv_bytes_info(buffer[, offset])</code></td>
<td align="left">功能类似于<code>recv_bytes()</code>方法类似，只是该方法将接收到的数据放在buffer中。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用Pipe管道实现2个进程之间通信</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processFun</span><span class="params">(conn, name)</span>:</span></span><br><span class="line">    print(multiprocessing.current_process().pid, <span class="string">"进程发送数据："</span>, name)</span><br><span class="line">    conn.send(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建管道</span></span><br><span class="line">    conn1, conn2 = multiprocessing.Pipe()</span><br><span class="line">    <span class="comment"># 创建子进程</span></span><br><span class="line">    p = multiprocessing.Process(target=processFun, args=(conn1, <span class="string">"http://www.baidu.com"</span>))</span><br><span class="line">    <span class="comment"># 启动子进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    print(multiprocessing.current_process().pid, <span class="string">"接收数据："</span>)</span><br><span class="line">    print(conn2.recv())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">5760 进程发送数据： http://www.baidu.com</span></span><br><span class="line"><span class="string">7760 接收数据：</span></span><br><span class="line"><span class="string">http://www.baidu.com</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h3 id="3-共享内存"><a href="#3-共享内存" class="headerlink" title="(3) 共享内存"></a>(3) 共享内存</h3><blockquote>
<p>共享内存是一种常用的，高效的进程之间的通信方式，为了保证共享内存的有序访问，需要对进程采取额外的同步措施。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> mmap</span><br><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> contextlib.closing(mmap.mmap(<span class="number">-1</span>, <span class="number">1024</span>, tagname=<span class="string">'cnblogs'</span>, access=mmap.ACCESS_WRITE)) <span class="keyword">as</span> mem:</span><br><span class="line">        <span class="keyword">for</span> share_data <span class="keyword">in</span> (<span class="string">"Hello"</span>, <span class="string">"Alpha_Panda"</span>):</span><br><span class="line">            mem.seek(<span class="number">0</span>)</span><br><span class="line">            print(<span class="string">'Write data:== %s == to share memory!'</span> % share_data)</span><br><span class="line">            mem.write(str.encode(share_data))</span><br><span class="line">            mem.flush()</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        invalid_byte, empty_byte = str.encode(<span class="string">'\x00'</span>), str.encode(<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">with</span> contextlib.closing(mmap.mmap(<span class="number">-1</span>, <span class="number">1024</span>, tagname=<span class="string">'cnblogs'</span>, access=mmap.ACCESS_READ)) <span class="keyword">as</span> mem:</span><br><span class="line">            share_data = mem.read(<span class="number">1024</span>).replace(invalid_byte, empty_byte)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> share_data:</span><br><span class="line">                <span class="comment"># 当共享内存没有有效数据时结束read</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            print(<span class="string">"Get data:== %s == from share memory!"</span> % share_data.decode())</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pr = Process(target=read, args=())</span><br><span class="line">    pw = Process(target=write, args=())</span><br><span class="line">    pw.start()</span><br><span class="line">    pr.start()</span><br><span class="line">    pw.join()</span><br><span class="line">    pr.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Write data:== Hello == to share memory!</span></span><br><span class="line"><span class="string">Get data:== Hello == from share memory!</span></span><br><span class="line"><span class="string">Write data:== Alpha_Panda == to share memory!</span></span><br><span class="line"><span class="string">Get data:== Alpha_Panda == from share memory!</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h3 id="4-信号量"><a href="#4-信号量" class="headerlink" title="(4) 信号量"></a>(4) 信号量</h3><blockquote>
<p>通信原理：给定一个数量对多个进程可见，多个进程都可以操作该数量增减，并根据数量值决定自己的行为。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实现方法：</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">from multiprocessing import Semaphore</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sem = Semaphore(num)</span></span><br><span class="line"><span class="string">功能 ： 创建信号量对象</span></span><br><span class="line"><span class="string">参数 ： 信号量的初始值</span></span><br><span class="line"><span class="string">返回值 ： 信号量对象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sem.acquire()  将信号量减1 当信号量为0时阻塞</span></span><br><span class="line"><span class="string">sem.release()  将信号量加1</span></span><br><span class="line"><span class="string">sem.get_value() 获取信号量数量</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Semaphore</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建信号量</span></span><br><span class="line">sem = Semaphore(<span class="number">3</span>)  <span class="comment"># 3表示服务程序最多允许三个进程同时执行事件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f"进程 <span class="subst">&#123;os.getpid()&#125;</span> 想执行事件"</span>)</span><br><span class="line">    <span class="comment"># 获取信号量</span></span><br><span class="line">    sem.acquire()  <span class="comment"># 减少信号量</span></span><br><span class="line">    print(<span class="string">f"进程 <span class="subst">&#123;os.getpid()&#125;</span> 开始执行操作"</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">f"睡眠了<span class="subst">&#123;end - start: <span class="number">.4</span>f&#125;</span>秒"</span>)</span><br><span class="line">    print(<span class="string">f"进程 <span class="subst">&#123;os.getpid()&#125;</span> 操作执行完毕"</span>)</span><br><span class="line">    sem.release()  <span class="comment"># 增加信号量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p = Process(target=foo, args=<span class="string">''</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">进程 4856 想执行事件</span></span><br><span class="line"><span class="string">进程 4856 开始执行操作</span></span><br><span class="line"><span class="string">睡眠了 3.0010秒</span></span><br><span class="line"><span class="string">进程 4856 操作执行完毕</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h3 id="5-socket套接字"><a href="#5-socket套接字" class="headerlink" title="(5) socket套接字"></a>(5) socket套接字</h3><blockquote>
<p>套接字无疑是通信使用最为广泛的方式了，socket不仅可以跨主机进行通信，甚至有时候可以使用socket在同一主机的不同进程间进行通信。</p>
</blockquote>
<blockquote>
<p>socket的语法：<code>socket = socket.socket(family, type[, protocal])</code>，family代表地址家族，一般为AF_UNIX，AF_INET和AF_INET6；AF_UNIX用于同一台机器上的进程通信，AF_INET用于IPV4协议的TCP/UDP，AF_INET6用于IPV6协议的TCP/UDP。type表示套接字类型，一般为SOCK_STREAM，SOCK_DGRAM和SOCK_RAM；SOCK_STREAM为流式套接字，用于TCP通信，SOCK_DGRAM为数据报式套接字，用于UDP通信，SOCK_RAM为原始套接字，可以用于处理ICMP/IGMP等网络报文，这是普通套接字无法处理的。protocal代表协议编号，默认为0。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、创建服务端的socket对象</span></span><br><span class="line">sk = socket.socket()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、绑定一个ip和端口</span></span><br><span class="line">sk.bind((<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、服务器端一直监听是否有客户端进行连接</span></span><br><span class="line">sk.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 4、如果有客户端进行连接、则接受客户端的连接</span></span><br><span class="line">    conn, addr = sk.accept() <span class="comment"># 返回客户端socket通信对象和客户端的ip</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5、客户端与服务端进行通信</span></span><br><span class="line">    rev_data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">'服务端收到客户端发来的消息:%s'</span> % (rev_data.decode(<span class="string">'GB2312'</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6、服务端给客户端回消息</span></span><br><span class="line">    conn.send(<span class="string">b"HTTP/1.1 200 OK \r\n\r\n"</span>)  <span class="comment"># http协议</span></span><br><span class="line">    show_str = <span class="string">"&lt;h1&gt; 这短短的一生，我们最终都会失去，你不妨大胆一些。爱一个人，攀一座山，追一个梦,加油 !!!&lt;/h1&gt;"</span></span><br><span class="line">    conn.send(show_str.encode(<span class="string">'GB2312'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 7、关闭socket对象</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>客户端可以自己写，也可以直接通过浏览器访问：<code>http://127.0.0.1:8888</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、创建socket通信对象</span></span><br><span class="line">clientSocket = socket.socket()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、使用正确的ip和端口去链接服务器</span></span><br><span class="line">clientSocket.connect((<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、客户端与服务器进行通信</span></span><br><span class="line"><span class="comment"># 给socket服务器发送信息</span></span><br><span class="line">send_data = <span class="string">"你拼命赚钱的样子虽然有些狼狈。但是自己靠自己的样子真的很美！加油"</span></span><br><span class="line">clientSocket.send(send_data.encode(<span class="string">"GB2312"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收服务器的响应（服务器回复的消息）</span></span><br><span class="line">recvData = clientSocket.recv(<span class="number">1024</span>).decode(<span class="string">"GB2312"</span>)</span><br><span class="line">print(<span class="string">"客户端收到服务器恢复的消息：%s"</span> % (recvData))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、关闭socket对象</span></span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure>

<h3 id="6-信号signal"><a href="#6-信号signal" class="headerlink" title="(6) 信号signal"></a>(6) 信号signal</h3><p><strong><a href="https://www.jianshu.com/p/ec4ca6235a77" target="_blank" rel="noopener">参考链接</a></strong></p>
<blockquote>
<p>信号是在软件层次上对中断机制的一种模拟（是由系统内核 发出，由于错误内存冲突等原因引起产生的），在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。信号机制经过POSIX（一个针对Unix操作系统的标准化协议）实时扩展后，功能更加强大，除了基本通知功能外，还可以传递附加信息。信号事件的发生有两个来源：硬件来源(比如我们按下了键盘或者其它硬件故障)；软件来源。</p>
</blockquote>
<blockquote>
<p>信号分为可靠信号和不可靠信号，实时信号和非实时信号。</p>
</blockquote>
<blockquote>
<p>进程有三种方式响应信号: 忽略信号、捕捉信号、执行默认操作。</p>
</blockquote>
<h2 id="9-线程间通信"><a href="#9-线程间通信" class="headerlink" title="9. 线程间通信"></a>9. 线程间通信</h2><h3 id="1-互斥锁"><a href="#1-互斥锁" class="headerlink" title="(1) 互斥锁"></a>(1) 互斥锁</h3><blockquote>
<p>互斥锁为资源引入一个状态：锁定/非锁定。某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">#创建锁</span></span><br><span class="line"><span class="string">mutex = threading.Lock()</span></span><br><span class="line"><span class="string">#锁定</span></span><br><span class="line"><span class="string">mutex.acquire([timeout])</span></span><br><span class="line"><span class="string">#释放</span></span><br><span class="line"><span class="string">mutex.release()</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">money = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> money</span><br><span class="line">    money = money + n</span><br><span class="line">    money = money - n</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, thread_name)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self, name=<span class="string">'线程'</span> + thread_name)</span><br><span class="line">        self.thread_name = int(thread_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">            lock.acquire()  <span class="comment"># 加锁</span></span><br><span class="line">            order(self.thread_name)</span><br><span class="line">            lock.release()  <span class="comment"># 释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    t1 = MyThread(<span class="string">'1'</span>)</span><br><span class="line">    t2 = MyThread(<span class="string">'10'</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    print(money)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了支持在同一线程中多次请求同一资源，python提供了“可重入锁”：threading.RLock。RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次acquire。直到一个线程所有的acquire都被release，其他的线程才能获得资源。acquire() 和 release() 必须成对出现，也就是说加了几把锁就得释放几把锁。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">mutex = threading.RLock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> num</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mutex.acquire():</span><br><span class="line">            num = num + <span class="number">1</span></span><br><span class="line">            msg = self.name + <span class="string">'set num to'</span> + str(num)</span><br><span class="line">            print(msg)</span><br><span class="line">            mutex.acquire()</span><br><span class="line">            mutex.release()</span><br><span class="line">            mutex.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Thread-1set num to1</span></span><br><span class="line"><span class="string">Thread-4set num to2</span></span><br><span class="line"><span class="string">Thread-3set num to3</span></span><br><span class="line"><span class="string">Thread-2set num to4</span></span><br><span class="line"><span class="string">Thread-5set num to5</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h3 id="2-信号量"><a href="#2-信号量" class="headerlink" title="(2) 信号量"></a>(2) 信号量</h3><blockquote>
<p>在多线程编程中，为了防止不同的线程同时对一个公用的资源（比如全部变量）进行修改，需要进行同时访问的数量（通常是1）的限制。信号量同步基于内部计数器，每调用一次acquire()，计数器减1；每调用一次release()，计数器加1.当计数器为0时，acquire()调用被阻塞。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Semaphore, Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建信号量</span></span><br><span class="line">sema = Semaphore(<span class="number">3</span>)  <span class="comment"># 限制同时访问资源的数量为3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(tid)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> sema:</span><br><span class="line">        print(<span class="string">f"<span class="subst">&#123;tid&#125;</span> acquire sema"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">f"<span class="subst">&#123;tid&#125;</span> release sema"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    t = Thread(target=foo, args=(i,))</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0 acquire sema</span></span><br><span class="line"><span class="string">1 acquire sema</span></span><br><span class="line"><span class="string">2 acquire sema</span></span><br><span class="line"><span class="string">1 release sema3 acquire sema</span></span><br><span class="line"><span class="string">0 release sema</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4 acquire sema</span></span><br><span class="line"><span class="string">2 release sema</span></span><br><span class="line"><span class="string">3 release sema</span></span><br><span class="line"><span class="string">4 release sema</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h3 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="(3) 条件变量"></a>(3) 条件变量</h3><blockquote>
<p>条件变量可以认为是更高级的锁，比Lock和Rlock的用法更高级，能处理一些复杂的线程同步问题。threading.Condition() 创建一把资源锁（默认是Rlock），提供 acquire() 和 release() 方法，用法和 Rlock 一致。此外 Condition 还提供 wait()、Notify() 和 NotifyAll() 方法。</p>
</blockquote>
<blockquote>
<p>wait()：线程挂起，直到收到一个 Notify() 通知或者超时（可选参数），wait() 必须在线程得到 Rlock 后才能使用。</p>
</blockquote>
<blockquote>
<p>Notify() ：在线程挂起的时候，发送一个通知，让 wait() 等待线程继续运行，Notify() 也必须在线程得到 Rlock 后才能使用。 Notify(n=1)，最多唤醒 n 个线程。</p>
</blockquote>
<blockquote>
<p>NotifyAll() ：在线程挂起的时候，发送通知，让所有 wait() 阻塞的线程都继续运行。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_a</span><span class="params">()</span>:</span></span><br><span class="line">    condition.acquire()</span><br><span class="line">    print(<span class="string">"李白：中路团一波，推塔"</span>)</span><br><span class="line">    condition.wait()</span><br><span class="line">    print(<span class="string">"李白：好的"</span>)</span><br><span class="line">    condition.notify()</span><br><span class="line">    condition.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_b</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    condition.acquire()</span><br><span class="line">    print(<span class="string">"武则天：等我大冷却"</span>)</span><br><span class="line">    condition.notify()</span><br><span class="line">    condition.wait()</span><br><span class="line">    print(<span class="string">"武则天：我的大好了，干干干"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    condition = threading.Condition()</span><br><span class="line">    ta = threading.Thread(target=test_a)</span><br><span class="line">    tb = threading.Thread(target=test_b)</span><br><span class="line">    ta.start()</span><br><span class="line">    tb.start()</span><br><span class="line">    ta.join()</span><br><span class="line">    tb.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">李白：中路团一波，推塔</span></span><br><span class="line"><span class="string">武则天：等我大冷却</span></span><br><span class="line"><span class="string">李白：好的</span></span><br><span class="line"><span class="string">武则天：我的大好了，干干干</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h3 id="4-事件"><a href="#4-事件" class="headerlink" title="(4) 事件"></a>(4) 事件</h3><blockquote>
<p>线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其他线程需要通过断某个线程的状态来确定自己下一步的操作，这时线程同步问题就会变得非常棘手。为了解决这些问题，我们需要使用 threading 库中的 Event 对象。Event 对象包含一个可由线程设置的信号标志，它允许线程等待某些事件的发生。在初始情况下，event 对象中的信号标志被设置假。如果有线程等待一个 event 对象，而这个 event 对象的标志为假，那么这个线程将会被一直阻塞，直至该标志为真。一个线程如果将一个 event 对象的信号标志设置为真，它将唤醒所有等待这个 event 对象的线程。如果一个线程等待一个已经被设置为真的 event 对象，那么它将忽略这个事件，继续执行。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">event.wait(): 阻塞线程，知道flag值变为True</span></span><br><span class="line"><span class="string">event.set(): 设置flag值为True</span></span><br><span class="line"><span class="string">event.clear(): 修改flag值为False</span></span><br><span class="line"><span class="string">event.isSet()：仅当flag值为True时返回</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 主线程启动子线程后sleep两秒，子线程因为event.wait()被阻塞，当主线程醒来后执行event.set()，子线程才继续运行，两者输出时间差2s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, thread_name)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self, name=<span class="string">'线程'</span> + thread_name)</span><br><span class="line">        self.thread_name = int(thread_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        event.wait()</span><br><span class="line">        print(<span class="string">f"子线程运行时间: <span class="subst">&#123;datetime.datetime.now()&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line">    t1 = thread(<span class="string">'0'</span>)</span><br><span class="line">    t1.start()  <span class="comment"># 启动子线程</span></span><br><span class="line">    print(<span class="string">f"主线程运行时间：<span class="subst">&#123;datetime.datetime.now()&#125;</span>"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    event.set()  <span class="comment"># flag设置为True</span></span><br><span class="line">    t1.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">主线程运行时间：2020-06-15 21:44:54.221804</span></span><br><span class="line"><span class="string">子线程运行时间: 2020-06-15 21:44:56.222719</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h3 id="5-消息队列"><a href="#5-消息队列" class="headerlink" title="(5) 消息队列"></a>(5) 消息队列</h3><blockquote>
<p>使用线程队列有一个要注意的问题是，向队列中添加数据项时并不会复制此数据项，线程间通信实际上是在线程间传递对象引用。如果你担心对象的共享状态，那你最好只传递不可修改的数据结构（如：整型、字符串或者元组）或者一个对象的深拷贝。</p>
</blockquote>
<blockquote>
<p>在一个进程中，不同子线程负责不同的任务，t1子线程负责获取到数据，t2子线程负责把数据保存的本地，那么他们之间的通信使用Queue来完成。因为在一个进程中，数据变量是共享的，即多个子线程可以对同一个全局变量进行操作修改，Queue是加了锁的安全消息队列。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设需要爬取博客网站的所有文章详情，先要通过文章列表页爬取所有文章的url，再根据文章的url，爬取文章的具体内容</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬取文章详情页</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_html</span><span class="params">(detail_url_list, id)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        url = detail_url_list.get()</span><br><span class="line">        time.sleep(<span class="number">2</span>)  <span class="comment"># 延时2s，模拟网络请求</span></span><br><span class="line">        print(<span class="string">"thread &#123;id&#125;: get &#123;url&#125; detail finished "</span>.format(id=id,url=url))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬取文章列表页</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_url</span><span class="params">(queue)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>) <span class="comment"># 延时1s，模拟比爬取文章详情要快</span></span><br><span class="line">        queue.put(<span class="string">"http://projectedu.com/&#123;id&#125;"</span>.format(id=i))</span><br><span class="line">        print(<span class="string">"get detail url &#123;id&#125; end"</span>.format(id=i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    detail_url_queue = Queue(maxsize=<span class="number">1000</span>)</span><br><span class="line">    <span class="comment"># 先创造两个线程</span></span><br><span class="line">    thread = threading.Thread(target=get_detail_url, args=(detail_url_queue,))</span><br><span class="line">    html_thread= []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        thread2 = threading.Thread(target=get_detail_html, args=(detail_url_queue,i))</span><br><span class="line">        html_thread.append(thread2)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="comment"># 启动两个线程</span></span><br><span class="line">    thread.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        html_thread[i].start()</span><br><span class="line">    <span class="comment"># 等待所有线程结束</span></span><br><span class="line">    thread.join()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        html_thread[i].join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"last time: &#123;&#125; s"</span>.format(time.time()-start_time))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">get detail url 0 end</span></span><br><span class="line"><span class="string">get detail url 1 end</span></span><br><span class="line"><span class="string">thread 0: get http://projectedu.com/0 detail finished </span></span><br><span class="line"><span class="string">get detail url 2 end</span></span><br><span class="line"><span class="string">thread 1: get http://projectedu.com/1 detail finished </span></span><br><span class="line"><span class="string">get detail url 3 end</span></span><br><span class="line"><span class="string">thread 2: get http://projectedu.com/2 detail finished </span></span><br><span class="line"><span class="string">get detail url 4 end</span></span><br><span class="line"><span class="string">thread 0: get http://projectedu.com/3 detail finished </span></span><br><span class="line"><span class="string">get detail url 5 end</span></span><br><span class="line"><span class="string">thread 1: get http://projectedu.com/4 detail finished </span></span><br><span class="line"><span class="string">get detail url 6 end</span></span><br><span class="line"><span class="string">thread 2: get http://projectedu.com/5 detail finished </span></span><br><span class="line"><span class="string">get detail url 7 end</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="10-孤儿进程、僵尸进程、守护进程"><a href="#10-孤儿进程、僵尸进程、守护进程" class="headerlink" title="10. 孤儿进程、僵尸进程、守护进程"></a>10. 孤儿进程、僵尸进程、守护进程</h2><blockquote>
<p>孤儿进程：父进程退出，子进程还在运行这些子进程都是孤儿进程，孤儿进程将被init进程（进程号为1）说收养，并由init进程对他们完成状态收集工作。</p>
</blockquote>
<blockquote>
<p>僵尸进程：进程使用fork创建子进程，如果进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的描述符仍然保存在系统中，这些进程就是僵尸进程。避免僵尸进程的方法：</p>
</blockquote>
<ul>
<li>fork两次用孙子进程去完成子进程的任务；</li>
<li>用wait()函数使父进程阻塞；</li>
<li>使用信号量，在signal handler中调用waitpid，这样父进程不用阻塞。</li>
</ul>
<blockquote>
<p>守护进程：就是会随着主进程结束而结束的进程，主进程代码执行结束后就终止，而且守护进程内无法开启子进程，否则抛出异常。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f"进程为<span class="subst">&#123;os.getpid()&#125;</span>，父进程为<span class="subst">&#123;os.getppid()&#125;</span>"</span>)</span><br><span class="line">        print(<span class="string">f"我的名字是<span class="subst">&#123;self.name&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p1 = MyProcess(<span class="string">"张三"</span>)</span><br><span class="line">    p2 = MyProcess(<span class="string">"李四"</span>)</span><br><span class="line">    p2.daemon = <span class="literal">True</span>  <span class="comment"># 默认为False，必须在start()之前上设置</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"主进程结束"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">进程为436，父进程为11972</span></span><br><span class="line"><span class="string">我的名字是张三</span></span><br><span class="line"><span class="string">进程为12140，父进程为11972</span></span><br><span class="line"><span class="string">我的名字是李四</span></span><br><span class="line"><span class="string">主进程结束</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="11-进程池"><a href="#11-进程池" class="headerlink" title="11. 进程池"></a>11. 进程池</h2><p><strong><a href="https://blog.csdn.net/brucewong0516/article/details/85788202" target="_blank" rel="noopener">Pool进程池模块</a></strong></p>
<blockquote>
<p>Multiprocessing.Pool可以提供指定数量的进程供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行它。Pool类用于需要执行的目标很多，而手动限制进程数量又太繁琐时，如果目标少且不用控制进程数量则可以用Process类。</p>
</blockquote>
<blockquote>
<p>进程池Pool语法：<code>Pool([processes[, initializer[, initargs[, maxtasksperchild[, context]]]]])</code></p>
</blockquote>
<ul>
<li>processes: 进程数，由CPU个数决定，不能操作CPU总数；如果进程是None，那么返回的数字<code>os.cpu_count()</code>。</li>
<li>initializer: 如果是None，那么每一个工作进程在开始会调用<code>initialize(*initargs)</code>。</li>
<li>maxtasksperchild: 工作进程退出前可以完成的任务数，完成后用一个新的工作进程来代替原进程，让闲置下来的资源被释放。默认值为None，表示只要Pool存在工作进程就回一直存活。</li>
<li>context: 用在只当工作进程启动时的上下文，一般使用<code>multiprocessing.Pool()</code>或者一个<code>context()</code>对象的<code>Pool()</code>方法来创建一个池。</li>
</ul>
<blockquote>
<p>multiprocessing 模块下的Pool类下的方法：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>apply(func[, args=()[, kwargs={}]])</code></td>
<td align="left">该函数用于传递不定参数，和python中的apply函数一致，主进程会被阻塞知道函数执行结束（不建议使用，python3已经移除）。</td>
</tr>
<tr>
<td align="center"><code>apply_async(func[, args=()[, kwargs={}[, callback[, error_callback]]]])</code></td>
<td align="left">与apply的用法一致，但是它是非阻塞的且支持结果返回后进行回调，调用失败，将调用<code>error_callback</code>。</td>
</tr>
<tr>
<td align="center"><code>map(func, iterable[, chunksize=None])</code></td>
<td align="left">Pool类中的map方法，与内置的map函数用法基本一致，它会使进程阻塞知道结果返回。（注意：虽然第二个参数是一个迭代器，但在实际使用中，必须在整个队列都就绪后，程序才会运行子进程。）</td>
</tr>
<tr>
<td align="center"><code>map_async(func, iterable[, chunksize[, callback[, error_callback]]])</code></td>
<td align="left">与map用法一致，但是它是非阻塞的。</td>
</tr>
<tr>
<td align="center"><code>imap(func, iterable[, chunksize])</code></td>
<td align="left">返回迭代器，<code>next()</code>调用返回的迭代器的方法得到结果，<code>imap()</code>方法有一个可选的超时参数：<code>next(timeout)</code>将引发<code>multiprocessing.TimeoutError</code>异常</td>
</tr>
<tr>
<td align="center"><code>close()</code></td>
<td align="left">防止任何更多的任务被提交到进程池中，一旦完成所有任务，工作进程将退出。</td>
</tr>
<tr>
<td align="center"><code>terminate()</code></td>
<td align="left">立即停止工作进程未完成的工作，当进程池对象被垃圾回收时，<code>terminate()</code>将立即调用。</td>
</tr>
<tr>
<td align="center"><code>join()</code></td>
<td align="left">等待工作进程退出，必须在<code>close()</code>或<code>terminate()</code>使用之前<code>join()</code>。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(fn)</span>:</span>  <span class="comment"># fn函数参数是数据列表的一个元素</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(fn * fn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    print(<span class="string">"执行顺序："</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">for</span> fn <span class="keyword">in</span> s:</span><br><span class="line">        run(fn)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">f"顺序执行时间：<span class="subst">&#123;end-start:<span class="number">.2</span>f&#125;</span>"</span>)</span><br><span class="line">    print(<span class="string">"创建多个进程："</span>)</span><br><span class="line">    pool = Pool(<span class="number">10</span>)  <span class="comment"># 创建拥有10个进程数量的进程池</span></span><br><span class="line">    pool.map(run, s)</span><br><span class="line">    pool.close()  <span class="comment"># 关闭进程池，不在接收新的进程</span></span><br><span class="line">    pool.join()  <span class="comment"># 主进程阻塞等待子进程退出</span></span><br><span class="line">    t = time.time()</span><br><span class="line">    print(<span class="string">f"并行执行时间：<span class="subst">&#123;t-end:<span class="number">.2</span>f&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行顺序：</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">16</span></span><br><span class="line"><span class="string">25</span></span><br><span class="line"><span class="string">36</span></span><br><span class="line"><span class="string">顺序执行时间：6.00</span></span><br><span class="line"><span class="string">创建多个进程：</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">16</span></span><br><span class="line"><span class="string">25</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">36</span></span><br><span class="line"><span class="string">并行执行时间：3.31</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="12-守护线程"><a href="#12-守护线程" class="headerlink" title="12. 守护线程"></a>12. 守护线程</h2><blockquote>
<p>守护线程：当主线程结束后，子线程也会随之结束，所以当主线程结束后，整个程序就退出了。所谓“线程守护”，就是主线程不管该线程的执行情况，只要是其他子线程结束且主线程执行完毕，主线程都会关闭。也就是说：主线程不等待该守护线程的执行完再去关闭。</p>
</blockquote>
<blockquote>
<p>守护线程的作用：是为其他线程提供便利服务，守护线程最典型的应用就是GC。</p>
</blockquote>
<blockquote>
<p>守护线程的特点：</p>
</blockquote>
<ul>
<li>只要当前主线程中尚存在任何一个非守护线程没有结束，守护线程就继续工作；</li>
<li>只有当最后一个非守护线程结束时，守护线程才随着主线程一同结束工作。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  线程不是守护线程</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start fun"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end fun"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"main thread"</span>)</span><br><span class="line">    t1 = threading.Thread(target=fun,args=())</span><br><span class="line">    t1.setDaemon(<span class="literal">False</span>)  <span class="comment"># 非守护线程</span></span><br><span class="line">    t1.start()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"main thread end"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果，主程序在等待子线程结束才退出</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">main thread</span></span><br><span class="line"><span class="string">start fun</span></span><br><span class="line"><span class="string">main thread end</span></span><br><span class="line"><span class="string">end fun</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 线程是守护线程</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start fun"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end fun"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"main thread"</span>)</span><br><span class="line">    t1 = threading.Thread(target=fun,args=())</span><br><span class="line">    t1.setDaemon(<span class="literal">True</span>)  <span class="comment"># 守护线程</span></span><br><span class="line">    t1.start()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"main thread end"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果，程序在主程序结束后，直接退出。没有等待子线程运行完</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">main thread</span></span><br><span class="line"><span class="string">start fun</span></span><br><span class="line"><span class="string">main thread end</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多线程情况下</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start fun"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end fun"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start foo"</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"end foo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"main thread"</span>)</span><br><span class="line">    t1 = threading.Thread(target=fun,args=())</span><br><span class="line">    t2 = threading.Thread(target=foo,args=())</span><br><span class="line">    t1.setDaemon(<span class="literal">True</span>)  <span class="comment"># 守护线程</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"main thread end"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果，程序在主程序结束后，等待非守护线程的foo执行完，才退出。而没有等待守护线程func运行完</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">main thread</span></span><br><span class="line"><span class="string">start fun</span></span><br><span class="line"><span class="string">start foo</span></span><br><span class="line"><span class="string">main thread end</span></span><br><span class="line"><span class="string">end foo</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="13-线程池"><a href="#13-线程池" class="headerlink" title="13. 线程池"></a>13. 线程池</h2><p><strong><a href="https://www.cnblogs.com/hoojjack/p/10846010.html" target="_blank" rel="noopener">PYTHON线程池及其原理和使用</a></strong></p>
<blockquote>
<p>系统启动一个新线程的成本是比较高的，因为它涉及与操作系统的交互。这种情形下，使用线程池可以很好地性能，尤其是当程序中需要大量存活期很短暂的线程时，更应该考虑使用线程池。</p>
</blockquote>
<blockquote>
<p>线程池在系统启动时创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它。当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。</p>
</blockquote>
<blockquote>
<p>此外，使用线程池可以有效控制系统中并发线程的数量。当西戎中包含有大量的并发线程时，会导致系统性能急剧下降，甚至导致Python解释器崩溃，而线程池的最大线程数参数可以控制系统中并发线程的数量不超过此数。</p>
</blockquote>
<p><strong>线程池的使用</strong></p>
<blockquote>
<p>线程池的基类是<code>concurrent.futures</code>模块中的<code>Executor</code>，包含两个子类：<code>ThreadPoolExecutor</code>（用于创建线程池），<code>ProcessPoolExecutor</code>用于创建进程池。</p>
</blockquote>
<blockquote>
<p><code>Executor</code>中的常用方法：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>submit(func, *args, **kwargs)</code></td>
<td align="left">将函数func提交给线程池，<code>*args</code>表示传给func函数的参数，<code>**kwargs</code>表示以关键字形式给func传参</td>
</tr>
<tr>
<td align="center"><code>map(func, *iterables, timeout=None, chunksize=1)</code></td>
<td align="left">该函数类似于python中的map()函数的用法，只是个该函数将会启动多个线程，以异步的方式立即对可迭代对象iterables进行map处理</td>
</tr>
<tr>
<td align="center"><code>shutdown(wait=True)</code></td>
<td align="left">关闭线程池，不再接受性任务，会将以前所有提交的任务执行完成</td>
</tr>
</tbody></table>
<blockquote>
<p>程序task函数提交(submit)给线程池后，submit方法会返回一个Future对象，Future类主要用于获取线程任务函数的返回值。由于线程任务会在新线程中以异步的方式执行，因此，线程执行的函数相当于一个“将来完成”的任务，所以Python使用Future来代表。</p>
</blockquote>
<blockquote>
<p><code>Future</code>中的常用方法：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>cancel()</code></td>
<td align="left">取消该Future代表的线程任务，若该任务正在执行，不可取消，返回False；否则，程序会取消该任务，并返回True</td>
</tr>
<tr>
<td align="center"><code>cancelled()</code></td>
<td align="left">返回Future代表的线程任务是否被成功取消</td>
</tr>
<tr>
<td align="center"><code>running()</code></td>
<td align="left">若该Future代表的线程任务正在执行，不可取消，该方法返回True</td>
</tr>
<tr>
<td align="center"><code>done()</code></td>
<td align="left">若该Future代表的线程任务被成功取消或者执行完成，该方法返回True</td>
</tr>
<tr>
<td align="center"><code>result(timeout=None)</code></td>
<td align="left">获取该Future代表的线程任务最后的返回的结果，若任务还未完成，该方法将会阻塞当前线程，其中timeout参数指定阻塞持续时间</td>
</tr>
<tr>
<td align="center"><code>exception(timeout=None)</code></td>
<td align="left">获取该Future代表的线程任务说引发的异常，若任务成功完成，且没有异常，该方法返回None</td>
</tr>
<tr>
<td align="center"><code>add_done_callback(func)</code></td>
<td align="left">为该Future代表的线程任务注册一个”回调函数”，当该任务成功完成时，程序会自动触发func函数 ,并将对应的 Future 对象作为参数传给该回调函数</td>
</tr>
</tbody></table>
<p><strong>使用线程池来执行线程任务的步骤：</strong></p>
<ul>
<li>调用<code>ThreadPoolExecutor</code>类的构造器创建一个线程池；</li>
<li>定义一个普通函数作为线程任务；</li>
<li>调用<code>ThreadPoolExecutor</code>对象的<code>submit()</code>方法来提交线程任务；</li>
<li>当不想提交任何任务时，调用<code>ThreadPoolExecutor</code>对象的<code>shutdown()</code>方法来关闭线程池</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个线程任务函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    print(<span class="string">f"<span class="subst">&#123;threading.current_thread().name&#125;</span> is running, x=<span class="subst">&#123;x&#125;</span>, y=<span class="subst">&#123;y&#125;</span>."</span>)</span><br><span class="line">    <span class="comment"># time.sleep(2)</span></span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_result</span><span class="params">(future)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    如果程序不希望直接调用 result() 方法阻塞线程，则可通过 Future 的 add_done_callback() 方法来添加回调函数，该回调函数形如 fn(future)。当线程任务完成后，程序会自动触发该回调函数，并将对应的 Future 对象作为参数传给该回调函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(future.result())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个包含2个子线程的线程池，且线程名为以“thread_”开头</span></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=<span class="number">2</span>, thread_name_prefix=<span class="string">"thread_"</span>)</span><br><span class="line">    <span class="comment"># 向线程池提交一个task</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        future = pool.submit(func, i, i+<span class="number">1</span>)</span><br><span class="line">        print(future.done())</span><br><span class="line">        future.add_done_callback(get_result)</span><br><span class="line">    pool.shutdown(wait=<span class="literal">True</span>)</span><br><span class="line">    print(<span class="string">'process finished'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    process()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">thread__0 is running, x=0, y=1.</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">thread__0 is running, x=1, y=2.</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">thread__0 is running, x=2, y=3.</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">thread__1 is running, x=3, y=4.</span></span><br><span class="line"><span class="string">12</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">thread__0 is running, x=4, y=5.</span></span><br><span class="line"><span class="string">20</span></span><br><span class="line"><span class="string">process finished</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">使用 with 语句来管理线程池，这样即可避免手动关闭线程池，通过Exectuor里的map()方法，为 iterables 的每个元素启动一个线程，以并发方式来执行 action 函数，并收集线程任务的返回值</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个准备作为线程任务的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(max)</span>:</span></span><br><span class="line">    my_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max):</span><br><span class="line">        print(threading.current_thread().name + <span class="string">'  '</span> + str(i))</span><br><span class="line">        my_sum += i</span><br><span class="line">    <span class="keyword">return</span> my_sum</span><br><span class="line"><span class="comment"># 创建一个包含4条线程的线程池</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> pool:</span><br><span class="line">    <span class="comment"># 使用线程执行map计算</span></span><br><span class="line">    <span class="comment"># 后面元组有3个元素，因此程序启动3条线程来执行action函数</span></span><br><span class="line">    results = pool.map(action, (<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>))</span><br><span class="line">    print(<span class="string">'--------------'</span>)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> results:</span><br><span class="line">        print(r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">ThreadPoolExecutor-0_0  0</span></span><br><span class="line"><span class="string">ThreadPoolExecutor-0_0  1</span></span><br><span class="line"><span class="string">ThreadPoolExecutor-0_0  2</span></span><br><span class="line"><span class="string">ThreadPoolExecutor-0_0  0</span></span><br><span class="line"><span class="string">ThreadPoolExecutor-0_0  1</span></span><br><span class="line"><span class="string">ThreadPoolExecutor-0_0  2</span></span><br><span class="line"><span class="string">ThreadPoolExecutor-0_0  3</span></span><br><span class="line"><span class="string">ThreadPoolExecutor-0_0  4</span></span><br><span class="line"><span class="string">ThreadPoolExecutor-0_0  0</span></span><br><span class="line"><span class="string">ThreadPoolExecutor-0_0  1</span></span><br><span class="line"><span class="string">ThreadPoolExecutor-0_0  2</span></span><br><span class="line"><span class="string">ThreadPoolExecutor-0_0  3</span></span><br><span class="line"><span class="string">ThreadPoolExecutor-0_0  4</span></span><br><span class="line"><span class="string">ThreadPoolExecutor-0_0  5</span></span><br><span class="line"><span class="string">ThreadPoolExecutor-0_0  6</span></span><br><span class="line"><span class="string">--------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">21</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p><strong>线程池的优点：</strong></p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h2 id="14-线程安全"><a href="#14-线程安全" class="headerlink" title="14. 线程安全"></a>14. 线程安全</h2><blockquote>
<p>线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问知道该线程读完，其他线程才能使用，这样就不会出现数据不一致或数据污染。</p>
</blockquote>
<blockquote>
<p>当多个线程访问某个方法时，不管通过怎样的调用方式或说这些线程如何交替执行，在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正切行为，那么我们就可以说这个类是线程安全的。</p>
</blockquote>
<h2 id="15-多线程资源竞争，怎么解决"><a href="#15-多线程资源竞争，怎么解决" class="headerlink" title="15. 多线程资源竞争，怎么解决"></a>15. 多线程资源竞争，怎么解决</h2><blockquote>
<p>线程是独立的，同一个进程里线程的数据共享的，当各个线程访问数据资源时会出现竞争状态，即数据几乎同时被多个线程占用，造成数据混乱，所谓的线程的不安全。</p>
</blockquote>
<blockquote>
<p>添加锁，确保了某段关键代码（共享数据资源）只能由一个线程从头到尾完整地执行，则能够解决多线程资源进程下原子操作的问题；但是添加锁阻止了多线程并发操作，包含锁的某段代码实际上只能以单线程模式执行，效率就大大下降；其次，由于可以存在多个锁，不同的线程持有不同的说，并试图获取对方持有的锁时，可能造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p>
</blockquote>
<h2 id="16-有几种锁"><a href="#16-有几种锁" class="headerlink" title="16. 有几种锁"></a>16. 有几种锁</h2><ul>
<li>互斥锁</li>
</ul>
<blockquote>
<p>在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为” 互斥锁” 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。同一个进行中的多线程是共享系统资源的,，多个线程同时对一个对象进行操作，一个线程操作尚未结束，另一个线程已经对其进行操作，导致最终结果出现错误，此时需要对被操作对象添加互斥锁，保证每个线程对该对象的操作都得到正确的结果。</p>
</blockquote>
<ul>
<li>可重入锁</li>
</ul>
<blockquote>
<p>可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。换一种说法，同一个线程再次进入同步代码时，可以使用自己已获取到的锁，防止在同一线程中多次获取锁而导致死锁发生。</p>
</blockquote>
<ul>
<li>死锁</li>
</ul>
<blockquote>
<p>若干个线程资源竞争时，都在等待对方对某部分资源解除占用状态，结果谁也不愿意先解锁，互相干等着，程序无法执行下去，这就是死锁。</p>
</blockquote>
<h2 id="17-调度算法"><a href="#17-调度算法" class="headerlink" title="17. 调度算法"></a>17. 调度算法</h2><p><strong><a href="https://www.jianshu.com/p/6edf8174c1eb" target="_blank" rel="noopener">常见的调度算法总结</a></strong></p>
<h3 id="1-先来先服务-FCFS-First-Come-First-Service"><a href="#1-先来先服务-FCFS-First-Come-First-Service" class="headerlink" title="(1) 先来先服务(FCFS, First Come First Service)"></a>(1) 先来先服务(FCFS, First Come First Service)</h3><blockquote>
<p>先来先服务（FCFS）调度算法是一种最简单的调度算法，该算法既可用于作业调度， 也可用于进程调度。FCFS算法比较有利于长作业（进程），而不利于短作业（进程）。由此可知，本算法适合于CPU繁忙型作业， 而不利于I/O繁忙型的作业（进程）。</p>
</blockquote>
<h3 id="2-短作业优先-SJF-Shortest-Job-First"><a href="#2-短作业优先-SJF-Shortest-Job-First" class="headerlink" title="(2) 短作业优先(SJF, Shortest Job First)"></a>(2) 短作业优先(SJF, Shortest Job First)</h3><blockquote>
<p>短作业（进程）优先调度算法（SJ/PF）是指对短作业或短进程优先调度的算法，该算法既可用于作业调度， 也可用于进程调度。但其对长作业不利；不能保证紧迫性作业（进程）被及时处理；作业的长短只是被估算出来的。</p>
</blockquote>
<h3 id="3-最高优先权调度-Priority-Scheduling"><a href="#3-最高优先权调度-Priority-Scheduling" class="headerlink" title="(3) 最高优先权调度(Priority Scheduling)"></a>(3) 最高优先权调度(Priority Scheduling)</h3><blockquote>
<p>为了照顾紧迫性作业，使之进入系统后便获得优先处理，引入了最高优先权优先（FPF）调度算法。 此算法常被用在批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度，还可以用于实时系统中。当其用于作业调度， 将后备队列中若干个优先权最高的作业装入内存。当其用于进程调度时，把处理机分配给就绪队列中优先权最高的进程，此时， 又可以进一步把该算法分成以下两种：</p>
</blockquote>
<ul>
<li>非抢占式优先权算法</li>
<li>抢占式优先权算法（高性能计算机系统）</li>
</ul>
<blockquote>
<p>高响应比优先调度算法为了弥补短作业优先算法的不足，我们引入动态优先权，使作业的优先等级随着等待时间的增加而以速率a提高。 该优先权变化规律可描述为：优先权=（等待时间+要求服务时间）/要求服务时间 =（响应时间）/要求服务时间</p>
</blockquote>
<h3 id="4-时间片轮转-RR-Round-Robin"><a href="#4-时间片轮转-RR-Round-Robin" class="headerlink" title="(4) 时间片轮转(RR, Round Robin)"></a>(4) 时间片轮转(RR, Round Robin)</h3><blockquote>
<p>时间片轮转法一般用于进程调度，每次调度，把CPU分配队首进程，并令其执行一个时间片。 当执行的时间片用完时，由一个记时器发出一个时钟中断请求，该进程被停止，并被送往就绪队列末尾；依次循环。</p>
</blockquote>
<h3 id="5-多级反馈队列调度-Multilevel-Feedback-Queue-Scheduling"><a href="#5-多级反馈队列调度-Multilevel-Feedback-Queue-Scheduling" class="headerlink" title="(5) 多级反馈队列调度(Multilevel Feedback Queue Scheduling)"></a>(5) 多级反馈队列调度(Multilevel Feedback Queue Scheduling)</h3><blockquote>
<p>多级反馈队列调度算法多级反馈队列调度算法，不必事先知道各种进程所需要执行的时间，它是目前被公认的一种较好的进程调度算法。其实施过程如下：</p>
</blockquote>
<ul>
<li>设置多个就绪队列，并为各个队列赋予不同的优先级，在优先权越高的队列中，为每个进程所规定的的执行时间片就越小；</li>
<li>当一个新进程进入内存后，首先放入第一队列的末尾，按FCFC原则排队等候调度。如果它能在一个时间片中完成，便可撤离；如果未完成，就转入第二队列的末尾，在同样等待调度…如此下去，当一个长作业（进程）从第一队列一次将到第n队列（最后队列后），变按第n队列时间片轮转运行；</li>
<li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第一到第（i-1）队列空时，才会调度第i队列中的进程运行，并执行相应的时间片轮转。</li>
<li>如果处理机正在处理第i队列中某进程，又有新进程进入优先级较高的队列，则此新队列抢占正在运行的处理机，并把正在运行的进行放在第i队列的队尾。</li>
</ul>
<h2 id="18-空"><a href="#18-空" class="headerlink" title="18. 空"></a>18. 空</h2><h2 id="19-nginx如何处理连接"><a href="#19-nginx如何处理连接" class="headerlink" title="19. nginx如何处理连接"></a>19. nginx如何处理连接</h2><h2 id="20-nginx如何做性能优化"><a href="#20-nginx如何做性能优化" class="headerlink" title="20. nginx如何做性能优化"></a>20. nginx如何做性能优化</h2><h2 id="21-nginx与apache的区别"><a href="#21-nginx与apache的区别" class="headerlink" title="21. nginx与apache的区别"></a>21. nginx与apache的区别</h2><h2 id="22-nginx超时怎么办"><a href="#22-nginx超时怎么办" class="headerlink" title="22. nginx超时怎么办"></a>22. nginx超时怎么办</h2><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="1-linux常用命令"><a href="#1-linux常用命令" class="headerlink" title="1. linux常用命令"></a>1. linux常用命令</h2><h2 id="2-Linux内存管理机制"><a href="#2-Linux内存管理机制" class="headerlink" title="2. Linux内存管理机制"></a>2. Linux内存管理机制</h2><h2 id="3-使用什么命令查看cpu和内存情况"><a href="#3-使用什么命令查看cpu和内存情况" class="headerlink" title="3.使用什么命令查看cpu和内存情况"></a>3.使用什么命令查看cpu和内存情况</h2><h2 id="4-如何查看进程的线程情况"><a href="#4-如何查看进程的线程情况" class="headerlink" title="4. 如何查看进程的线程情况"></a>4. 如何查看进程的线程情况</h2><blockquote>
<p><code>top -H -p</code></p>
</blockquote>
<h2 id="5-如何查看系统性能、性能指标"><a href="#5-如何查看系统性能、性能指标" class="headerlink" title="5. 如何查看系统性能、性能指标"></a>5. 如何查看系统性能、性能指标</h2><h2 id="6-查看系统负载"><a href="#6-查看系统负载" class="headerlink" title="6. 查看系统负载"></a>6. 查看系统负载</h2><h2 id="7-linux文件类型、文件管理"><a href="#7-linux文件类型、文件管理" class="headerlink" title="7. linux文件类型、文件管理"></a>7. linux文件类型、文件管理</h2><h2 id="8-cup负载过高怎么解决"><a href="#8-cup负载过高怎么解决" class="headerlink" title="8. cup负载过高怎么解决"></a>8. cup负载过高怎么解决</h2>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
        <tag>进程</tag>
        <tag>线程</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库知识点总结归纳</title>
    <url>/2020/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>本文主要对数据库基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。</p>
</blockquote>
<a id="more"></a>

<div style='display: none'>

<!-- TOC -->

<ul>
<li><a href="#数据库常识">数据库常识</a><ul>
<li><a href="#1-什么是索引">1. 什么是索引</a></li>
<li><a href="#2-索引的数据结构">2. 索引的数据结构</a></li>
<li><a href="#3-聚簇索引与非聚簇索引">3. 聚簇索引与非聚簇索引</a></li>
<li><a href="#4-什么是索引覆盖">4. 什么是索引覆盖</a></li>
<li><a href="#5-什么是回表查询">5. 什么是回表查询</a></li>
<li><a href="#6-建立索引需要考虑的因素">6. 建立索引需要考虑的因素</a></li>
<li><a href="#7-联合索引">7. 联合索引</a></li>
<li><a href="#8-查看索引是否被使用到">8. 查看索引是否被使用到</a></li>
<li><a href="#9-为什么要尽量设定一个主键">9. 为什么要尽量设定一个主键</a></li>
<li><a href="#10-主键使用自增id还是uuid">10. 主键使用自增ID还是UUID</a></li>
<li><a href="#11-字段为什么要求定义为not-null">11. 字段为什么要求定义为NOT NULL</a></li>
<li><a href="#12-如果要存储用户的密码散列应该使用什么字段进行存储">12. 如果要存储用户的密码散列，应该使用什么字段进行存储</a></li>
<li><a href="#13-什么是事务">13. 什么是事务</a></li>
<li><a href="#14-事务的特性">14. 事务的特性</a></li>
<li><a href="#15-mysql的事务隔离级别">15. MySql的事务隔离级别</a></li>
<li><a href="#16-同时多个事务并发执行可能造成的问题">16. 同时多个事务并发执行可能造成的问题</a></li>
<li><a href="#17-不可重复读和幻读的区别">17. 不可重复读和幻读的区别</a></li>
<li><a href="#18-共享锁与排他锁">18. 共享锁与排他锁</a></li>
<li><a href="#19-表级锁行级锁页级锁">19. 表级锁、行级锁、页级锁</a></li>
<li><a href="#20-死锁">20. 死锁</a></li>
<li><a href="#21-什么是悲观锁">21. 什么是悲观锁</a></li>
<li><a href="#22-什么是乐观锁">22. 什么是乐观锁</a></li>
<li><a href="#23-mysql支持哪些存储引擎">23. MySQL支持哪些存储引擎</a><ul>
<li><a href="#1-innodb存储引擎">(1) InnoDB存储引擎</a></li>
<li><a href="#2-myisam存储引擎">(2) MyISAM存储引擎</a></li>
<li><a href="#3-memory存储引擎">(3) MEMORY存储引擎</a></li>
<li><a href="#4-merge存储引擎">(4) MERGE存储引擎</a></li>
<li><a href="#5-archive存储引擎">(5) Archive存储引擎</a></li>
<li><a href="#6-example存储引擎">(6) EXAMPLE存储引擎</a></li>
<li><a href="#7-ndb-cluster存储引擎">(7) NDB Cluster存储引擎</a></li>
<li><a href="#8-federated存储引擎">(8) FEDERATED存储引擎</a></li>
<li><a href="#9-csv存储引擎">(9) CSV存储引擎</a></li>
<li><a href="#10-blackhole存储引擎">(10) BLACKHOLE存储引擎</a></li>
</ul>
</li>
<li><a href="#24-myisam和innodb的区别">24. MyISAM和InnoDB的区别</a></li>
<li><a href="#25-存储过程">25. 存储过程</a></li>
<li><a href="#26-什么是视图">26. 什么是视图</a></li>
<li><a href="#27-什么是游标">27. 什么是游标</a></li>
<li><a href="#28-触发器">28. 触发器</a></li>
<li><a href="#29-droptruncatedelete区别">29. drop、truncate、delete区别</a></li>
<li><a href="#30-临时表">30. 临时表</a></li>
<li><a href="#31-数据库范式">31. 数据库范式</a></li>
<li><a href="#32-关系型数据库与非关系型数据库优势和区别">32. 关系型数据库与非关系型数据库优势和区别</a></li>
<li><a href="#33-sql语言分类">33. SQL语言分类</a></li>
<li><a href="#34-countcount1和countcolumn的区别">34. count(*)、count(1)和count(column)的区别</a></li>
<li><a href="#35-like百分号和下划线的区别">35. like、百分号和下划线的区别</a></li>
<li><a href="#36-最左前缀原则">36. 最左前缀原则</a></li>
<li><a href="#37-超大分页处理">37. 超大分页处理</a></li>
<li><a href="#38-慢查询优化">38. 慢查询优化</a></li>
<li><a href="#39-横向分表和纵向分表">39. 横向分表和纵向分表</a></li>
<li><a href="#40-b树和b树的区别">40. B+树和B树的区别</a></li>
<li><a href="#41-查询语句中用到的关键词">41. 查询语句中用到的关键词</a></li>
<li><a href="#42-使用explain优化sql和索引">42. 使用explain优化SQL和索引</a></li>
<li><a href="#43-数据库组主从复制的方式">43. 数据库组主从复制的方式</a></li>
<li><a href="#44-数据库崩溃时事务的恢复机制redo日志和undo日志">44. 数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）</a></li>
</ul>
</li>
<li><a href="#mysql数据库">Mysql数据库</a><ul>
<li><a href="#1-创建数据库">1. 创建数据库</a></li>
<li><a href="#2-用户管理">2. 用户管理</a></li>
<li><a href="#3-授权管理">3. 授权管理</a></li>
<li><a href="#4-修改表的列">4. 修改表的列</a></li>
<li><a href="#5-键的操作">5. 键的操作</a></li>
<li><a href="#6-设置默认值">6. 设置默认值</a></li>
<li><a href="#7-sql语句基础">7. SQL语句基础</a></li>
<li><a href="#8-排序">8. 排序</a></li>
<li><a href="#9-聚合函数">9. 聚合函数</a></li>
<li><a href="#10-分组">10. 分组</a></li>
<li><a href="#11-关联查询">11. 关联查询</a></li>
<li><a href="#12-组合">12. 组合</a></li>
<li><a href="#13-limit的用法">13. LIMIT的用法</a></li>
<li><a href="#14-case-when">14. case when</a></li>
<li><a href="#15-mysql-常用数据类型">15. mysql 常用数据类型</a></li>
<li><a href="#16-mysql读取数据的基本单位">16. MySQL读取数据的基本单位</a></li>
<li><a href="#17-为什么mysql事务回滚后自增id依然自增">17. 为什么mysql事务回滚后，自增ID依然自增</a></li>
<li><a href="#18-mysql的主从复制的实现过程">18. mysql的主从复制的实现过程</a></li>
<li><a href="#19-mysql高并发环境解决方案">19. mysql高并发环境解决方案</a></li>
</ul>
</li>
<li><a href="#redis数据库">Redis数据库</a><ul>
<li><a href="#1-什么是redis">1. 什么是Redis</a></li>
<li><a href="#2-redis的数据类型">2. redis的数据类型</a></li>
<li><a href="#3-两种持久化方式">3. 两种持久化方式</a></li>
<li><a href="#4-rdb与aof比较">4. RDB与AOF比较</a></li>
<li><a href="#5-如果aof文件出现被写坏的情况该怎么处理">5. 如果AOF文件出现被写坏的情况，该怎么处理</a></li>
<li><a href="#6-redis-和-memcached-的主要区别">6. redis 和 memcached 的主要区别</a></li>
<li><a href="#7-事务处理">7. 事务处理</a></li>
<li><a href="#8-redis常见的架构模式">8. Redis常见的架构模式</a><ul>
<li><a href="#1-单机模式">(1) 单机模式</a></li>
<li><a href="#2-主从复制模式">(2) 主从复制模式</a></li>
<li><a href="#3-哨兵模式">(3) 哨兵模式</a></li>
<li><a href="#4-集群模式">(4) 集群模式</a></li>
</ul>
</li>
<li><a href="#9-redis如何实现分布式锁">9. Redis如何实现分布式锁</a></li>
<li><a href="#10-缓存使用场景">10. 缓存使用场景</a></li>
<li><a href="#11-常用的缓存使用模式">11. 常用的缓存使用模式</a></li>
<li><a href="#12-什么是缓存穿透">12. 什么是缓存穿透</a></li>
<li><a href="#13-什么是缓存击穿">13. 什么是缓存击穿</a></li>
<li><a href="#14-什么是缓存雪崩">14. 什么是缓存雪崩</a></li>
<li><a href="#15-连接redis">15. 连接Redis</a></li>
<li><a href="#16-redis异步队列">16. Redis异步队列</a></li>
<li><a href="#17-生产一次消费多次">17. 生产一次消费多次</a></li>
<li><a href="#18-redis分区">18. Redis分区</a></li>
</ul>
</li>
<li><a href="#mongodb数据库">MongoDB数据库</a><ul>
<li><a href="#1-mongodb常用的操作">1. MongoDB常用的操作</a></li>
</ul>
</li>
<li><a href="#elasticsearch数据库">Elasticsearch数据库</a><ul>
<li><a href="#1-索引如何存储">1. 索引如何存储</a></li>
<li><a href="#2-介绍下elastisearch原理和用途">2. 介绍下Elastisearch原理和用途</a></li>
<li><a href="#3-分布式实时日志使用elk">3. 分布式实时日志使用ELK</a></li>
</ul>
</li>
<li><a href="#hive数据库">Hive数据库</a></li>
<li><a href="#hbase数据库">Hbase数据库</a></li>
<li><a href="#hadoop生态">Hadoop生态</a></li>
</ul>
<!-- /TOC -->

</div>

<h1 id="数据库常识"><a href="#数据库常识" class="headerlink" title="数据库常识"></a>数据库常识</h1><h2 id="1-什么是索引"><a href="#1-什么是索引" class="headerlink" title="1. 什么是索引"></a>1. 什么是索引</h2><blockquote>
<p>索引其实就是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候,索引可以大大的加快查询的速度，这是因为使用索引之后不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据的屋里地址然后访问相应的数据。</p>
</blockquote>
<blockquote>
<p>索引的缺点：在创建索引和维护索引会耗费时间，随着数据的增加而增加.索引也会增加，所以如果是经常增删改的列创建索引会大大的增加项目的维护速度。</p>
</blockquote>
<blockquote>
<p>索引的分类：</p>
</blockquote>
<ul>
<li>普通索引</li>
<li>主键索引</li>
<li>唯一索引</li>
<li>多列索引</li>
<li>全文索引</li>
</ul>
<blockquote>
<p>创建索引和删除索引：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 普通索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> tb_name</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> <span class="keyword">index</span> index_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> tb_name  <span class="comment">-- 删除索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 主键索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> primary <span class="keyword">key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除主键索引：</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">drop</span> primary <span class="keyword">key</span>  <span class="comment">-- 普通非自增主键</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">id</span> <span class="keyword">modify</span> <span class="keyword">id</span> <span class="built_in">int</span>;  <span class="comment">-- 自增主键，取消自增列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">drop</span> primary <span class="keyword">key</span>  <span class="comment">-- 删除主键索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 唯一索引，与普通索引类似，可以有null值</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> tb_name</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> <span class="keyword">unique</span> <span class="keyword">index</span> index_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> tb_name  <span class="comment">-- 删除索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多列索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> people <span class="keyword">ADD</span> <span class="keyword">INDEX</span> lname_fname_age (lame, fname,age);</span><br></pre></td></tr></table></figure>

<h2 id="2-索引的数据结构"><a href="#2-索引的数据结构" class="headerlink" title="2. 索引的数据结构"></a>2. 索引的数据结构</h2><blockquote>
<p>索引的数据结构和具体存储引擎的实现有关，在MySql中常用的有Hash索引和B+树索引，而常用的<code>InnoDB</code>存储引擎的默认索引实现为：B+树索引。</p>
</blockquote>
<ul>
<li>Hash索引</li>
</ul>
<blockquote>
<p>Hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获取实际数据。</p>
</blockquote>
<ul>
<li>B+树索引</li>
</ul>
<blockquote>
<p>B+树索引底层实现是多路平衡查找树，所有节点遵循左节点小于父节点，右节点大于父节点；对于每一次查询都是从根节点出发，查找到叶子节点方可以获取所查询的键值，然后根据查询判断是否需要返回表查询数据。</p>
</blockquote>
<blockquote>
<p>Hash索引与B+树所以的差异：</p>
</blockquote>
<ul>
<li>hash索引进行等值查询比较快，但是无法进行范围查询，而B+支持范围查询；</li>
<li>hash索引不支持使用索引排序；</li>
<li>hash索引不支持模糊查询以及多列索引的最左前缀匹配；</li>
<li>hash索引避免不了回表查询数据，而B+树在（聚簇索引、覆盖索引）的时候可以只通过索引完成查询；</li>
<li>hash索引不稳定，性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率极差，而B+树查询效率比较稳定，所有查询都是从根节点到叶子节点，且树的高度较低。</li>
</ul>
<h2 id="3-聚簇索引与非聚簇索引"><a href="#3-聚簇索引与非聚簇索引" class="headerlink" title="3. 聚簇索引与非聚簇索引"></a>3. 聚簇索引与非聚簇索引</h2><blockquote>
<p>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。以<code>InnoDB</code>作为存储引擎的数据表中，只有主键索引才是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引；如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p>
</blockquote>
<blockquote>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用在进行回表查询。</p>
</blockquote>
<blockquote>
<p>非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据还需要根据主键再去聚集索引中进行查找，也就是回表查询。非聚簇索引也不一定会回表查询，因为这涉及到查询语句所要求的字段是否全部命中了索引，如果是，那么就不用再进行回表查询了。</p>
</blockquote>
<h2 id="4-什么是索引覆盖"><a href="#4-什么是索引覆盖" class="headerlink" title="4. 什么是索引覆盖"></a>4. 什么是索引覆盖</h2><blockquote>
<p>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。</p>
</blockquote>
<blockquote>
<p>可以利用索引覆盖来优化SQL的场景：</p>
</blockquote>
<ul>
<li>全表count查询优化</li>
<li>列查询回表优化</li>
<li>分页查询</li>
</ul>
<h2 id="5-什么是回表查询"><a href="#5-什么是回表查询" class="headerlink" title="5. 什么是回表查询"></a>5. 什么是回表查询</h2><blockquote>
<p>先定位主键值，再定位行记录，它的性能比扫一遍索引树更低。</p>
</blockquote>
<h2 id="6-建立索引需要考虑的因素"><a href="#6-建立索引需要考虑的因素" class="headerlink" title="6. 建立索引需要考虑的因素"></a>6. 建立索引需要考虑的因素</h2><ul>
<li>考虑字段的使用频率，经常作为条件进行查询的字段；</li>
<li>经常作为表连接的字段考虑建索引，可以加快连接的速度；</li>
<li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度；</li>
<li>经常在order by、group by之后的字段考虑建索引；</li>
<li>考虑联合索引中的顺序，否则无法命中索引</li>
<li>对非空字段<code>(NOT NULL)</code>创建索引，Mysql很难对控制做查询优化</li>
<li>索引适合区分度高、离散程度大的字段，有大量重复值的字段不适合建索引；</li>
<li>索引的长度不能太长，耗时；</li>
<li>对于那些定义为text, image和bit数据类型的列不应该增加索引；</li>
</ul>
<h2 id="7-联合索引"><a href="#7-联合索引" class="headerlink" title="7. 联合索引"></a>7. 联合索引</h2><blockquote>
<p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p>
</blockquote>
<blockquote>
<p>因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p>
</blockquote>
<h2 id="8-查看索引是否被使用到"><a href="#8-查看索引是否被使用到" class="headerlink" title="8. 查看索引是否被使用到"></a>8. 查看索引是否被使用到</h2><blockquote>
<p>MySQL提供了explain命令来查看语句的执行计划，MySQL在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。可以通过其中和索引有关的信息来分析是否命中了索引，如<code>possilbe_key, key,key_len</code>等字段，分别说明了此语句可能会使用的索引、实际使用的索引以及使用的索引长度。</p>
</blockquote>
<blockquote>
<p>Mysql索引未被使用到的情况：</p>
</blockquote>
<ul>
<li>列参与了数学运算或者函数；</li>
<li>在字符串like时，左边是通配符，如’%aaa’;</li>
<li>当Mysql分析全表扫描比使用索引快的时候不用索引；</li>
<li>当使用联合索引，前面一个条件为范围查询，后面的即使符合最左前缀原则，也无法使用索引；</li>
</ul>
<h2 id="9-为什么要尽量设定一个主键"><a href="#9-为什么要尽量设定一个主键" class="headerlink" title="9. 为什么要尽量设定一个主键"></a>9. 为什么要尽量设定一个主键</h2><blockquote>
<p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p>
</blockquote>
<h2 id="10-主键使用自增ID还是UUID"><a href="#10-主键使用自增ID还是UUID" class="headerlink" title="10. 主键使用自增ID还是UUID"></a>10. 主键使用自增ID还是UUID</h2><blockquote>
<p>推荐使用自增ID，不要使用UUID（通用唯一识别码，Universally Unique Identifier）。因为在<code>InnoDB</code>存储引擎中，主键索引是作为聚簇索引存在的，也就是说主键索引的B+树叶子节点上存储了主键索引以及全部的数据，如果主键索引是自增ID,那么只需要不断向后排序即可；如果用UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入、数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p>
</blockquote>
<h2 id="11-字段为什么要求定义为NOT-NULL"><a href="#11-字段为什么要求定义为NOT-NULL" class="headerlink" title="11. 字段为什么要求定义为NOT NULL"></a>11. 字段为什么要求定义为NOT NULL</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- MySQL官网这样介绍：</span></span><br><span class="line">NULL columns require additional space in the rowto record whether their <span class="keyword">values</span> <span class="keyword">are</span> NULL. <span class="keyword">For</span> MyISAM <span class="keyword">tables</span>, <span class="keyword">each</span> <span class="literal">NULL</span> columntakes one <span class="built_in">bit</span> extra, rounded up <span class="keyword">to</span> the nearest byte.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>NULL值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p>
</blockquote>
<h2 id="12-如果要存储用户的密码散列，应该使用什么字段进行存储"><a href="#12-如果要存储用户的密码散列，应该使用什么字段进行存储" class="headerlink" title="12. 如果要存储用户的密码散列，应该使用什么字段进行存储"></a>12. 如果要存储用户的密码散列，应该使用什么字段进行存储</h2><blockquote>
<p>密码散列、盐、用户身份证号等固定长度的字符串应该使用<code>char</code>而不是<code>varchar</code>来存储,这样可以节省空间且提高检索效率.</p>
</blockquote>
<h2 id="13-什么是事务"><a href="#13-什么是事务" class="headerlink" title="13. 什么是事务"></a>13. 什么是事务</h2><blockquote>
<p>在MySQL中只有使用了<code>Innodb</code>数据库引擎的数据库或表才支持事务；事务是数据库并发控制的基本单位；事务可以用来管理<code>INSERT/UPDATE/DELETE</code>操作语句；事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行（回滚）。</p>
</blockquote>
<h2 id="14-事务的特性"><a href="#14-事务的特性" class="headerlink" title="14. 事务的特性"></a>14. 事务的特性</h2><ul>
<li>原子性(Atomicity)</li>
</ul>
<blockquote>
<p>事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。</p>
</blockquote>
<ul>
<li>一致性(Consistency)</li>
</ul>
<blockquote>
<p>几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。</p>
</blockquote>
<ul>
<li>隔离性(Isolation)</li>
</ul>
<blockquote>
<p>事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。</p>
</blockquote>
<ul>
<li>持久性(Durability)</li>
</ul>
<blockquote>
<p>对于任意已交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现异常。</p>
</blockquote>
<h2 id="15-MySql的事务隔离级别"><a href="#15-MySql的事务隔离级别" class="headerlink" title="15. MySql的事务隔离级别"></a>15. MySql的事务隔离级别</h2><ul>
<li>读未提交（Read uncommitted）</li>
</ul>
<blockquote>
<p>事物A和事物B，事物A未提交的数据，事物B可以读取到”脏数据”；隔离级别低，一般都高于该级别。</p>
</blockquote>
<ul>
<li>读已提交（Read committed）</li>
</ul>
<blockquote>
<p>事物A和事物B，事物A提交的数据，事物B才能读取到;隔离级别高于读未提交，可以避免脏读，但是可能会导致不可重复读和幻读。（是Oracle默认隔离级别）</p>
</blockquote>
<ul>
<li>可重复读（Repeatable read）</li>
</ul>
<blockquote>
<p>事务A和事务B，事务A提交之后的数据，事务B是可重复读取数据这时事务B读取不到；该隔离级别高于读已提交，可以避免不可重复读，但有可能导致幻读，MySQL（也是InnoDB）默认隔离级别。</p>
</blockquote>
<ul>
<li>串行化（Serializable）</li>
</ul>
<blockquote>
<p>事务A和事务B，事务A在操作数据库时，事务B只能排队等待；这种隔离级别很少使用，吞吐量太低，用户体验差，这种级别可以避免脏读、重复读、幻读，每一次读取的都是数据库中真实存在数据，这时事务A与事务B串行，而不是并发。</p>
</blockquote>
<p><strong><a href="https://blog.csdn.net/JIESA/article/details/51317164" target="_blank" rel="noopener">四个隔离级别可能出现脏读、不可重复读、幻读问题</a></strong></p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center"></th>
<th align="center">出现情况</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">脏读</td>
<td align="center">不可重复读</td>
<td align="center">幻读</td>
</tr>
<tr>
<td align="center">读未提交</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">读已提交</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h2 id="16-同时多个事务并发执行可能造成的问题"><a href="#16-同时多个事务并发执行可能造成的问题" class="headerlink" title="16. 同时多个事务并发执行可能造成的问题"></a>16. 同时多个事务并发执行可能造成的问题</h2><ul>
<li>脏读：就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问这个数据，然后使用了这个数据。</li>
<li>不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。</li>
<li>幻读：事务在插入已经检查过不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测获取到的数据如同鬼影一般。</li>
<li>丢失修改：并发写入造成其中一些修改丢失。</li>
</ul>
<h2 id="17-不可重复读和幻读的区别"><a href="#17-不可重复读和幻读的区别" class="headerlink" title="17. 不可重复读和幻读的区别"></a>17. 不可重复读和幻读的区别</h2><ul>
<li>不可重复读是读取了其他事务更改的数据，针对update操作</li>
</ul>
<blockquote>
<p>解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。</p>
</blockquote>
<ul>
<li>幻读是读取了其他事务新增的数据，针对insert与delete操作</li>
</ul>
<blockquote>
<p>解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。</p>
</blockquote>
<h2 id="18-共享锁与排他锁"><a href="#18-共享锁与排他锁" class="headerlink" title="18. 共享锁与排他锁"></a>18. 共享锁与排他锁</h2><blockquote>
<p>共享锁(shared lock)，又叫读锁，读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，而不会造成阻塞。当用户要进行数据的读取时，对数据加上共享锁，共享锁可以同时加上多个。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>排他锁(exclusive lock)，又叫写锁，写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，它和其他的排他锁、共享锁都相斥。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure>

<h2 id="19-表级锁、行级锁、页级锁"><a href="#19-表级锁、行级锁、页级锁" class="headerlink" title="19. 表级锁、行级锁、页级锁"></a>19. 表级锁、行级锁、页级锁</h2><p><strong><a href="https://www.cnblogs.com/luyucheng/p/6297752.html" target="_blank" rel="noopener">MySQL锁详解</a></strong></p>
<blockquote>
<p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。</p>
</blockquote>
<ul>
<li>使用表级锁的主要是MyISAM、MEMORY、CSV等一些非事务性存储引擎。</li>
</ul>
<blockquote>
<p>行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。<br>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。</p>
</blockquote>
<ul>
<li>使用行级锁的主要是InnoDB存储引擎。</li>
</ul>
<blockquote>
<p>页级锁是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。</p>
</blockquote>
<ul>
<li>使用页级锁的主要是BerkeleyDB存储引擎。</li>
</ul>
<p><strong>MySQL中这三种锁的总结</strong></p>
<blockquote>
<p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；</p>
</blockquote>
<blockquote>
<p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；</p>
</blockquote>
<blockquote>
<p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>
</blockquote>
<blockquote>
<p>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p>
</blockquote>
<h2 id="20-死锁"><a href="#20-死锁" class="headerlink" title="20. 死锁"></a>20. 死锁</h2><blockquote>
<p>在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，当两个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。</p>
</blockquote>
<blockquote>
<p>在InnoDB的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在。当InnoDB检测到系统中产生了死锁之后，InnoDB会通过相应的判断来选这产生死锁的两个事务中较小的事务来回滚，而让另外一个较大的事务成功完成。实际上在InnoDB发现死锁之后，会计算出两个事务各自插入、更新或者删除的数据量来判定两个事务的大小。也就是说哪个事务所改变的记录条数越多，在死锁中就越不会被回滚掉。</p>
</blockquote>
<blockquote>
<p>避免死锁的常用方法：</p>
</blockquote>
<ul>
<li><p>在应用中，如果不同的程序会并发存储多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的概率。</p>
</li>
<li><p>在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能。</p>
</li>
<li><p>在事务中，如果要更新记录，应该直接申请足够级别的锁，及排他锁，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能又已经获得相同记录的共享锁，从而造成锁冲突，甚至死锁。</p>
</li>
<li><p>在可重复读隔离级别下，如果两个线程同时对相同条件记录用<code>select ... for update</code>加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么，就会出现死锁。这种情况下，将隔离级别该为读已提交，就可以避免问题。</p>
</li>
<li><p>当隔离级别为读已提交时，如果两个线程都先执行<code>select ... for update</code>，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现等待，当第一个线程提交后，第二个线程会因主键重复出错，但虽然这个线程出错了，却获得一个排他锁。这时，如果有第三个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后在捕获主键异常，或在遇到主键重错误时，总是执行Rollback释放获得的排他锁。</p>
</li>
<li><p>查出线程杀死kill：<code>SELECT try_MySQL_thread_id FROM information_schema.INNODB_TRX;</code></p>
</li>
<li><p>设置锁超时时间：<code>set innodb_lock_wait_timeout=1000;</code></p>
</li>
</ul>
<h2 id="21-什么是悲观锁"><a href="#21-什么是悲观锁" class="headerlink" title="21. 什么是悲观锁"></a>21. 什么是悲观锁</h2><blockquote>
<p>悲观锁(Pessimistic Lock)，顾名思义就是很悲观。每次去操作数据的时候，都会认为别人会修改。所以为了防止别人修改，就在操作的时候上锁。这样别人来访问的时候就会阻塞在那里直到锁被是释放。传统的关系型数据库里面就用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。</p>
</blockquote>
<blockquote>
<p>遵循逻辑为一锁二查三更新(select for update)会把数据给锁住，其中MySQL默认InnoDB引擎，默认是行级锁，基于索引的，若SQL语句用不到索引，则不会使用行级锁的，会使用表级锁将整张表锁住。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 来源：https://www.jianshu.com/p/083bbe5f5534</span></span><br><span class="line"><span class="comment">-- encoding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 场景：商品goods表中有一个字段status，status为1代表商品未被下单，status为2代表商品已经被下单，那么我们对某个商品下单的时候必须确保该商品status为1。假设商品id为1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果不使用锁,那么操作方法如下:</span></span><br><span class="line"><span class="comment">-- 1.查询出商品信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.根据商品信息生成订单</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_orders(<span class="keyword">id</span>,goods_d) <span class="keyword">values</span>(<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 3.修改商品status为2</span></span><br><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 上面这种场景在高并发访问的情况下很可能会出现问题。</span></span><br><span class="line"><span class="comment">-- 前面已经提到，只有上status为1的时候，才能对该商品下单，上面的第一步操作中查询出来的上面品status为1，但是当我们执行第二步的时候，很有可能有的人先一步执行了步骤2和步骤3，此时订单已经被下过了，然后我们又下了一次。很有可能就出现一个订单被下单了两次的情况。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解决这种问题的方法，我们使用悲观锁来实现。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在上面的场景中，商品信息从查询出来到修改，中间有一个处理订单的过程。使用悲观锁的原理就是,当我们查询goods的信息时，就把当前的数据锁住，直到我们修改完毕后再解锁。那么在这个过程中，因为goods被锁定了，就不会出现有第三者来对其进行修改了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：如果要使用悲观锁，我们必须将mysql数据库的自动提交功能关闭。因为mysql默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySql会立即将结果进行提交。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 我们可以使用命令设置MySQL为非autocommit的模式:</span></span><br><span class="line"><span class="keyword">set</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 设置完autocommit后,我们就可以执行我们的正常业务了。具体如下：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 0.事务开始</span></span><br><span class="line"><span class="keyword">begin</span>;/<span class="keyword">begin</span> <span class="keyword">work</span>;/<span class="keyword">start</span> trasaction;  <span class="comment">-- 三者选一即可</span></span><br><span class="line"><span class="comment">-- 1.查询出商品信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">-- 2.根据商品信息生成订单</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_orders (<span class="keyword">id</span> ,goods_id) <span class="keyword">values</span> (<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 3.修改商品status为2</span></span><br><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 4.提交事务</span></span><br><span class="line"><span class="keyword">commit</span>;/ commint work;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 上面的第一步我们执行了一次查询操作:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> t_goods <span class="keyword">from</span> t_good <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 与普通查询不一样的是，我们使用了select... for update的方式，这样就通过数据库实现了悲观锁。此时t_goods表中，id为1的那条数据就被我们锁定了，其他的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其他事务修改。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>悲观锁的优缺点：悲观锁的策略是先取锁在访问，保证了数据的安全性，但是效率方面，处理锁机制会让数据库产生额外开销，还有可能增加产生死锁的可能，所以一般只有在写操作冲突很多的时候才使用悲观锁，而读操作不需要加锁。</p>
</blockquote>
<h2 id="22-什么是乐观锁"><a href="#22-什么是乐观锁" class="headerlink" title="22. 什么是乐观锁"></a>22. 什么是乐观锁</h2><blockquote>
<p>乐观锁(Optimistic Lock)，顾名思义就是很乐观，每次去拿数据的时候都认为比人不会修改，所以不会上锁。但是在更新数据的时候，会判断一下在更新数据的这段时间内，数据有没有被修改；如果被修改了，就取消这次操作；如果没有被修改，则使得这次操作生效。一般使用版本号或者时间戳的方式来实现。</p>
</blockquote>
<blockquote>
<p>遵循先修改，更新时发现数据已经变了就回滚(check and set)，乐观锁一般通过数据库版本号或时间戳实现。在数据库增加一个字段version，当我们操作数据的时候，将版本号一同取出来，当我们更新数据，在提交更新的时候，会再去数据查询下当前的版本号，跟我们之前取出来的版本号，是否一致。如果一致，就使得这次更新生效。并且在每次更新数据的时候，都使得版本号加1。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用版本号时,可以再数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断一下当前的版本号是不是该数据的最新的版本号。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1. 查询出商品信息</span></span><br><span class="line"><span class="keyword">select</span> (<span class="keyword">status</span>, <span class="keyword">version</span>) <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'id'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.根据商品信息生成订单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.修改商品status为2</span></span><br><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>, <span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">'id'</span> <span class="keyword">and</span> <span class="keyword">version</span>=<span class="string">'version'</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>乐观锁的优缺点：乐观并发控制相信事务之间的数据竞争的概率是比较小的，会先进行操作。再提交的时候，再进行验证这次提交是否可行，因此不会有任何的死锁和锁。但是这样做还是有问题的，例如如果某两个事务对同一行的数据同时进行了修改，经过修改之后，同时写进了数据库，这时就会出现问题。所以乐观锁，一般用在读数据比较多的地方。而对于写数据比较多的地方，我们最好使用悲观锁来解决。</p>
</blockquote>
<h2 id="23-MySQL支持哪些存储引擎"><a href="#23-MySQL支持哪些存储引擎" class="headerlink" title="23. MySQL支持哪些存储引擎"></a>23. MySQL支持哪些存储引擎</h2><p><strong><a href="https://blog.csdn.net/holysll/article/details/89197810" target="_blank" rel="noopener">MySQL的存储引擎的特点比较</a></strong></p>
<h3 id="1-InnoDB存储引擎"><a href="#1-InnoDB存储引擎" class="headerlink" title="(1) InnoDB存储引擎"></a>(1) InnoDB存储引擎</h3><blockquote>
<p>MySQL的默认存储引擎，提供事务安全表，该存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。用于事务处理应用程序，具有众多特性，包括ACID事务支持。相对于MyISAM引擎，写的处理效率会差一些，并且会占用更多的磁盘空间以保留数据和索引。</p>
</blockquote>
<blockquote>
<p>InnoDB主要特点：</p>
</blockquote>
<ul>
<li>InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎；</li>
<li>InnoDB有强大的CPU效率，能够处理巨大数据量；</li>
<li>InnoDB存储引擎完全与MySQL服务器整合，将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件，表可以是任何尺寸；</li>
<li>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键。</li>
</ul>
<h3 id="2-MyISAM存储引擎"><a href="#2-MyISAM存储引擎" class="headerlink" title="(2) MyISAM存储引擎"></a>(2) MyISAM存储引擎</h3><blockquote>
<p>MyISAM存储引擎是管理非事务表，不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表，支持3种不同的存储格式，分别是：静态表（字段长度固定）、动态表（字段长度动态不固定）、压缩表（每个记录单独被压缩，访问开支小）。默认的MySQL插件式存储引擎，它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。</p>
</blockquote>
<blockquote>
<p>MyISAM的主要特点：</p>
</blockquote>
<ul>
<li>大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持；</li>
<li>当把删除和更新及插入操作混合使用的时候，动态大小的行产生更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块自动完成；</li>
<li>每个MyISAM表最大索引数是64，这可以通过重新编译来改变，每个索引最大的列数是16；</li>
<li>NULL被允许在索引的列中，这个值占每个键的0~1个字节；</li>
<li>可以把数据文件和索引文件放在不同目录；</li>
</ul>
<h3 id="3-MEMORY存储引擎"><a href="#3-MEMORY存储引擎" class="headerlink" title="(3) MEMORY存储引擎"></a>(3) MEMORY存储引擎</h3><blockquote>
<p>Memory存储引擎使用存在于内存中的内容来创建表。每个Memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失掉。将所有数据保存在RAM中，在需要快速查找引用和其他类似数据的环境下，可提供极快的访问。Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果。</p>
</blockquote>
<h3 id="4-MERGE存储引擎"><a href="#4-MERGE存储引擎" class="headerlink" title="(4) MERGE存储引擎"></a>(4) MERGE存储引擎</h3><blockquote>
<p>Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，Merge表本身并没有数据，对Merge类型的表可以进行select、update、delete操作，这些操作实际上是对内部的MyISAM表进行的。允许MySQL DBA或开发人员将一系列等同的MyISAM表以逻辑方式组合在一起，并作为1个对象引用它们。对于诸如数据仓储等VLDB环境十分适合。</p>
</blockquote>
<h3 id="5-Archive存储引擎"><a href="#5-Archive存储引擎" class="headerlink" title="(5) Archive存储引擎"></a>(5) Archive存储引擎</h3><blockquote>
<p>存储引擎被用来无索引的、非常小的覆盖存储大量数据。为大量很少引用的历史、归档、或安全审计信息的存储和检索提供了完美的解决方案。</p>
</blockquote>
<h3 id="6-EXAMPLE存储引擎"><a href="#6-EXAMPLE存储引擎" class="headerlink" title="(6) EXAMPLE存储引擎"></a>(6) EXAMPLE存储引擎</h3><blockquote>
<p>EXAMPLE存储引擎是一个“存根”引擎，可以用这个引擎创建表，但没有数据被存储于其中或从其中检索，这个引擎的目的是服务，可为快速创建定制的插件式存储引擎提供帮助。</p>
</blockquote>
<h3 id="7-NDB-Cluster存储引擎"><a href="#7-NDB-Cluster存储引擎" class="headerlink" title="(7) NDB Cluster存储引擎"></a>(7) NDB Cluster存储引擎</h3><blockquote>
<p>MySQL的簇式数据库引擎，是被MySQL Cluster用来实现分割到多台计算机上的表的存储引擎，尤其适合于具有高性能查找要求的应用程序，这类查找需求还要求具有最高的正常工作时间和可用性。</p>
</blockquote>
<h3 id="8-FEDERATED存储引擎"><a href="#8-FEDERATED存储引擎" class="headerlink" title="(8) FEDERATED存储引擎"></a>(8) FEDERATED存储引擎</h3><blockquote>
<p>FEDERATED存储引擎把数据存在远程数据库中。在MySQL 5.1中，它只和MySQL一起工作，使用MySQL C Client API。能够将多个分离的MySQL服务器链接起来，从多个物理服务器创建一个逻辑数据库。十分适合于分布式环境或数据集市环境。</p>
</blockquote>
<h3 id="9-CSV存储引擎"><a href="#9-CSV存储引擎" class="headerlink" title="(9) CSV存储引擎"></a>(9) CSV存储引擎</h3><blockquote>
<p>CSV存储引擎把数据以逗号分隔的格式存储在文本文件中。</p>
</blockquote>
<h3 id="10-BLACKHOLE存储引擎"><a href="#10-BLACKHOLE存储引擎" class="headerlink" title="(10) BLACKHOLE存储引擎"></a>(10) BLACKHOLE存储引擎</h3><blockquote>
<p>BLACKHOLE存储引擎接受但不存储数据，并且检索总是返回一个空集。用于临时禁止对数据库的应用程序输入。</p>
</blockquote>
<h2 id="24-MyISAM和InnoDB的区别"><a href="#24-MyISAM和InnoDB的区别" class="headerlink" title="24. MyISAM和InnoDB的区别"></a>24. MyISAM和InnoDB的区别</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="left">MyISAM</th>
<th align="left">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">构成</td>
<td align="left">表定义文件：.frm；数据文件：.MYD；索引文件：.MYI；</td>
<td align="left">表大小只限制与操作系统文件的大熊啊，一般为2G</td>
</tr>
<tr>
<td align="center">事务处理</td>
<td align="left">性能快，但不支持事务和外键</td>
<td align="left">支持事务，支持外键</td>
</tr>
<tr>
<td align="center">增删改查</td>
<td align="left">适合执行大量的SELECT操作</td>
<td align="left">执行大量数据的INSERT或UPDATE；删除不会重新建表，而是一行行删除</td>
</tr>
<tr>
<td align="center">AUTO_INCREMENT操作</td>
<td align="left">MyISAM 为 INSERT 和 UPDATE 操作自动更新这一列；</td>
<td align="left">在数据词典里的InnoDB表句柄包含一个名为自动增长计数器的计数器，仅被存储在主内存中，而不是存在磁盘上</td>
</tr>
<tr>
<td align="center">表行数</td>
<td align="left">执行<code>select count(*) from table</code>保存行数</td>
<td align="left">执行<code>select count(*) from table</code>且要扫描整表去计算行数</td>
</tr>
<tr>
<td align="center">锁</td>
<td align="left">表级锁</td>
<td align="left">行级锁</td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="left">支持全文索引</td>
<td align="left">支持全文索引(&gt;=5.6)</td>
</tr>
<tr>
<td align="center">多版本并发控制</td>
<td align="left">不支持MVCC</td>
<td align="left">支持MVCC</td>
</tr>
</tbody></table>
<h2 id="25-存储过程"><a href="#25-存储过程" class="headerlink" title="25. 存储过程"></a>25. 存储过程</h2><blockquote>
<p>存储过程是一些预编译的SQL语句，执行效率比较高，一个存储过程代替大量的T-SQL语句，可以降低网络通信量，提高通信速率，可以一定程度上确保数据安全。</p>
</blockquote>
<blockquote>
<p>通俗的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能，然后再给这个代码块取一个别名，调用时直接用别名调用。</p>
</blockquote>
<blockquote>
<p>存储过程的优缺点</p>
</blockquote>
<ul>
<li>优点：<ul>
<li>存储过程是预编译过的，执行效率高；</li>
<li>存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯；</li>
<li>安全性高，执行存储过程需要一定权限的用户；</li>
<li>存储过程可以重复使用，可减少数据库开发人员的工作量；</li>
</ul>
</li>
<li>缺点：移植性差</li>
</ul>
<h2 id="26-什么是视图"><a href="#26-什么是视图" class="headerlink" title="26. 什么是视图"></a>26. 什么是视图</h2><blockquote>
<p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增、改、查操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。</p>
</blockquote>
<blockquote>
<p>视图的优缺点</p>
</blockquote>
<ul>
<li>优点：<ul>
<li>对数据库的访问，因为视图可以有选择性的选取数据库里的一部分；</li>
<li>用户通过简单的查询可以从复杂查询中得到结果；</li>
<li>维护数据的独立性，视图可从多个表检索数据；</li>
<li>对于相同的数据可产生不同的视图；</li>
</ul>
</li>
<li>缺点：<ul>
<li>查询视图时，必须把视图的查询转化成基本表的查询，如果这个视图是由一个复杂的夺标查询所定义的，那么就无法更改数据。</li>
</ul>
</li>
</ul>
<h2 id="27-什么是游标"><a href="#27-什么是游标" class="headerlink" title="27. 什么是游标"></a>27. 什么是游标</h2><blockquote>
<p>游标是对查询出来的结果作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或者多行。可以对结果集当前行做修改。一般不用游标，主要用在逐条处理数据时。</p>
</blockquote>
<h2 id="28-触发器"><a href="#28-触发器" class="headerlink" title="28. 触发器"></a>28. 触发器</h2><blockquote>
<p>触发器是一种特殊的存储过程，主要是通过实践来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算，如某表上的触发器包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p>
</blockquote>
<h2 id="29-drop、truncate、delete区别"><a href="#29-drop、truncate、delete区别" class="headerlink" title="29. drop、truncate、delete区别"></a>29. drop、truncate、delete区别</h2><ul>
<li>drop直接删除表</li>
<li>truncate删除表中的数据，再插入时自增长id又从1开始</li>
<li>delete删除表中的数据，可以加where语句</li>
</ul>
<h2 id="30-临时表"><a href="#30-临时表" class="headerlink" title="30. 临时表"></a>30. 临时表</h2><blockquote>
<p>MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。默认情况下，当你断开与数据库的连接后，临时表就会自动被销毁。当然你也可以在当前MySQL会话使用 DROP TABLE 命令来手动删除临时表。</p>
</blockquote>
<h2 id="31-数据库范式"><a href="#31-数据库范式" class="headerlink" title="31. 数据库范式"></a>31. 数据库范式</h2><blockquote>
<p>第一范式：最基本范式，数据库表中所有字段都是不可分解的原子值。</p>
</blockquote>
<blockquote>
<p>第二范式：在一个数据表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据表中。主要针对联合主键而言，确保数据表中的每一列都和主键相关，而不能只与主键的某一部分相关。</p>
</blockquote>
<blockquote>
<p>第三范式：确保数据表中的每一列数据都和主键直接相关，而不是间接相关。</p>
</blockquote>
<blockquote>
<p><strong>一般，一个数据库设计符合3NF或BCNF就可以了</strong></p>
</blockquote>
<blockquote>
<p>第四范式：要求把统一表内的多对多关系删除。</p>
</blockquote>
<blockquote>
<p>第五范式：从最终结构重新建立原始结构。</p>
</blockquote>
<h2 id="32-关系型数据库与非关系型数据库优势和区别"><a href="#32-关系型数据库与非关系型数据库优势和区别" class="headerlink" title="32. 关系型数据库与非关系型数据库优势和区别"></a>32. 关系型数据库与非关系型数据库优势和区别</h2><ul>
<li><p>关系型数据库</p>
<ul>
<li>复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li>
<li>事务支持：使得对安全性能很高的数据访问要求得以实现。</li>
</ul>
</li>
<li><p>非关系型数据库</p>
<ul>
<li>性能：NoSQL基于k-v键值对，不需要经过SQL层的解析，性能非常高。</li>
<li>可扩展性：因为基于键值对，数据之间没有耦合性，所以水平扩展非常容易。</li>
</ul>
</li>
<li><p>趋势</p>
<ul>
<li>NoSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，如MongoDB。</li>
<li>对于事务的支持，也可以用一些系统级的原子操作（乐观锁之类的方法）来解决，比如redis set nx</li>
</ul>
</li>
</ul>
<h2 id="33-SQL语言分类"><a href="#33-SQL语言分类" class="headerlink" title="33. SQL语言分类"></a>33. SQL语言分类</h2><ul>
<li>数据查询语言DQL：主要是<code>SELECT</code>、<code>FROM</code>、<code>WHERE</code>语句</li>
<li>数据操纵语句DML：主要是<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code></li>
<li>数据定义语言DDL：创建数据库中的各种对象（表、视图、索引、同义词）<code>CREATE TABLE/VIEW/INDEX/SYN/CLUSTER</code></li>
<li>数据控制语言DCL：授权（<code>GRANT</code>）、回滚上次最后提交的状态（<code>ROLLBACK</code>）、回退到某个点（<code>ROLLBACK WORK TO [SAVEPOINT</code>）、提交（<code>COMMIT WORK</code>）。</li>
</ul>
<h2 id="34-count-、count-1-和count-column-的区别"><a href="#34-count-、count-1-和count-column-的区别" class="headerlink" title="34. count(*)、count(1)和count(column)的区别"></a>34. count(*)、count(1)和count(column)的区别</h2><ul>
<li><code>count(*)</code>：对行的数目进行计算，包含NULL，跟<code>count(非主键)</code>一样，扫描整个表；</li>
<li><code>count(1)</code>：与<code>count(主键)</code>是一样的，只扫描主键；</li>
<li><code>count(column)</code>：对特定的类的值具体的函数进行计算，不包含NULL值；</li>
</ul>
<blockquote>
<p>特别注意：</p>
</blockquote>
<ul>
<li>任何情况下<code>SELECT COUNT(*) FROM tablename</code>是最优选择；</li>
<li>尽量减少<code>SELECT COUNT(*) FROM tablename WHERE COL = &#39;value&#39;</code>这种查询；</li>
<li>杜绝<code>SELECT COUNT(COL) FROM tablename WHERE COL1 = &#39;value&#39;</code>的出现；</li>
<li>如果表没有主键，那么<code>count(1)</code>比<code>count(*)</code>快；若果有主键，那么<code>count(主键，联合主键)</code>比<code>count(*)</code>快；若过表只有一个字段，<code>count(*)</code>最快。</li>
</ul>
<h2 id="35-like、百分号和下划线的区别"><a href="#35-like、百分号和下划线的区别" class="headerlink" title="35. like、百分号和下划线的区别"></a>35. like、百分号和下划线的区别</h2><ul>
<li>like操作符：LIKE作用是指示MySQL后面的搜索模式是利用通配符而不是直接相等匹配进行比较；若like后面没有通配符，则跟=等号效果一致。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> products.prod_name <span class="keyword">like</span> <span class="string">'1000'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>%百分号通配符：表示任何字符出现任意次数（可以是0次），但是不能匹配NULL。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 匹配以aaa开头的记录，包括aaa</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> products.prod_name <span class="keyword">like</span> <span class="string">'aaa%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配包含aaa开头的记录，包括aaa</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> products.prod_name <span class="keyword">like</span> <span class="string">'%aaa%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配以aaa结尾的记录，仅仅包括aaa（后面不能有空格）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> products.prod_name <span class="keyword">like</span> <span class="string">'%aaa'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>_下划线通配符：表示只能匹配单个字符，不能多也不能少，就一个字符。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 向前匹配一个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> products.prod_name <span class="keyword">like</span> <span class="string">'_aaa'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 向后匹配一个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> products.prod_name <span class="keyword">like</span> <span class="string">'aaa_'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>特别注意</p>
<ul>
<li>MySQL的通配符很有用，但这种通配符搜索的处理一般比较慢。</li>
<li>不要过度使用通配符,如果其他操作符能达到相同的目的，应该使用其他操作符;</li>
<li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处，因为会很慢；</li>
<li>仔细注意通配符的位置，如果放错地方，可能不会返回想要的结果。</li>
</ul>
</li>
</ul>
<h2 id="36-最左前缀原则"><a href="#36-最左前缀原则" class="headerlink" title="36. 最左前缀原则"></a>36. 最左前缀原则</h2><blockquote>
<p>最左前缀原则：顾名思义，就是最左优先。在mysql中执行查询时，只能使用一个索引；在多列分别建索引，执行查询时，只用使用一个索引，mysql会选择一个最严格的的索引（获得结果集记录数最少的）。</p>
</blockquote>
<h2 id="37-超大分页处理"><a href="#37-超大分页处理" class="headerlink" title="37. 超大分页处理"></a>37. 超大分页处理</h2><ul>
<li>数据库层面：核心思想是减少load数据，适当利用所应覆盖</li>
<li>靠缓存机制解决，可预测性地提前查到所需的内存，缓存到redis等k-v数据库中，直接返回即可。</li>
</ul>
<h2 id="38-慢查询优化"><a href="#38-慢查询优化" class="headerlink" title="38. 慢查询优化"></a>38. 慢查询优化</h2><ul>
<li>首先分析语句，查看是否load了额外的数据，可能是查询了多余的行并抛弃了，可能是加载了许多结果中并不需要的列，对语句进行分析并重写；</li>
<li>分析语句的执行计划，然后获得其索引情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引；</li>
<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或纵向的分表；</li>
<li><code>slow_query_log_file</code> 查看慢查询日志，调整数据修改索引</li>
</ul>
<h2 id="39-横向分表和纵向分表"><a href="#39-横向分表和纵向分表" class="headerlink" title="39. 横向分表和纵向分表"></a>39. 横向分表和纵向分表</h2><blockquote>
<p>横向分表是按行分表，假设我们有一张用户表，主键是自增ID且同时是用户的ID。数据量较大，有1亿多条，那么此时放在一张表里的查询效果就不太理想。我们可以根据主键ID进行分表，无论是按尾号分，或者按ID的区间分都是可以的。假设按照尾号0-99分为100个表，那么每张表中的数据就仅有100w。这时的查询效率无疑是可以满足要求的。</p>
</blockquote>
<blockquote>
<p>纵向分表是按列分表，假设我们现在有一张文章表。包含字段id-摘要-内容。而系统中的展示形式是刷新出一个列表，列表中仅包含标题和摘要，当用户点击某篇文章进入详情时才需要正文内容。此时，如果数据量大，将内容这个很大且不经常使用的列放在一起会拖慢原表的查询速度。我们可以将上面的表分为两张。id-摘要，id-内容，当用户点击详情，那主键再来取一次内容即可，而增加的存储量只是很小的主键字段，代价很小。</p>
</blockquote>
<h2 id="40-B-树和B树的区别"><a href="#40-B-树和B树的区别" class="headerlink" title="40. B+树和B树的区别"></a>40. B+树和B树的区别</h2><p><strong><a href="https://www.cnblogs.com/zhuyeshen/p/12082839.html" target="_blank" rel="noopener">MySQL索引-B+树（看完你就明白了）</a></strong></p>
<p><strong><a href="https://blog.csdn.net/qq_35571554/article/details/82759668" target="_blank" rel="noopener">漫画叙述B+树和B-树</a></strong></p>
<blockquote>
<p>(1). B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。</p>
</blockquote>
<blockquote>
<p>(2). B+ 树的阶数是等于键值的数量的，如果我们的 B+ 树一个节点可以存储 1000 个键值，那么 3 层 B+ 树可以存储 1000×1000×1000=10 亿个数据。一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。</p>
</blockquote>
<blockquote>
<p>(3). B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。</p>
</blockquote>
<blockquote>
<p>(4). B+ 树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。在<code>InnoDB</code>中，数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据；在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。</p>
</blockquote>
<blockquote>
<p>(5). B+树的磁盘读写代价更低，IO 次数少，数据查询的效率也会更快；B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路，路径长度相同，所以每一个数据的查询效率相当。</p>
</blockquote>
<h2 id="41-查询语句中用到的关键词"><a href="#41-查询语句中用到的关键词" class="headerlink" title="41. 查询语句中用到的关键词"></a>41. 查询语句中用到的关键词</h2><blockquote>
<p>查询中用到的关键词主要包含六个，且执行顺序为<code>select--&gt;from--&gt;where--&gt;group by--&gt;having--order by</code></p>
</blockquote>
<blockquote>
<p>select和from是必须的，其他可选；</p>
</blockquote>
<blockquote>
<p>where: 过滤表中数据的条件；</p>
</blockquote>
<blockquote>
<p>group by：如何将上面过滤出的数据分组；</p>
</blockquote>
<blockquote>
<p>having：对上面已经分组的数据进行过滤的条件；</p>
</blockquote>
<blockquote>
<p>order by：按照什么样的顺序来查看返回的数据；</p>
</blockquote>
<blockquote>
<p><strong>from后面的表关联，是自右向左解析，而where条件的解析顺序是自下而上的：</strong> 在写SQL语句的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在where语句的最左边（用小表去匹配大表）。</p>
</blockquote>
<h2 id="42-使用explain优化SQL和索引"><a href="#42-使用explain优化SQL和索引" class="headerlink" title="42. 使用explain优化SQL和索引"></a>42. 使用explain优化SQL和索引</h2><blockquote>
<p>对于复杂、效率低的sql语句，可以使用<code>explain + sql</code>的格式来分析sql语句，可以打印出语句执行的过程，以便分析与优化。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>table</code></td>
<td align="left">显示这一行的数据是关于哪张表的</td>
</tr>
<tr>
<td align="center"><code>type</code></td>
<td align="left">这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL</td>
</tr>
<tr>
<td align="center"><code>all</code></td>
<td align="left"><code>full table scan</code> 即MySQL将遍历全表以找到匹配的行</td>
</tr>
<tr>
<td align="center"><code>index</code></td>
<td align="left"><code>index scan</code> index 和 all的区别在于index类型只遍历索引</td>
</tr>
<tr>
<td align="center"><code>range</code></td>
<td align="left">索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between，等查询</td>
</tr>
<tr>
<td align="center"><code>ref</code></td>
<td align="left">非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找</td>
</tr>
<tr>
<td align="center"><code>eq_ref</code></td>
<td align="left">唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描</td>
</tr>
<tr>
<td align="center"><code>const, system</code></td>
<td align="left">当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量</td>
</tr>
<tr>
<td align="center"><code>possible_keys</code></td>
<td align="left">显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</td>
</tr>
<tr>
<td align="center"><code>key</code></td>
<td align="left">实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用<code>USE INDEX（indexname）</code>来强制使用一个索引或者用<code>IGNORE INDEX（indexname）</code>来强制MySQL忽略索引</td>
</tr>
<tr>
<td align="center"><code>key_len</code></td>
<td align="left">使用的索引的长度。在不损失精确性的情况下，长度越短越好</td>
</tr>
<tr>
<td align="center"><code>rows</code></td>
<td align="left">MySQL认为必须检查的用来返回请求数据的行数</td>
</tr>
<tr>
<td align="center"><code>Extra</code></td>
<td align="left">关于MySQL如何解析查询的额外信息</td>
</tr>
</tbody></table>
<h2 id="43-数据库组主从复制的方式"><a href="#43-数据库组主从复制的方式" class="headerlink" title="43. 数据库组主从复制的方式"></a>43. 数据库组主从复制的方式</h2><ul>
<li>同步复制</li>
</ul>
<blockquote>
<p>所谓同步复制，意思是master的变化，必须等待<code>slave-1, slave-2, ..., slave-n</code>完成后才能返回。这显然不可取，也不是MySQL复制的默认设置。比如在Web全段页面上，用户增加了一条记录，需要等待很长时间。</p>
</blockquote>
<ul>
<li>异步复制</li>
</ul>
<blockquote>
<p>异步也就同ajax请求一样，master秩序完成自己的数据操作即可，至于slaves是否接收到二进制日志、是否完成操作，不需要关心，这是MySQL的默认设置。</p>
</blockquote>
<ul>
<li>半同步复制</li>
</ul>
<blockquote>
<p>master只保证slaves中的一个操作成功就返回，其他的不管。这个是由goole为MySQL引入的。</p>
</blockquote>
<h2 id="44-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）"><a href="#44-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）" class="headerlink" title="44. 数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）"></a>44. 数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）</h2><ul>
<li>Undo Log</li>
</ul>
<blockquote>
<p>为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog），然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。</p>
</blockquote>
<blockquote>
<p>为了保证事务持久性，必须将数据在事务提交前写到磁盘,只要事务成功提交，数据必然已经持久化。Undo log必须先于数据持久化到磁盘，如果在G,H之间系统崩溃，undo log是完整的， 可以用来回滚事务；如果在A-F之间系统崩溃，因为数据没有持久化到磁盘，所以磁盘上的数据还是保持在事务开始前的状态。</p>
</blockquote>
<blockquote>
<p>缺陷：每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少IO提高性能，但这样就会丧失事务的持久性。</p>
</blockquote>
<ul>
<li>Redo Log</li>
</ul>
<blockquote>
<p>原理和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化，系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。</p>
</blockquote>
<h1 id="Mysql数据库"><a href="#Mysql数据库" class="headerlink" title="Mysql数据库"></a>Mysql数据库</h1><h2 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1. 创建数据库"></a>1. 创建数据库</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- utf-8</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_name <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- gbk</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_name <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> gbk <span class="keyword">COLLATE</span> gbk_chinese_ci;</span><br></pre></td></tr></table></figure>

<h2 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2. 用户管理"></a>2. 用户管理</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建用户</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'密码'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除用户</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改用户</span></span><br><span class="line"><span class="keyword">rename</span> <span class="keyword">user</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span>; to '新用户名'@'IP地址';;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改密码</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">password</span> <span class="keyword">for</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span> = <span class="keyword">Password</span>(<span class="string">'新密码'</span>);</span><br><span class="line"><span class="comment">-- 或者用update更新user</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">password</span>=<span class="keyword">password</span>(<span class="string">'123'</span>) <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">'root'</span> <span class="keyword">and</span> host=<span class="string">'localhost'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改需要刷新才生效</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-授权管理"><a href="#3-授权管理" class="headerlink" title="3. 授权管理"></a>3. 授权管理</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看权限</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">grant</span> <span class="keyword">for</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授权</span></span><br><span class="line"><span class="keyword">grant</span> 权限 <span class="keyword">on</span> database1.table1 <span class="keyword">to</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 取消权限</span></span><br><span class="line"><span class="keyword">revoke</span> 权限 <span class="keyword">on</span> database1.table1 <span class="keyword">from</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-修改表的列"><a href="#4-修改表的列" class="headerlink" title="4. 修改表的列"></a>4. 修改表的列</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">column</span> <span class="built_in">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 默认添加到最后一列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> age <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加到第一列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> addr <span class="built_in">char</span>(<span class="number">12</span>) <span class="keyword">first</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加到addr列后面</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> phone <span class="keyword">after</span> addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">drop</span> phone;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改列，只修改类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">modify</span> <span class="keyword">column</span> phone <span class="built_in">INTEGER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列名和类型同时修改</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">change</span> <span class="keyword">column</span> <span class="keyword">name</span> myname <span class="built_in">varchar</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h2 id="5-键的操作"><a href="#5-键的操作" class="headerlink" title="5. 键的操作"></a>5. 键的操作</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加主键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> primary <span class="keyword">key</span>(<span class="keyword">id</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除主键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">drop</span> primary <span class="keyword">key</span>(<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">modify</span> <span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">drop</span> primary <span class="keyword">key</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 从表 <span class="keyword">add</span> <span class="keyword">constraint</span> 从键名称 foreign_key 从表(外键字段)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> foreign_key key_name</span><br></pre></td></tr></table></figure>

<h2 id="6-设置默认值"><a href="#6-设置默认值" class="headerlink" title="6. 设置默认值"></a>6. 设置默认值</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置默认值</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">alter</span> age <span class="keyword">set</span> <span class="keyword">default</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除默认值</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">alter</span> age <span class="keyword">drop</span> <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<h2 id="7-SQL语句基础"><a href="#7-SQL语句基础" class="headerlink" title="7. SQL语句基础"></a>7. SQL语句基础</h2><p><strong><a href="https://www.runoob.com/sql/sql-tutorial.html" target="_blank" rel="noopener">SQL基础知识</a></strong></p>
<ul>
<li>select语句</li>
</ul>
<blockquote>
<p>格式：select 字段 from 表名； 全部字段可以用 *</p>
</blockquote>
<ul>
<li>where 用于限制查询的结果</li>
</ul>
<blockquote>
<p>格式：<code>where 字段=&#39;xxx&#39;;</code> 查询条件&gt; &lt; &gt;= &lt;= = !=</p>
</blockquote>
<ul>
<li><p>与(AND)或(OR)</p>
</li>
<li><p>在(IN)不在(NOT IN)</p>
</li>
<li><p>空(NULL)非空(NOT NULL)</p>
</li>
<li><p>全部(ALL) 任一(ANY)</p>
</li>
<li><p>在[a,b]之间</p>
</li>
</ul>
<blockquote>
<p>格式：between a and b</p>
</blockquote>
<ul>
<li>排重DISTINCT</li>
</ul>
<blockquote>
<p>格式：<code>select DISTINCT 字段 from 表名;</code></p>
</blockquote>
<ul>
<li>insert语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(列名,列名) <span class="keyword">values</span>(值,值);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb1(<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'luck'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>update语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 更新数据</span></span><br><span class="line"><span class="keyword">update</span> tb1 <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'zhangsan'</span> <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>delete语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb1 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">name</span> = <span class="string">'luck'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="8-排序"><a href="#8-排序" class="headerlink" title="8. 排序"></a>8. 排序</h2><ul>
<li>ORDER BY语句</li>
</ul>
<blockquote>
<p>格式：<code>select 字段 from 表名 where 条件 ORDER BY 字段;</code></p>
</blockquote>
<ul>
<li>升序(ASC)与降序(DESC)</li>
</ul>
<blockquote>
<p>格式：<code>select 字段 from 表名 where 条件 ORDER BY 字段 ASC;</code></p>
</blockquote>
<blockquote>
<p>格式：<code>select 字段 from 表名 where 条件 ORDER BY 字段 DESC;</code>  </p>
</blockquote>
<ul>
<li>多项排序</li>
</ul>
<blockquote>
<p>格式：<code>select 字段 from 表名 where 条件 ORDER BY 字段 ASC|DESC，字段ASC|DESC;</code></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 升序</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表 <span class="keyword">order</span> <span class="keyword">by</span> 列 <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 降序</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表 <span class="keyword">order</span> <span class="keyword">by</span> 列 <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多项排序</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表 <span class="keyword">order</span> <span class="keyword">by</span> 列<span class="number">1</span> <span class="keyword">desc</span>,列<span class="number">2</span> <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>

<h2 id="9-聚合函数"><a href="#9-聚合函数" class="headerlink" title="9. 聚合函数"></a>9. 聚合函数</h2><blockquote>
<p>把 select 语句的查询结果汇聚成一个结果，这样的函数叫聚合函数。</p>
</blockquote>
<ul>
<li><p>最大值(MAX)</p>
</li>
<li><p>最小值(MIN)</p>
</li>
<li><p>平均值(SVG)</p>
</li>
<li><p>求和(SUM)</p>
</li>
<li><p>统计数量(COUNT)</p>
</li>
</ul>
<h2 id="10-分组"><a href="#10-分组" class="headerlink" title="10. 分组"></a>10. 分组</h2><ul>
<li>GROUP BY</li>
</ul>
<blockquote>
<p>格式：<code>select 组函数 from 表 where 条件 group by 字段;</code><br>特别的<code>group by</code> 必须在where之后,<code>order by</code>之前</p>
</blockquote>
<ul>
<li>HAVING 组判断条件，它的真假决定一组数据是否返回</li>
</ul>
<blockquote>
<p>格式：<code>select 组函数 from 表 where 条件 group by 字段 having 组判断条件;</code></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> tb1 <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">num</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">num</span>, <span class="keyword">id</span> <span class="keyword">from</span> tb1 <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">num</span>, <span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">num</span>, <span class="keyword">id</span> <span class="keyword">from</span> tb1 <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">5</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">num</span>, <span class="keyword">id</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">num</span>, <span class="keyword">id</span> <span class="keyword">count</span>(*), <span class="keyword">sum</span>(score), <span class="keyword">max</span>(score), <span class="keyword">min</span>(score) <span class="keyword">from</span> tb1 <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">num</span>, <span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> tb1 <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">num</span> <span class="keyword">having</span> <span class="keyword">max</span>(<span class="keyword">id</span>) &gt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="11-关联查询"><a href="#11-关联查询" class="headerlink" title="11. 关联查询"></a>11. 关联查询</h2><ul>
<li>JOIN：如果表中有至少一个匹配，则返回行  </li>
</ul>
<blockquote>
<p>格式：<code>select * from a join b on a.id=b.id;</code></p>
</blockquote>
<ul>
<li>内连接(INNER JOIN)：只返回两个表中联结字段相等的行</li>
</ul>
<blockquote>
<p>格式：<code>select * from a inner join b on a.id=b.id;</code>  其中inner可以省略，等同于JOIN的用法</p>
</blockquote>
<ul>
<li>左外连接(LEFT JOIN 或 LEFT OUTER JOIN)：即使右表中没有匹配，也从左表返回所有的行</li>
</ul>
<blockquote>
<p>格式：<code>select * from a left outer join b on a.id=b.aid;</code>  其中outer可忽略</p>
</blockquote>
<ul>
<li>右外连接(RIGHT JOIN 或 RIGHT OUTER JOIN)：即使左表中没有匹配，也从右表返回所有的行</li>
</ul>
<blockquote>
<p>格式：<code>select * from a right outer join b on a.id=b.aid;</code>  其中outer可忽略</p>
</blockquote>
<ul>
<li>全连接(FULL JOIN 或 FULL OUTER JOIN): 只要其中一个表中存在匹配，就返回行。相当于左外连接+右外链接，注意mysql不支持全连接</li>
</ul>
<blockquote>
<p>格式：<code>select * from a full outer join b on a.id=b.id;</code> 其中outer可忽略</p>
</blockquote>
<ul>
<li>自连接：自连接意思是把自身表当成另外一张表看待，互相关联查询，连接方式可以使用以上的内外连接，这种连接方式可以解决很多奇怪的问题。</li>
</ul>
<blockquote>
<p>格式：<code>SELECT ab.* from a ab,a ac where ab.id&gt;ac.id;</code></p>
</blockquote>
<h2 id="12-组合"><a href="#12-组合" class="headerlink" title="12. 组合"></a>12. 组合</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 组合，自动处理重合</span></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> A <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> B;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 组合，不处理重合</span></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> A <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> B;</span><br></pre></td></tr></table></figure>

<h2 id="13-LIMIT的用法"><a href="#13-LIMIT的用法" class="headerlink" title="13. LIMIT的用法"></a>13. LIMIT的用法</h2><blockquote>
<p>格式：<code>select * from student limit 10;</code>  查询前10条数据，显示1-10条数据</p>
</blockquote>
<blockquote>
<p>格式：<code>select * from student limit 1,10;</code>  查询从第2行开始，累加10条id记录，共显示id为2….11</p>
</blockquote>
<blockquote>
<p>格式：<code>select * from student limit 5,10;</code>  查询从第6行开始向前加10条数据，共显示id为6,7….15  </p>
</blockquote>
<blockquote>
<p>格式：<code>select * from student limit i,n;</code>  i: 为查询结果的索引值(默认从0开始),当i=0时可省略i; n: 为查询结果返回的数量</p>
</blockquote>
<h2 id="14-case-when"><a href="#14-case-when" class="headerlink" title="14. case when"></a>14. case when</h2><p><strong><a href="https://www.cnblogs.com/aipan/p/7770611.html" target="_blank" rel="noopener">CASE WHEN 及 SELECT CASE WHEN的用法</a></strong><br><strong><a href="https://www.cnblogs.com/cx-zyq/archive/2013/05/16/3082295.html" target="_blank" rel="noopener">SQL Case when 的使用方法</a></strong></p>
<ul>
<li>简单Case函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CASE sex</span><br><span class="line">WHEN '1' THEN '男'</span><br><span class="line">WHEN '2' THEN '女'</span><br><span class="line">ELSE '其他' <span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Case搜索函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CASE WHEN sex = '1' THEN '男'</span><br><span class="line">WHEN sex = '2' THEN '女'</span><br><span class="line">ELSE '其他' <span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>两种方式，可以实现相同的功能。简单Case函数的写法相对比较简洁，但是和Case搜索函数相比，功能方面会有些限制，比如写判断式。还有一个需要注意的问题，Case函数只返回第一个符合条件的值，剩下的Case部分将会被自动忽略。</p>
</blockquote>
<p><strong>实例分析：</strong></p>
<p>(1). 已知数据按照另外一种方式进行分组，分析</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*根据这个国家人口数据，统计亚洲和北美洲的人口数量*/</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">SUM</span>(population),</span><br><span class="line"><span class="keyword">CASE</span> country  <span class="keyword">WHEN</span> <span class="string">'中国'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="string">'印度'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="string">'日本'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="string">'美国'</span> <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="string">'加拿大'</span>  <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="string">'墨西哥'</span>  <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'其他'</span> <span class="keyword">END</span></span><br><span class="line"><span class="keyword">FROM</span>    Table_A</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">CASE</span> country </span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'中国'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'印度'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'日本'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'美国'</span> <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'加拿大'</span>   <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'墨西哥'</span>   <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'其他'</span> <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*判断工资的等级，并统计每一等级的人数*/</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary &lt;= <span class="number">500</span> <span class="keyword">THEN</span> <span class="string">'1'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">500</span> <span class="keyword">AND</span> salary &lt;= <span class="number">600</span>  <span class="keyword">THEN</span> <span class="string">'2'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">600</span> <span class="keyword">AND</span> salary &lt;= <span class="number">800</span>  <span class="keyword">THEN</span> <span class="string">'3'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">800</span> <span class="keyword">AND</span> salary &lt;= <span class="number">1000</span> <span class="keyword">THEN</span> <span class="string">'4'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span> salary_class, <span class="comment">-- 别名命名</span></span><br><span class="line"><span class="keyword">COUNT</span>(*)  <span class="keyword">FROM</span>    Table_A</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary &lt;= <span class="number">500</span> <span class="keyword">THEN</span> <span class="string">'1'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">500</span> <span class="keyword">AND</span> salary &lt;= <span class="number">600</span>  <span class="keyword">THEN</span> <span class="string">'2'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">600</span> <span class="keyword">AND</span> salary &lt;= <span class="number">800</span>  <span class="keyword">THEN</span> <span class="string">'3'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">800</span> <span class="keyword">AND</span> salary &lt;= <span class="number">1000</span> <span class="keyword">THEN</span> <span class="string">'4'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>(2). 用一个SQL语句完成不同条件的分组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*按照国家和性别进行分组*/</span></span><br><span class="line"><span class="keyword">SELECT</span> country, </span><br><span class="line"><span class="keyword">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="string">'1'</span> <span class="keyword">THEN</span>  population <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>),  <span class="comment">--男性人口</span></span><br><span class="line"><span class="keyword">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="string">'2'</span> <span class="keyword">THEN</span>  population <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)   <span class="comment">--女性人口</span></span><br><span class="line"><span class="keyword">FROM</span>  Table_A  <span class="keyword">GROUP</span> <span class="keyword">BY</span> country;</span><br></pre></td></tr></table></figure>

<p>(3). 在Check中使用Case函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*公司A，这个公司有个规定，女职员的工资必须高于1000块*/</span></span><br><span class="line">CONSTRAINT check_salary <span class="keyword">CHECK</span></span><br><span class="line">( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">THEN</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary &gt; <span class="number">1000</span></span><br><span class="line"><span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="number">1</span> <span class="keyword">END</span> = <span class="number">1</span> )</span><br></pre></td></tr></table></figure>

<p>(4). 根据条件有选择的UPDATE</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1.工资5000以上的职员，工资减少10% */</span></span><br><span class="line"><span class="keyword">UPDATE</span> Personnel  <span class="keyword">SET</span> salary = salary * <span class="number">0.9</span>  <span class="keyword">WHERE</span> salary &gt;= <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.工资在2000到4600之间的职员，工资增加15% */</span></span><br><span class="line"><span class="keyword">UPDATE</span> Personnel  <span class="keyword">SET</span> salary = salary * <span class="number">1.15</span> <span class="keyword">WHERE</span> salary &gt;= <span class="number">2000</span> <span class="keyword">AND</span> salary &lt; <span class="number">4600</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.如果满足条件1和条件2，顺序执行则会出现问题。</span></span><br><span class="line"><span class="comment">假设有个人工资5000块。首先，按照条件1，工资减少10%，变成工资4500。</span></span><br><span class="line"><span class="comment">接下来运行第二个SQL时候，因为这个人的工资是4500在2000到4600的范围之内，需增加15%，</span></span><br><span class="line"><span class="comment">最后这个人的工资结果是5175,不但没有减少，反而增加了。</span></span><br><span class="line"><span class="comment">如果要是反过来执行，那么工资4600的人相反会变成减少工资。 </span></span><br><span class="line"><span class="comment">这里用到case when 进行不同条件的更新*/</span></span><br><span class="line"><span class="keyword">UPDATE</span> Personnel</span><br><span class="line"><span class="keyword">SET</span> salary =</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary &gt;= <span class="number">5000</span>  　                <span class="keyword">THEN</span> salary * <span class="number">0.9</span></span><br><span class="line">     <span class="keyword">WHEN</span> salary &gt;= <span class="number">2000</span> <span class="keyword">AND</span> salary &lt; <span class="number">4600</span>  <span class="keyword">THEN</span> salary * <span class="number">1.15</span></span><br><span class="line"><span class="keyword">ELSE</span> salary <span class="keyword">END</span>;  <span class="comment">-- 这行else必须写，不写会导致不符合这两个条件的工资会变成NULL</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 把主键a和b相互交换 */</span></span><br><span class="line"><span class="keyword">UPDATE</span> SomeTable</span><br><span class="line"><span class="keyword">SET</span> p_key = <span class="keyword">CASE</span> <span class="keyword">WHEN</span> p_key = <span class="string">'a'</span>  <span class="keyword">THEN</span> <span class="string">'b'</span></span><br><span class="line"><span class="keyword">WHEN</span> p_key = <span class="string">'b'</span>  <span class="keyword">THEN</span> <span class="string">'a'</span>  <span class="keyword">ELSE</span> p_key <span class="keyword">END</span></span><br><span class="line"><span class="keyword">WHERE</span> p_key <span class="keyword">IN</span> (<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>检查两个表数据是否一致</li>
</ul>
<blockquote>
<p>Case函数不同于DECODE函数。在Case函数中，可以使用BETWEEN,LIKE,IS NULL,IN,EXISTS等等。比如说使用IN,EXISTS，可以进行子查询，从而 实现更多的功能。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--使用IN的时候</span></span><br><span class="line"><span class="keyword">SELECT</span> keyCol,</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> keyCol <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> keyCol <span class="keyword">FROM</span> tbl_B )  <span class="keyword">THEN</span> <span class="string">'Matched'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'Unmatched'</span> <span class="keyword">END</span> Label</span><br><span class="line"><span class="keyword">FROM</span> tbl_A;</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用EXISTS的时候</span></span><br><span class="line"><span class="keyword">SELECT</span> keyCol,</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">EXISTS</span> ( <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_B  <span class="keyword">WHERE</span> tbl_A.keyCol = tbl_B.keyCol )  <span class="keyword">THEN</span> <span class="string">'Matched'</span>  <span class="keyword">ELSE</span> <span class="string">'Unmatched'</span> <span class="keyword">END</span> Label</span><br><span class="line"><span class="keyword">FROM</span> tbl_A;</span><br></pre></td></tr></table></figure>

<ul>
<li>在Case函数中使用合计函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Studentclass</span></span><br><span class="line"><span class="comment">+------+----------+--------------+-----------------+</span></span><br><span class="line"><span class="comment">|std_id| class_id |  class_name  |  main_class_flg |</span></span><br><span class="line"><span class="comment">+------+----------+--------------+-----------------+</span></span><br><span class="line"><span class="comment">| 100  |    1     |     经济学    |        Y        |</span></span><br><span class="line"><span class="comment">| 100  |    2     |     历史学    |        N        |</span></span><br><span class="line"><span class="comment">| 200  |    2     |     历史学    |        N        |</span></span><br><span class="line"><span class="comment">| 200  |    3     |     考古学    |        Y        |</span></span><br><span class="line"><span class="comment">| 200  |    4     |     计算机    |        N        |</span></span><br><span class="line"><span class="comment">| 300  |    4     |     计算机    |        N        |</span></span><br><span class="line"><span class="comment">| 400  |    5     |      化学     |        N        |</span></span><br><span class="line"><span class="comment">| 500  |    6     |      数学     |        N        |</span></span><br><span class="line"><span class="comment">+------+----------+---------------+----------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--条件1：只选择了一门课程的学生, 返回那门课程的ID</span></span><br><span class="line"><span class="keyword">SELECT</span> std_id, <span class="keyword">MAX</span>(class_id) <span class="keyword">AS</span> main_class  <span class="keyword">FROM</span> Studentclass  <span class="keyword">GROUP</span> <span class="keyword">BY</span> std_id  <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--条件2：选择多门课程的学生, 返回所选的主课程ID</span></span><br><span class="line"><span class="keyword">SELECT</span> std_id, class_id <span class="keyword">AS</span> main_class  <span class="keyword">FROM</span> Studentclass  <span class="keyword">WHERE</span> main_class_flg = <span class="string">'Y'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用Case函数,满足以上两个条件</span></span><br><span class="line"><span class="keyword">SELECT</span>  std_id, </span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">COUNT</span>(*) = <span class="number">1</span>                   <span class="keyword">THEN</span> <span class="keyword">MAX</span>(class_id)</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> main_class_flg = <span class="string">'Y'</span>  <span class="keyword">THEN</span> class_id  <span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span>)</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> main_class</span><br><span class="line"><span class="keyword">FROM</span> Studentclass  <span class="keyword">GROUP</span> <span class="keyword">BY</span> std_id;</span><br></pre></td></tr></table></figure>

<ul>
<li>select case when</li>
</ul>
<blockquote>
<p>select 与 case结合使用最大的好处有两点，一是在显示查询结果时可以灵活的组织格式，二是有效避免了多次对同一个表或几个表的访问。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 例如表 students(id, name ,birthday, sex, grade)，要求按每个年级统计男生和女生的数量各是多少，统计结果的表头为，年级，男生数量，女生数量。如果不用select case when，为了将男女数量并列显示，统计起来非常麻烦，先确定年级信息，再根据年级取男生数和女生数，而且很容易出错。*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> grade, <span class="keyword">COUNT</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="number">1</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                            <span class="keyword">ELSE</span> <span class="literal">NULL</span></span><br><span class="line">                        <span class="keyword">END</span>) 男生数,</span><br><span class="line">               <span class="keyword">COUNT</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="number">2</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                            <span class="keyword">ELSE</span> <span class="literal">NULL</span></span><br><span class="line">                       <span class="keyword">END</span>) 女生数</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> grade;</span><br></pre></td></tr></table></figure>

<h2 id="15-mysql-常用数据类型"><a href="#15-mysql-常用数据类型" class="headerlink" title="15. mysql 常用数据类型"></a>15. mysql 常用数据类型</h2><ul>
<li><p>字符串类型</p>
<ul>
<li>CHAR：0-255 bytes, 存定长字符串</li>
<li>VARCHAR：0-65535 bytes, 存不定长字符串</li>
<li>TINYBLOB: 0-255 bytes, 不超过 255 个字符的二进制字符串</li>
<li>TINYTEXT: 0-255 bytes, 短文本字符串</li>
<li>BLOB: 0-65535 bytes, 二进制形式的长文本数据</li>
<li>TEXT: 0-65535 bytes, 长文本数据</li>
<li>MEDIUMBLOB: 0-16777215 bytes, 二进制形式的中等长度文本数据</li>
<li>MEDIUMTEXT: 0-16777215 bytes, 中等长度文本数据</li>
<li>LONGBLOB: 0-4294967295 bytes, 二进制形式的极大文本数据</li>
<li>LONGTEXT: 0-4294967295 bytes, 极大文本数据</li>
</ul>
</li>
<li><p>数值类型</p>
<ul>
<li>TINYINT: 1 bytes, 有符号范围(-128，127)、无符号范围(0，255)</li>
<li>SMALLINT: 2 bytes, 有符号范围(-32768，32767)、无符号范围(0，65535)</li>
<li>MEDIUMINT: 3 bytes, 有符号范围(-8388608，8388607)、无符号范围(0，16777215)</li>
<li>INT/INTEGER: 4 bytes, 有符号范围(-2147483648，2147483647)、无符号范围(0，4294967295)</li>
<li>BIGINT: 8 bytes, 有符号范围(-9223372036854775808，9223372036854775807)、无符号范围(0，18446744073709551615)</li>
<li>FLOAT: 4 bytes, 有符号范围[(-3.402823466E+38，-1.175494351 E-38)，0，(1.175494351E-38，3.402823466351E+38)]、无符号范围<code>[0，(1.175494351E-38，3.402823466E+38)]</code></li>
<li>DOUBLE: 8 bytes, 有符号范围[(-1.7976931348623157E+308，-2.2250738585072014E-308)，0，(2.2250738585072014E-308，1.797 6931348623157E+308)]、无符号范围[0，(2.2250738585072014 E-308，1.7976931348623157E+308)]</li>
<li>DECIMAL: DECIMAL(M, D), 若M&gt;D，这为大小为M+2，否则为D+2</li>
</ul>
</li>
<li><p>日期类型</p>
<ul>
<li>DATE: 3 bytes, <code>YYYY-MM-DD（1000-01-01/9999-12-31）</code></li>
<li>TIME: 3 bytes, <code>HH:MM:SS（&#39;-838:59:59&#39;/&#39;838:59:59&#39;）</code></li>
<li>YEAR: 1 bytes, <code>YYYY（1901/2155）</code></li>
<li>DATETIME: 8 bytes, <code>YYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00/9999-12-31 23:59:59）</code></li>
<li>TIMESTAMP: 4 bytes, <code>YYYYMMDD HHMMSS（1970-01-01 00:00:00/2037 年某时）</code></li>
</ul>
</li>
</ul>
<h2 id="16-MySQL读取数据的基本单位"><a href="#16-MySQL读取数据的基本单位" class="headerlink" title="16. MySQL读取数据的基本单位"></a>16. MySQL读取数据的基本单位</h2><blockquote>
<p>在 MySQL 中数据读取的基本单位都是页，InnoDB 中页的默认大小是 16KB。</p>
</blockquote>
<h2 id="17-为什么mysql事务回滚后，自增ID依然自增"><a href="#17-为什么mysql事务回滚后，自增ID依然自增" class="headerlink" title="17. 为什么mysql事务回滚后，自增ID依然自增"></a>17. 为什么mysql事务回滚后，自增ID依然自增</h2><blockquote>
<p>因为<code>innodb</code>的<code>auto_increament</code>的计数器记录的当前值是保存在存内 存中的，并不是存在于磁盘上，当<code>mysql server</code>处于运行的时候，这个计数值只会随着<code>insert</code>改增长，不会随着<code>delete</code>而减少。</p>
</blockquote>
<blockquote>
<p>当<code>mysql server</code>启动时，当我们需要去查询<code>auto_increment</code>计数值时，mysql便会自动执行：<code>SELECT MAX(id) FROM 表名 FOR UPDATE;</code>语句来获得当前<code>auto_increment</code>列的最大值，然后将这个值放到<code>auto_increment</code>计数器中。所以就算Rollback MySQL的<code>auto_increament</code>计数器也不会作负运算。</p>
</blockquote>
<h2 id="18-mysql的主从复制的实现过程"><a href="#18-mysql的主从复制的实现过程" class="headerlink" title="18. mysql的主从复制的实现过程"></a>18. mysql的主从复制的实现过程</h2><p><strong><a href="https://www.cnblogs.com/cocoxu1992/p/10670589.html" target="_blank" rel="noopener">MySQL主从复制的实现过程</a></strong></p>
<ul>
<li><p>主从复制的作用</p>
<ul>
<li>主数据库出现问题，可以切换到从数据库</li>
<li>可以进行数据库层面的读写分离</li>
<li>可以在从数据库上进行日常备份</li>
</ul>
</li>
<li><p>主从复制的过程</p>
<ul>
<li>(1). master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中.</li>
<li>(2). salve开启一个<code>I/O Thread</code>，该线程在master打开一个普通连接，主要工作是<code>binlog dump process</code>。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志（Realy log）中。</li>
<li>(3). SQL Thread会读取中继日志（Realy log），并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</li>
</ul>
</li>
<li><p>具体步骤</p>
<ul>
<li><p>准备两台服务器，安装mysql</p>
<blockquote>
<p>主库是：192.168.x.x master<br>从库是：192.168.x.xx slave</p>
</blockquote>
</li>
<li><p>主库操作：</p>
<ul>
<li>（1）开启binlog功能，修改<code>vim /etc/my.cnf</code>配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">&lt;!-- 指明主库的身份id为1 --&gt;</span><br><span class="line">server-id=1</span><br><span class="line">&lt;!-- 指明binlog的日志名 --&gt;</span><br><span class="line"><span class="built_in">log</span>-bin=/var/<span class="built_in">log</span>/mysql/mysql-bin</span><br><span class="line">&lt;!-- 为了在使用带事务的InnoDB进行复制设置时尽可能提高持久性和一致性 --&gt;</span><br><span class="line">innodb_flush_log_at_trx_commit = 1</span><br><span class="line">sync_binlog = 1</span><br></pre></td></tr></table></figure>

<ul>
<li>（2）创建日志目录并赋予权限，重启mysql，使得binlog生效</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 创建日志目录 --&gt;</span><br><span class="line">mkdir /var/<span class="built_in">log</span>/mysql</span><br><span class="line">&lt;!-- 赋予权限 --&gt;</span><br><span class="line">chown mysql.mysql /varlog/mysql</span><br><span class="line">&lt;!-- mysqld重启服务 --&gt;</span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<ul>
<li>（3）登录mysql，检查主库的状态</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>（4）创建一个用户，用于进行主从同步</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'database_backup'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'database_backup_666'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>（5）授予账号权限，授予一个从库的身份权限</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> . <span class="keyword">to</span> <span class="string">'database_backup'</span>@<span class="string">'%'</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>（6）锁定mysql的表，防止数据写入</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">table</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>（7）这一步需要等下面到处数据完成后，然后解除锁表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出数据</p>
<ul>
<li>导出当前的数据，用于slave机器导入数据，保证在一个起始点</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump -u root -p <span class="comment">--all-databases &gt; /data/db.dump;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将此db.dump文件远程传输给 slave机器，用于导入</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp /data/db.dump root@192.168.x.x:/tmp/</span><br></pre></td></tr></table></figure>
</li>
<li><p>从库操作：</p>
<ul>
<li>（1）修改<code>vim /etc/my.cnf</code>配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=2</span><br></pre></td></tr></table></figure>

<ul>
<li>（2）重启mysql，使得binlog生效</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- mysqld重启服务 --&gt;</span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<ul>
<li>（3）登录slave从库，导入主库的数据信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">source /tmp/db.dump;</span><br></pre></td></tr></table></figure>

<ul>
<li>（4）从数据库上进行复制行为的相关配置</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">'192.168.x.xx'</span>,</span><br><span class="line">master_user=<span class="string">'database_backup'</span>,</span><br><span class="line">master_password=<span class="string">'database_backup_666'</span>,</span><br><span class="line">master_log_file=<span class="string">'mysql-bin.000001'</span>,  <span class="comment">-- 根据show master status给出的状态</span></span><br><span class="line">master_log_pos=<span class="number">666</span>;  <span class="comment">-- 根据show master status给出的状态</span></span><br></pre></td></tr></table></figure>

<ul>
<li>（5）启动slave线程</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">slave <span class="keyword">start</span>;</span><br></pre></td></tr></table></figure>

<p>-（6）检查slave状态，检查两条参数，如果都是yes，即主从ok</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="19-mysql高并发环境解决方案"><a href="#19-mysql高并发环境解决方案" class="headerlink" title="19. mysql高并发环境解决方案"></a>19. mysql高并发环境解决方案</h2><ul>
<li>水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力；</li>
<li>集群方案，解决DB宕机带来的单点DB不能访问问题；</li>
<li>读写分离策略，极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力；</li>
</ul>
<h1 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h1><h2 id="1-什么是Redis"><a href="#1-什么是Redis" class="headerlink" title="1. 什么是Redis"></a>1. 什么是Redis</h2><blockquote>
<p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>
</blockquote>
<blockquote>
<p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>
</blockquote>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<blockquote>
<p>Redis的优势：</p>
</blockquote>
<ul>
<li>性能极高：Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>丰富的数据类型：Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>原子性：Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li>丰富的特性：Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>
</ul>
<blockquote>
<p>Redis与其他key-value存储有什么不同</p>
</blockquote>
<ul>
<li><p>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</p>
</li>
<li><p>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p>
</li>
</ul>
<p><strong><a href="https://www.runoob.com/redis/redis-intro.html" target="_blank" rel="noopener">以上来源于《菜鸟教程–Redis简介》</a></strong></p>
<h2 id="2-redis的数据类型"><a href="#2-redis的数据类型" class="headerlink" title="2. redis的数据类型"></a>2. redis的数据类型</h2><ul>
<li>字符串(String)</li>
</ul>
<blockquote>
<p>string类型是二进制安全的，可以包含任何数据，比如JPG图片或者序列化对象。string类型是Redis最基本的数据类型，一个键最大能存储512MB。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置字符串类型</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key value</span><br><span class="line"><span class="comment"># 读取字符串类型</span></span><br><span class="line">127.0.0.1:6379&gt; get key value</span><br></pre></td></tr></table></figure>

<ul>
<li>哈希(Hash)</li>
</ul>
<blockquote>
<p>hash存的是字符串和字符串值之间的映射，是一个键值(key=&gt;value)对集合，比如用户存储姓名、年龄等信息，非常适合存储对象。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立哈希，并赋值</span></span><br><span class="line">127.0.0.1:6379&gt; hmset name key1 value1 key2 value2 ...</span><br><span class="line">127.0.0.1:6379&gt; hmset user:001 username liming <span class="built_in">pwd</span> 123456 age 18</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出哈希的内容</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall user:001</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="string">"username"</span></span><br><span class="line"><span class="string">"liming"</span></span><br><span class="line"><span class="string">"pwd"</span></span><br><span class="line"><span class="string">"123456"</span></span><br><span class="line"><span class="string">"age"</span></span><br><span class="line"><span class="string">"18"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改哈希中的某一个值</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall user:001 <span class="built_in">pwd</span> aaaaaa</span><br><span class="line"><span class="comment"># 查看更改后的哈希的内容</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall user:001</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="string">"username"</span></span><br><span class="line"><span class="string">"liming"</span></span><br><span class="line"><span class="string">"pwd"</span></span><br><span class="line"><span class="string">"aaaaaa"</span></span><br><span class="line"><span class="string">"age"</span></span><br><span class="line"><span class="string">"18"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>列表(List)</li>
</ul>
<blockquote>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序，底层实现是链表，对于一个具有几百上千万个元素的list来说，在头部和尾部插入一个新元素，其时间复杂度是常数级别的，插入速度也是不变的。弊端就是链表型的list比数组型的list定位更慢。list主要应用在消息队列上，可以确保先后顺序，还可以利用<code>lrange</code>实现分页功能，博客系统中评论也可以存入一个单独的list中。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 头部插入元素</span></span><br><span class="line">127.0.0.1:6379&gt; lpush mylist <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尾部插入元素</span></span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">"2"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取list中的元素</span></span><br><span class="line">127.0.0.1:6379&gt; lrange mylist index1 index2 ...</span><br><span class="line"><span class="comment"># 读取list中编号0到倒数第一个元素</span></span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除元素</span></span><br><span class="line">127.0.0.1:6379&gt; lrem mylist index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取list长度</span></span><br><span class="line">127.0.0.1:6379&gt; llen mylist</span><br></pre></td></tr></table></figure>

<ul>
<li>集合(Set)</li>
</ul>
<blockquote>
<p>Redis的Set是string类型的无序且元素不重复的集合，集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)，同时可以进行集合运算：取交集、取并集、取差集等。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">"1"</span></span><br><span class="line"><span class="comment"># 读取元素</span></span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line"><span class="comment"># 删除元素</span></span><br><span class="line">127.0.0.1:6379&gt; srem myset <span class="string">"1"</span></span><br><span class="line"><span class="comment"># 判断元素是否存在，存在返回1，否则返回0</span></span><br><span class="line">127.0.0.1:6379&gt; sismember myset <span class="string">"1"</span></span><br><span class="line"><span class="comment"># 取交集</span></span><br><span class="line">127.0.0.1:6379&gt; sinter set1 set2</span><br><span class="line"><span class="comment"># 取并集</span></span><br><span class="line">127.0.0.1:6379&gt; sunion set1 set2</span><br><span class="line"><span class="comment"># 取差集</span></span><br><span class="line">127.0.0.1:6379&gt; sdiff set1 set2</span><br></pre></td></tr></table></figure>

<ul>
<li>有序集合(sorted set)</li>
</ul>
<blockquote>
<p>有序集合中，每个元素都会关联一个double类型的分数(score)，redis正是通过分数来为集合中的元素进行从小到大的排序。有序集合中的元素是唯一的，但分数(score)可以重复。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加元素，赋予序号1</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 1 aa</span><br><span class="line"><span class="comment"># 添加元素，赋予序号2</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 2 bb</span><br><span class="line"><span class="comment"># 添加元素，赋予序号3</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 3 cc</span><br><span class="line"><span class="comment"># 读取元素，并输出序号（即score）</span></span><br><span class="line">127.0.0.1:6379&gt; zrange myzset 0 -1 with scores</span><br><span class="line"><span class="comment"># 得出排名</span></span><br><span class="line">127.0.0.1:6379&gt; zrange myzset cc</span><br></pre></td></tr></table></figure>

<h2 id="3-两种持久化方式"><a href="#3-两种持久化方式" class="headerlink" title="3. 两种持久化方式"></a>3. 两种持久化方式</h2><blockquote>
<p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
</blockquote>
<ul>
<li>RDB(Redis DataBase)</li>
</ul>
<blockquote>
<p>RDB是Redis默认的方式，就是把某一时刻的数据以快照的方式存储到磁盘等介质上。Redis在进行持久化过程中，会调用rdbSave()函数，把数据写到临时文件中，等持久化过程都结束了，才调用rdbLoad()函数加载上次持久化好的文件，并用新的临时文件进行覆盖，快照文件总是完整的。</p>
</blockquote>
<blockquote>
<p>Redis会单独创建一个子进程进行持久化，而主进程是不会进行任何IO操作，确保了Redis极高的性能。</p>
</blockquote>
<blockquote>
<p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。但是如果对数据的完整性非常敏感，RDB方式安全性低一些，可能在故障时丢失数据。</p>
</blockquote>
<ul>
<li>AOF(Append Only File)</li>
</ul>
<blockquote>
<p>Append Only File意思是只允许最佳不允许改写的文件，AOF的方式是将执行过程的所有写指令记录下来，在数据回复时按照冲钱到后顺序在将指令执行一遍。通过配置redis.conf中的<code>appendonly yes</code>就可以打开AOF功能，每当服务器执行定时任务或者函数时，都会调用<code>flushAppendOnlyFile()</code>函数，根据条件将aof_buf中的缓存写到AOF文件中，而后调用<code>fsync()</code>或 <code>fdatasync()</code>函数将AOF保存到磁盘中。其中AOF默认持久化的策略是每秒钟fsync一次，所以对数据安全更加有保障。</p>
</blockquote>
<blockquote>
<p>因为采用了追加的方式，不做处理的话，AOF文件将会越来越大，所以要使用AOF文件重写机制，当AOF文件大小超过说设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。如100条INCR指令可以合并层一条SET指令。</p>
</blockquote>
<blockquote>
<p>在进行AOF重写时，仍然先写入临时文件，全部完成后再进行替换，因此断电、磁盘满等问题都不会影响AOF文件的可用性。</p>
</blockquote>
<blockquote>
<p>在同样的数据规模下，AOF文件比RDB文件的体积更大，且AOF方式恢复数据的速度也比RDB方式慢。</p>
</blockquote>
<h2 id="4-RDB与AOF比较"><a href="#4-RDB与AOF比较" class="headerlink" title="4. RDB与AOF比较"></a>4. RDB与AOF比较</h2><ul>
<li>AOF文件比RDB更新更加频繁，因此AOF文件更大</li>
<li>AOF方式比RDB方式数据安全性更高</li>
<li>RDB性能比AOF更好</li>
<li>优先使用AOF还原数据</li>
</ul>
<h2 id="5-如果AOF文件出现被写坏的情况，该怎么处理"><a href="#5-如果AOF文件出现被写坏的情况，该怎么处理" class="headerlink" title="5. 如果AOF文件出现被写坏的情况，该怎么处理"></a>5. 如果AOF文件出现被写坏的情况，该怎么处理</h2><blockquote>
<p>出现AOF文件被写坏的情况，Redis并不会冒然加载这个有问题的AOF文件，而是报错退出，这时可以用过以下步骤来修复出错文件：</p>
</blockquote>
<ul>
<li>备份被写坏的AOF文件</li>
<li>运行<code>redis-check-aof -fix</code>进行修复</li>
<li>用<code>diff -u</code>比两个文件的差异，定位问题点并修复</li>
<li>重启redis，加载修复后的AOF文件</li>
</ul>
<h2 id="6-redis-和-memcached-的主要区别"><a href="#6-redis-和-memcached-的主要区别" class="headerlink" title="6. redis 和 memcached 的主要区别"></a>6. redis 和 memcached 的主要区别</h2><p><strong><a href="https://www.cnblogs.com/xingxia/p/redis_compare_memcache.html" target="_blank" rel="noopener">redis和memcached的区别详解</a></strong></p>
<ul>
<li>Redis支持服务器端的数据操作：相比于memcached，redis拥有更多是数据结构，所以支持更多的数据操作，而在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。</li>
<li>内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。</li>
<li>性能对比：redis只支持单核，memcached可以使用多核，所以平均每一个核上 redis 在存储小数据时比 memcached 性能更高，但是在大数据存储上的处理memcached性能更高。</li>
<li>redis内部使用的是文件事件处理器<code>file event handler</code>，是单线程模型，处理效率高。文件事件处理器的结构包含多个socket、IO多路复用程序（非阻塞）、文件事件分派器、事件处理器四个部分。</li>
<li>存储数据安全：Redis拥有持久化机制，而memcached没有。</li>
<li>应用场景：Redis除了作为NoSQL数据库使用外，还能做消息队列、数据堆栈和数据缓存等；而Memcached适用于缓存SQL语句、数据集、用户临时性数据、延迟查询数据和session等。</li>
</ul>
<h2 id="7-事务处理"><a href="#7-事务处理" class="headerlink" title="7. 事务处理"></a>7. 事务处理</h2><blockquote>
<p>Redis 事务可以一次执行多个命令，并且带有以下三个重要的保证：</p>
</blockquote>
<ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中</li>
</ul>
<blockquote>
<p>一个事务从开始到执行会经历开始事务、命令入队、执行事务三个阶段。</p>
</blockquote>
<blockquote>
<p>redis 通过 MULTI、EXEC、DISCARD、WATCH四个指令实现事务处理</p>
</blockquote>
<ul>
<li>MULTI用来组装一个事务</li>
<li>EXEC用来执行一个事务</li>
<li>DISCARD用来取消一个事务</li>
<li>WATCH用来监视一些key，一旦这些key在事务执行之前被改变，则取消事务的执行</li>
</ul>
<h2 id="8-Redis常见的架构模式"><a href="#8-Redis常见的架构模式" class="headerlink" title="8. Redis常见的架构模式"></a>8. Redis常见的架构模式</h2><h3 id="1-单机模式"><a href="#1-单机模式" class="headerlink" title="(1) 单机模式"></a>(1) 单机模式</h3><ul>
<li>内存容量有限</li>
<li>处理能力有限</li>
<li>无法高可用</li>
</ul>
<h3 id="2-主从复制模式"><a href="#2-主从复制模式" class="headerlink" title="(2) 主从复制模式"></a>(2) 主从复制模式</h3><blockquote>
<p>MySQL一样，redis是支持主从同步的，而且也支持一主多从以及多级从结构。一是为了纯粹的冗余备份，二是为了提升读性能。</p>
</blockquote>
<blockquote>
<p>通常我们会设置一个主节点，N个从节点，默认情况下，主节点负责处理使用者的IO操作，而从节点则会对主节点的数据进行备份，并且也会对外提供读操作的处理。</p>
</blockquote>
<blockquote>
<p>主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。</p>
</blockquote>
<blockquote>
<p>Redis的主从同步是异步进行的，不会阻塞主节点，主节点和从节点是读写分离的。</p>
</blockquote>
<blockquote>
<p>全量同步：Redis全量复制一般发生在slave初始化阶段，这时，需要将Master上所有数据都复制一份。具体步骤如下：</p>
</blockquote>
<ul>
<li>从服务器连接主服务器，发送SYNC命令</li>
<li>主服务器接收到SYNC命令后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令</li>
<li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令</li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照</li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令</li>
<li>从服务器完成对快照的载入，开始接受命令请求 ，并执行来自主服务器缓冲区的写命令</li>
</ul>
<blockquote>
<p>增量同步：通常情况下，Master每执行一个写命令就回向Slave发送相同的命令，然后slave接收并执行。只有slave第一次连接是全量同步，断线重连有可能是全量同步，也有可能是增量同步；除此之外都是增量同步。</p>
</blockquote>
<blockquote>
<p>Redis主从复制模式的优点：</p>
</blockquote>
<ul>
<li>解决数据备份问题</li>
<li>实现读写分离，降低读压力，提高服务器性能</li>
</ul>
<blockquote>
<p>Redis主从复制模式的缺点：</p>
</blockquote>
<ul>
<li>无法实现高可用，一旦出现故障需要人工进行故障转移</li>
<li>无法实现动态扩容，受单击控制</li>
</ul>
<h3 id="3-哨兵模式"><a href="#3-哨兵模式" class="headerlink" title="(3) 哨兵模式"></a>(3) 哨兵模式</h3><blockquote>
<p>sentinel是基于主从模式进行优化，能够为Redis提供高可用性。在实际生产中，服务器难免遇到服务器宕机、停电、硬件损坏等突发状况，哨兵模式可以一定程度上帮助规避这些意外情况导致的灾难性的后果。核心还是主从复制，增加了由一个或多个Sentinel实例组成的Sentinel系统，监视任意多个主服务器以及这些主服务器属下的所有从服务器，当主服务器宕机导致不可写或者下线状态时，自动将主服务器下的某个服务器升级为新的主服务器。这样，就保证了Redis的高可用，规避数据丢失风险。</p>
</blockquote>
<blockquote>
<p>sentinel的特点：</p>
</blockquote>
<ul>
<li>监控（Monitoring）：它会监听不断检查主服务器和从服务器之间是否在正常工作。</li>
<li>通知（Notification）：当监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理管或者其他应用程序发送通知。</li>
<li>故障自动转移（Automatic failover）：当一个主服务器出现故障不能正常工作时，Sentinel会在所有从服务器中选择一个作为新的主服务器，实现故障自动转移。</li>
<li>提供主服务器地址：能够向当前使用者提供当前主节点的地址，特别是在故障自动转移后，使用者不用做任何修改就可以知道当前的主节点地址。</li>
<li>sentinel也可以集群，部署多个哨兵，sentinel可以通过发布和订阅(pub/sub)来自动发现Redis集群上的其他Sentinel。sentinel在发现其它sentinel进程后，会将其放入一个列表中，这个列表存储了所有已被发现的sentinel。</li>
</ul>
<blockquote>
<p>Redis哨兵模式的优点：</p>
</blockquote>
<ul>
<li>保证高可用</li>
<li>监控各个节点</li>
<li>自动故障迁移</li>
</ul>
<blockquote>
<p>Redis哨兵模式的缺点：</p>
</blockquote>
<ul>
<li>切换需要时间，可能存在丢失数据风险</li>
<li>从节点下线，故障不能自动转移</li>
<li>无法实现动态扩容</li>
</ul>
<h3 id="4-集群模式"><a href="#4-集群模式" class="headerlink" title="(4) 集群模式"></a>(4) 集群模式</h3><p><strong><a href="http://www.redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">Redis 集群</a></strong></p>
<blockquote>
<p>Redis 集群是一个提供在多个Redis间节点间共享数据的程序集。Redis集群并不支持处理多个keys的命令，因为这需要在不同的节点间移动数据，从而达不到像Redis那样的性能，在高负载的情况下可能会导致不可预料的错误。</p>
</blockquote>
<blockquote>
<p>Redis 集群通过分区来提供一定程度的可用性，在实际环境中当某个节点宕机或者不可达的情况下继续处理命令。</p>
</blockquote>
<blockquote>
<p>Redis 集群没有使用一致性hash, 而是引入了 哈希槽的概念。Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽。集群的每个节点负责一部分hash槽，比如当前集群有3个节点，那么节点 A 包含 0 到 5500号哈希槽；节点 B 包含5501 到 11000 号哈希槽；节点 C 包含11001 到 16384号哈希槽；这种结构很容易添加或者删除节点，比如如果我想新添加个节点D，我需要从节点 A, B, C中得部分槽到D上。如果我想移除节点A，需要将A中的槽移到B和C节点上，然后将没有任何槽的A节点从集群中移除即可。由于从一个节点将哈希槽移动到另一个节点并不会停止服务，所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态。</p>
</blockquote>
<blockquote>
<p>一致哈希算法根据数据的key值计算映射位置时和所使用的节点数量有非常大的关系。一致哈希分区的实现思路是为系统中每个节点分配一个token，范围一般在0~2^32，这些token构成一个哈希环，数据读写执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于等于该hash值的token节点，需要操作的数据就保存在该节点上。</p>
</blockquote>
<blockquote>
<p>Redis 一致性保证 Redis 并不能保证数据的强一致性。这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
</blockquote>
<blockquote>
<p>投票过程是集群中所有master参与，如果半数以上master节点与master节点通信超时(cluster-node-timeout)，认为当前master节点挂掉。这时如果当前master没有slave，集群就进入fail状态；当集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态。</p>
</blockquote>
<blockquote>
<p>一般集群建议搭建三主三从架构，三主提供服务，三从提供备份功能。</p>
</blockquote>
<blockquote>
<p>Redis集群模式的优点：</p>
</blockquote>
<ul>
<li>有效解决了Redis在分布式方面的需求</li>
<li>遇到单击内存，并发和流量瓶颈问题时，可采用Cluster方案达到负载均衡的目的</li>
<li>可实现动态扩容，可线性扩展到1000个节点，节点可以动态的添加或删除</li>
<li>P2P模式，无中心化</li>
<li>自动故障转移，节点间通过Gossip协议同步节点信息，用投票机制完成slave到maser的角色提升</li>
<li>数据按照Slot存储分布在多个节点，节点间数据共享，可动态调整数据分布。</li>
<li>高可用性，部分节点不可用时，集群仍然可用，通过增加slave做备份数据副本</li>
</ul>
<blockquote>
<p>Redis集群模式的缺点：</p>
</blockquote>
<ul>
<li>架构比较新，最佳时间比较少</li>
<li>为了性能提升，客户端需要缓存路由表信息</li>
<li>节点发现、reshard操作不够自动化</li>
</ul>
<h2 id="9-Redis如何实现分布式锁"><a href="#9-Redis如何实现分布式锁" class="headerlink" title="9. Redis如何实现分布式锁"></a>9. Redis如何实现分布式锁</h2><blockquote>
<p>使用 setnx 实现枷锁，可以同时通过 expire 添加超时时间</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当key不存在时，为key设置一个值，否则在一定时间内进行尝试</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire_lock</span><span class="params">(conn, lockname, acquire_timeout=<span class="number">10</span>)</span>:</span></span><br><span class="line">    identifier = str(uuid.uuid4())</span><br><span class="line">    end = time.time() + acquire_timeout</span><br><span class="line">    <span class="keyword">while</span> time.time() &lt; end:</span><br><span class="line">        <span class="keyword">if</span> conn.setnx(<span class="string">'lock:'</span> + lockname, identifier):</span><br><span class="line">            <span class="keyword">return</span> identifier</span><br><span class="line">        time.sleep(<span class="number">0.001</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>锁的 value 值可以使用一个随机的 uuid 或者特定的命名</p>
</blockquote>
<blockquote>
<p>释放锁的时候，通过 uuid 判断是否是该锁，是则执行 delete 释放锁</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">release_lock</span><span class="params">(conn, lockname,identifier)</span>:</span></span><br><span class="line">    pipe = conn.pipeline(<span class="literal">True</span>)</span><br><span class="line">    lockname = <span class="string">'lock:'</span> + lockname</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pipe.watch(lockname)</span><br><span class="line">            <span class="keyword">if</span> pipe.get(lockname) == identifier:</span><br><span class="line">                pipe.multi()</span><br><span class="line">                pipe.delete(lockname)</span><br><span class="line">                pipe.execute()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            pipe.unwatch()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.WatcjError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="10-缓存使用场景"><a href="#10-缓存使用场景" class="headerlink" title="10. 缓存使用场景"></a>10. 缓存使用场景</h2><blockquote>
<p>缓解关系数据库并发访问的压力： 热点数据</p>
</blockquote>
<blockquote>
<p>减少响应时间：内存IO速度比磁盘快</p>
</blockquote>
<blockquote>
<p>提升吞吐量：redis等内存数据库单机就可以支撑很大并发</p>
</blockquote>
<h2 id="11-常用的缓存使用模式"><a href="#11-常用的缓存使用模式" class="headerlink" title="11. 常用的缓存使用模式"></a>11. 常用的缓存使用模式</h2><ul>
<li>Cache-Aside</li>
</ul>
<blockquote>
<p>Cache-Aside可能是项目中最常见的一种模式。它是一种控制逻辑都实现在应用程序中的模式。缓存不和数据库直接进行交互，而是由应用程序来同时和缓存以及数据库打交道，即同时更新缓存和数据库。</p>
</blockquote>
<blockquote>
<p>应用场景：应用于缓存不支持Read-Through/Write-Through的系统。</p>
</blockquote>
<blockquote>
<p>优点：缓存仅仅保存被请求的数据，属于懒加载模式，避免了任何数据都被写入缓存造成缓存频繁的更新。</p>
</blockquote>
<blockquote>
<p>缺点：当发生缓存未命中的情况时，则会比较慢，因为要经过三个步骤，查询缓存、从数据库读取、写入缓存；复杂的逻辑都在应用程序中，如果实现微服务，多个微服务中会有重复的逻辑代码。</p>
</blockquote>
<ul>
<li>Read-Through / Write Through</li>
</ul>
<blockquote>
<p>这种模式中，应用程序将缓存作为主要的数据源，而数据库对于应用程序是透明的，更新数据库和从数据库的读取的任务都交给缓存来代理了，所以对于应用程序来说，简单很多。先更新缓存，缓存负责同步更新数据库。</p>
</blockquote>
<blockquote>
<p>应用场景：写入之后经常被读取的应用。</p>
</blockquote>
<blockquote>
<p>优点：缓存不存在脏数据；相比较Cache-Aside懒加载模式，读取速度更高，因为较少因为缓存未命中而从数据库中查找；应用程序的逻辑相对简单。</p>
</blockquote>
<blockquote>
<p>缺点：对于总是写入却很少被读取的应用，那么Write-Through会非常浪费性能，因为数据可能更改了很多次，却没有被读取，白白的每次都写入缓存造成写入延迟。</p>
</blockquote>
<ul>
<li>Write-Back</li>
</ul>
<blockquote>
<p>又叫做Write-Behind，和Write-Through写入的时机不同，Write-Back将缓存作为可靠的数据源，每次都只写入缓存，而写入数据库则采用异步的方式，比如当数据要被移除出缓存的时候再存储到数据库或者一段时间之后批量更新数据库。即先更新缓存，缓存定期异步更新数据库。</p>
</blockquote>
<blockquote>
<p>应用场景：读写效率都非常好，写的时候因为异步存储到数据库，提升了写的效率，适用于读写密集的应用。</p>
</blockquote>
<blockquote>
<p>优点：写入和读取数据都非常的快，因为都是从缓存中直接读取和写入；对于数据库不可用的情况有一定的容忍度，即使数据库暂时不可用，系统也整体可用，当数据库之后恢复的时候，再将数据写入数据库。</p>
</blockquote>
<blockquote>
<p>缺点：有数据丢失的风险，如果缓存挂掉而数据没有及时写到数据库中，那么缓存中的有些数据将永久的丢失了。</p>
</blockquote>
<ul>
<li>Write-Around</li>
</ul>
<blockquote>
<p>和Write-Through不同，更新的时候只写入数据库，不写入缓存，结合Read-Through或者Cache-Aside使用，只在缓存未命中的情况下写缓存。</p>
</blockquote>
<blockquote>
<p>应用场景：适合于只写入一次而很少被读取的应用。</p>
</blockquote>
<blockquote>
<p>优点：相比较Write-Through写入的时候的效率较高，如果数据写入后很少被读取，缓存也不会被没用到的数据占满。</p>
</blockquote>
<blockquote>
<p>缺点：如果数据会写入多次，那么可能存在缓存和数据库不一致</p>
</blockquote>
<h2 id="12-什么是缓存穿透"><a href="#12-什么是缓存穿透" class="headerlink" title="12. 什么是缓存穿透"></a>12. 什么是缓存穿透</h2><blockquote>
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
</blockquote>
<blockquote>
<p>解决：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存；对一定不存在的key进行过滤，可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。</p>
</blockquote>
<h2 id="13-什么是缓存击穿"><a href="#13-什么是缓存击穿" class="headerlink" title="13. 什么是缓存击穿"></a>13. 什么是缓存击穿</h2><blockquote>
<p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期，热点数据key失效），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</p>
</blockquote>
<blockquote>
<p>解决：设置热点数据永远不过期；分布式锁；异步后台更新，后台任务针对过期的key自动刷新。</p>
</blockquote>
<h2 id="14-什么是缓存雪崩"><a href="#14-什么是缓存雪崩" class="headerlink" title="14. 什么是缓存雪崩"></a>14. 什么是缓存雪崩</h2><blockquote>
<p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力，导致系统崩溃。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
</blockquote>
<blockquote>
<p>解决：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量，比如对某个key只允许一个线程查询数据和写缓存，其他线程等待；做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期；不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
</blockquote>
<blockquote>
<p>架构层面解决： 提升系统可用性， 监控、报警完善</p>
</blockquote>
<h2 id="15-连接Redis"><a href="#15-连接Redis" class="headerlink" title="15. 连接Redis"></a>15. 连接Redis</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># StrictRedis方式</span></span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis</span><br><span class="line">redis = StrictRedis(host=<span class="string">'localhost'</span>, prot=<span class="number">6379</span>, db=<span class="string">'test'</span>, password=<span class="string">'123456'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个字符串值</span></span><br><span class="line">redis.set(<span class="string">'name'</span>, <span class="string">'Bob'</span>)</span><br><span class="line">print(redis.get(<span class="string">'name'</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">b'Bob'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ConnectionPool连接方式</span></span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis, ConnectionPool</span><br><span class="line">pool = ConnectionPool(host=<span class="string">'localhost'</span>, port=<span class="number">63799</span>, db=<span class="string">'test'</span>, password=<span class="string">'123456'</span>)</span><br><span class="line">redis = StrictRedis(connection_pool=pool)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ConnectionPool支持通过URL来构建</span></span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis, ConnectionPool</span><br><span class="line">url = <span class="string">'redis://:123456@localhost:6379/test'</span></span><br><span class="line">pool = ConnectionPool.from_url(url)</span><br><span class="line">redis = StrictRedis(connect_pool=pool)</span><br></pre></td></tr></table></figure>

<h2 id="16-Redis异步队列"><a href="#16-Redis异步队列" class="headerlink" title="16. Redis异步队列"></a>16. Redis异步队列</h2><blockquote>
<p>一般使用list结构作为队列，rpush生产消息，lpop消费消息，当lpop没有消息的时候，要适当sleep一会再重试。</p>
</blockquote>
<blockquote>
<p>缺点：在消费者下线的情况，生产者的消息会丢失，得使用专业的消息队列如Rabbitmq。</p>
</blockquote>
<h2 id="17-生产一次消费多次"><a href="#17-生产一次消费多次" class="headerlink" title="17. 生产一次消费多次"></a>17. 生产一次消费多次</h2><blockquote>
<p>使用pub/sub主题订阅者模式，可以实现1：N的消息队列。</p>
</blockquote>
<h2 id="18-Redis分区"><a href="#18-Redis分区" class="headerlink" title="18. Redis分区"></a>18. Redis分区</h2><blockquote>
<p>分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。</p>
</blockquote>
<blockquote>
<p>分区的优势：</p>
</blockquote>
<ul>
<li>通过利用多台计算机内存的和值，允许我们构造更大的数据库。</li>
<li>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。</li>
</ul>
<blockquote>
<p>分区的不足：</p>
</blockquote>
<ul>
<li>涉及多个key的操作通常是不被支持的，如当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。</li>
<li>涉及多个key的redis事务不能使用。</li>
<li>当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。</li>
<li>增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。</li>
</ul>
<blockquote>
<p>分区类型：</p>
</blockquote>
<ul>
<li>范围分区：最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。</li>
<li>哈希分区：另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name: 这种形式。</li>
</ul>
<h1 id="MongoDB数据库"><a href="#MongoDB数据库" class="headerlink" title="MongoDB数据库"></a>MongoDB数据库</h1><h2 id="1-MongoDB常用的操作"><a href="#1-MongoDB常用的操作" class="headerlink" title="1. MongoDB常用的操作"></a>1. MongoDB常用的操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">'localhost'</span>, port=<span class="number">27017</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定数据库test</span></span><br><span class="line">db = client.test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定集合</span></span><br><span class="line">collection = db.students</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line">student1 = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20180101'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'zhangsan'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line">student2 = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20180102'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'lisi'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line">result = collection.insert([student1, student2])</span><br><span class="line">result = collection.insert_one(student1)</span><br><span class="line">result = collection.insert_many([student1, student2])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询</span></span><br><span class="line">result = collection.find_one(&#123;<span class="string">'name'</span>: <span class="string">'zhangsan'</span>&#125;)</span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> results:</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 年龄小于20的数据</span></span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$lt'</span>: <span class="number">20</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 年龄小于等于20的数据</span></span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$lte'</span>: <span class="number">20</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 年龄大于20的数据</span></span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$gt'</span>: <span class="number">20</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 年龄大于等于20的数据</span></span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$gte'</span>: <span class="number">20</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 年龄不等于20的数据</span></span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$ne'</span>: <span class="number">20</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 年龄在[18, 25]范围内的数据</span></span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$in'</span>: [<span class="number">18</span>,<span class="number">23</span>]&#125;&#125;)</span><br><span class="line"><span class="comment"># 年龄不在[18, 25]范围内的数据</span></span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$nin'</span>: [<span class="number">18</span>,<span class="number">23</span>]&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则查询，匹配以M开头的数据</span></span><br><span class="line">results = collection.find(&#123;<span class="string">'name'</span>: &#123;<span class="string">'$regex'</span>: <span class="string">'^M.*'</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计数</span></span><br><span class="line">num = collection.find(&#123;<span class="string">'age'</span>: <span class="number">20</span>&#125;).count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据字段，升序ASCENDING/降序DESCENDING</span></span><br><span class="line">results = collection.find().sort(<span class="string">'name'</span>, pymongo.ASCENDING)</span><br><span class="line">print(result[<span class="string">'name'</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 偏移位置，skip(n)忽略前n个元素</span></span><br><span class="line">results = collection.find().sort(<span class="string">'name'</span>, pymongo.ASCENDING).skip(<span class="number">2</span>)</span><br><span class="line">print(result[<span class="string">'name'</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制返回结果个数limit(n)，从左到右</span></span><br><span class="line">results = collection.find().sort(<span class="string">'name'</span>, pymongo.ASCENDING).limit(<span class="number">2</span>)</span><br><span class="line">print(result[<span class="string">'name'</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新update()</span></span><br><span class="line">condition = &#123;<span class="string">'name'</span>: <span class="string">'wangwu'</span>&#125;</span><br><span class="line">student = collection.find_one(condition)</span><br><span class="line">student[<span class="string">'age'</span>] = <span class="number">25</span></span><br><span class="line">result = collection.update(condition, student)</span><br><span class="line"></span><br><span class="line"><span class="comment"># $set操作符只更新student字典内存在的字段，其他字段不更新也不删除</span></span><br><span class="line">result = collection.update(condition, &#123;<span class="string">'$set'</span>: student&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># update_one()</span></span><br><span class="line">result = collection.update_one(condition, &#123;<span class="string">'$set'</span>: student&#125;)</span><br><span class="line"><span class="comment"># 查看获得匹配的数据条数和影响的数据条数</span></span><br><span class="line">print(result.matched_count, result.modified_count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># update_many()</span></span><br><span class="line">condition = &#123;<span class="string">'age'</span>: &#123;<span class="string">'$gt'</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line">result = collection.update_many(condition, &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'age'</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment"># 查看获得匹配的数据条数和影响的数据条数</span></span><br><span class="line">print(result.matched_count, result.modified_count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">result = collection.remove(&#123;<span class="string">'name'</span>: <span class="string">'zhangsan'</span>&#125;)</span><br><span class="line">result = collection.delete_one(&#123;<span class="string">'name'</span>: <span class="string">'zhangsan'</span>&#125;)</span><br><span class="line">result = collection.delete_many(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$lt'</span>: <span class="number">20</span>&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Elasticsearch数据库"><a href="#Elasticsearch数据库" class="headerlink" title="Elasticsearch数据库"></a>Elasticsearch数据库</h1><h2 id="1-索引如何存储"><a href="#1-索引如何存储" class="headerlink" title="1. 索引如何存储"></a>1. 索引如何存储</h2><h2 id="2-介绍下Elastisearch原理和用途"><a href="#2-介绍下Elastisearch原理和用途" class="headerlink" title="2. 介绍下Elastisearch原理和用途"></a>2. 介绍下Elastisearch原理和用途</h2><h2 id="3-分布式实时日志使用ELK"><a href="#3-分布式实时日志使用ELK" class="headerlink" title="3. 分布式实时日志使用ELK"></a>3. 分布式实时日志使用ELK</h2><h1 id="Hive数据库"><a href="#Hive数据库" class="headerlink" title="Hive数据库"></a>Hive数据库</h1><h1 id="Hbase数据库"><a href="#Hbase数据库" class="headerlink" title="Hbase数据库"></a>Hbase数据库</h1><h1 id="Hadoop生态"><a href="#Hadoop生态" class="headerlink" title="Hadoop生态"></a>Hadoop生态</h1>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
