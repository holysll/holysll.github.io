<!DOCTYPE html>


<html lang="cn">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="越努力越幸运！" />
   
  <meta name="description" content="个人博客" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    数据库知识点总结归纳 |  holysll
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="holysll" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      <section class="outer">
  <article id="post-数据库知识" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  数据库知识点总结归纳
</h1>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/" class="article-date">
  <time datetime="2020-05-08T15:05:08.000Z" itemprop="datePublished">2020-05-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">24.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">93 min</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <blockquote>
<p>本文主要对数据库基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。</p>
</blockquote>
<a id="more"></a>

<div style='display: none'>

<!-- TOC -->

<ul>
<li><a href="#数据库常识">数据库常识</a><ul>
<li><a href="#1-什么是索引">1. 什么是索引</a></li>
<li><a href="#2-索引的数据结构">2. 索引的数据结构</a></li>
<li><a href="#3-聚簇索引与非聚簇索引">3. 聚簇索引与非聚簇索引</a></li>
<li><a href="#4-什么是索引覆盖">4. 什么是索引覆盖</a></li>
<li><a href="#5-什么是回表查询">5. 什么是回表查询</a></li>
<li><a href="#6-建立索引需要考虑的因素">6. 建立索引需要考虑的因素</a></li>
<li><a href="#7-联合索引">7. 联合索引</a></li>
<li><a href="#8-查看索引是否被使用到">8. 查看索引是否被使用到</a></li>
<li><a href="#9-为什么要尽量设定一个主键">9. 为什么要尽量设定一个主键</a></li>
<li><a href="#10-主键使用自增id还是uuid">10. 主键使用自增ID还是UUID</a></li>
<li><a href="#11-字段为什么要求定义为not-null">11. 字段为什么要求定义为NOT NULL</a></li>
<li><a href="#12-如果要存储用户的密码散列应该使用什么字段进行存储">12. 如果要存储用户的密码散列，应该使用什么字段进行存储</a></li>
<li><a href="#13-什么是事务">13. 什么是事务</a></li>
<li><a href="#14-事务的特性">14. 事务的特性</a></li>
<li><a href="#15-mysql的事务隔离级别">15. MySql的事务隔离级别</a></li>
<li><a href="#16-同时多个事务并发执行可能造成的问题">16. 同时多个事务并发执行可能造成的问题</a></li>
<li><a href="#17-不可重复读和幻读的区别">17. 不可重复读和幻读的区别</a></li>
<li><a href="#18-共享锁与排他锁">18. 共享锁与排他锁</a></li>
<li><a href="#19-表级锁行级锁页级锁">19. 表级锁、行级锁、页级锁</a></li>
<li><a href="#20-死锁">20. 死锁</a></li>
<li><a href="#21-什么是悲观锁">21. 什么是悲观锁</a></li>
<li><a href="#22-什么是乐观锁">22. 什么是乐观锁</a></li>
<li><a href="#23-mysql支持哪些存储引擎">23. MySQL支持哪些存储引擎</a><ul>
<li><a href="#1-innodb存储引擎">(1) InnoDB存储引擎</a></li>
<li><a href="#2-myisam存储引擎">(2) MyISAM存储引擎</a></li>
<li><a href="#3-memory存储引擎">(3) MEMORY存储引擎</a></li>
<li><a href="#4-merge存储引擎">(4) MERGE存储引擎</a></li>
<li><a href="#5-archive存储引擎">(5) Archive存储引擎</a></li>
<li><a href="#6-example存储引擎">(6) EXAMPLE存储引擎</a></li>
<li><a href="#7-ndb-cluster存储引擎">(7) NDB Cluster存储引擎</a></li>
<li><a href="#8-federated存储引擎">(8) FEDERATED存储引擎</a></li>
<li><a href="#9-csv存储引擎">(9) CSV存储引擎</a></li>
<li><a href="#10-blackhole存储引擎">(10) BLACKHOLE存储引擎</a></li>
</ul>
</li>
<li><a href="#24-myisam和innodb的区别">24. MyISAM和InnoDB的区别</a></li>
<li><a href="#25-存储过程">25. 存储过程</a></li>
<li><a href="#26-什么是视图">26. 什么是视图</a></li>
<li><a href="#27-什么是游标">27. 什么是游标</a></li>
<li><a href="#28-触发器">28. 触发器</a></li>
<li><a href="#29-droptruncatedelete区别">29. drop、truncate、delete区别</a></li>
<li><a href="#30-临时表">30. 临时表</a></li>
<li><a href="#31-数据库范式">31. 数据库范式</a></li>
<li><a href="#32-关系型数据库与非关系型数据库优势和区别">32. 关系型数据库与非关系型数据库优势和区别</a></li>
<li><a href="#33-sql语言分类">33. SQL语言分类</a></li>
<li><a href="#34-countcount1和countcolumn的区别">34. count(*)、count(1)和count(column)的区别</a></li>
<li><a href="#35-like百分号和下划线的区别">35. like、百分号和下划线的区别</a></li>
<li><a href="#36-最左前缀原则">36. 最左前缀原则</a></li>
<li><a href="#37-超大分页处理">37. 超大分页处理</a></li>
<li><a href="#38-慢查询优化">38. 慢查询优化</a></li>
<li><a href="#39-横向分表和纵向分表">39. 横向分表和纵向分表</a></li>
<li><a href="#40-b树和b树的区别">40. B+树和B树的区别</a></li>
<li><a href="#41-查询语句中用到的关键词">41. 查询语句中用到的关键词</a></li>
<li><a href="#42-使用explain优化sql和索引">42. 使用explain优化SQL和索引</a></li>
<li><a href="#43-数据库组主从复制的方式">43. 数据库组主从复制的方式</a></li>
<li><a href="#44-数据库崩溃时事务的恢复机制redo日志和undo日志">44. 数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）</a></li>
</ul>
</li>
<li><a href="#mysql数据库">Mysql数据库</a><ul>
<li><a href="#1-创建数据库">1. 创建数据库</a></li>
<li><a href="#2-用户管理">2. 用户管理</a></li>
<li><a href="#3-授权管理">3. 授权管理</a></li>
<li><a href="#4-修改表的列">4. 修改表的列</a></li>
<li><a href="#5-键的操作">5. 键的操作</a></li>
<li><a href="#6-设置默认值">6. 设置默认值</a></li>
<li><a href="#7-sql语句基础">7. SQL语句基础</a></li>
<li><a href="#8-排序">8. 排序</a></li>
<li><a href="#9-聚合函数">9. 聚合函数</a></li>
<li><a href="#10-分组">10. 分组</a></li>
<li><a href="#11-关联查询">11. 关联查询</a></li>
<li><a href="#12-组合">12. 组合</a></li>
<li><a href="#13-limit的用法">13. LIMIT的用法</a></li>
<li><a href="#14-case-when">14. case when</a></li>
<li><a href="#15-mysql-常用数据类型">15. mysql 常用数据类型</a></li>
<li><a href="#16-mysql读取数据的基本单位">16. MySQL读取数据的基本单位</a></li>
<li><a href="#17-为什么mysql事务回滚后自增id依然自增">17. 为什么mysql事务回滚后，自增ID依然自增</a></li>
<li><a href="#18-mysql的主从复制的实现过程">18. mysql的主从复制的实现过程</a></li>
<li><a href="#19-mysql高并发环境解决方案">19. mysql高并发环境解决方案</a></li>
</ul>
</li>
<li><a href="#redis数据库">Redis数据库</a><ul>
<li><a href="#1-什么是redis">1. 什么是Redis</a></li>
<li><a href="#2-redis的数据类型">2. redis的数据类型</a></li>
<li><a href="#3-两种持久化方式">3. 两种持久化方式</a></li>
<li><a href="#4-rdb与aof比较">4. RDB与AOF比较</a></li>
<li><a href="#5-如果aof文件出现被写坏的情况该怎么处理">5. 如果AOF文件出现被写坏的情况，该怎么处理</a></li>
<li><a href="#6-redis-和-memcached-的主要区别">6. redis 和 memcached 的主要区别</a></li>
<li><a href="#7-事务处理">7. 事务处理</a></li>
<li><a href="#8-redis常见的架构模式">8. Redis常见的架构模式</a><ul>
<li><a href="#1-单机模式">(1) 单机模式</a></li>
<li><a href="#2-主从复制模式">(2) 主从复制模式</a></li>
<li><a href="#3-哨兵模式">(3) 哨兵模式</a></li>
<li><a href="#4-集群模式">(4) 集群模式</a></li>
</ul>
</li>
<li><a href="#9-redis如何实现分布式锁">9. Redis如何实现分布式锁</a></li>
<li><a href="#10-缓存使用场景">10. 缓存使用场景</a></li>
<li><a href="#11-常用的缓存使用模式">11. 常用的缓存使用模式</a></li>
<li><a href="#12-什么是缓存穿透">12. 什么是缓存穿透</a></li>
<li><a href="#13-什么是缓存击穿">13. 什么是缓存击穿</a></li>
<li><a href="#14-什么是缓存雪崩">14. 什么是缓存雪崩</a></li>
<li><a href="#15-连接redis">15. 连接Redis</a></li>
<li><a href="#16-redis异步队列">16. Redis异步队列</a></li>
<li><a href="#17-生产一次消费多次">17. 生产一次消费多次</a></li>
<li><a href="#18-redis分区">18. Redis分区</a></li>
</ul>
</li>
<li><a href="#mongodb数据库">MongoDB数据库</a><ul>
<li><a href="#1-mongodb常用的操作">1. MongoDB常用的操作</a></li>
</ul>
</li>
<li><a href="#elasticsearch数据库">Elasticsearch数据库</a><ul>
<li><a href="#1-索引如何存储">1. 索引如何存储</a></li>
<li><a href="#2-介绍下elastisearch原理和用途">2. 介绍下Elastisearch原理和用途</a></li>
<li><a href="#3-分布式实时日志使用elk">3. 分布式实时日志使用ELK</a></li>
</ul>
</li>
<li><a href="#hive数据库">Hive数据库</a></li>
<li><a href="#hbase数据库">Hbase数据库</a></li>
<li><a href="#hadoop生态">Hadoop生态</a></li>
</ul>
<!-- /TOC -->

</div>

<h1 id="数据库常识"><a href="#数据库常识" class="headerlink" title="数据库常识"></a>数据库常识</h1><h2 id="1-什么是索引"><a href="#1-什么是索引" class="headerlink" title="1. 什么是索引"></a>1. 什么是索引</h2><blockquote>
<p>索引其实就是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候,索引可以大大的加快查询的速度，这是因为使用索引之后不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据的屋里地址然后访问相应的数据。</p>
</blockquote>
<blockquote>
<p>索引的缺点：在创建索引和维护索引会耗费时间，随着数据的增加而增加.索引也会增加，所以如果是经常增删改的列创建索引会大大的增加项目的维护速度。</p>
</blockquote>
<blockquote>
<p>索引的分类：</p>
</blockquote>
<ul>
<li>普通索引</li>
<li>主键索引</li>
<li>唯一索引</li>
<li>多列索引</li>
<li>全文索引</li>
</ul>
<blockquote>
<p>创建索引和删除索引：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 普通索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> tb_name</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> <span class="keyword">index</span> index_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> tb_name  <span class="comment">-- 删除索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 主键索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> primary <span class="keyword">key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除主键索引：</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">drop</span> primary <span class="keyword">key</span>  <span class="comment">-- 普通非自增主键</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">id</span> <span class="keyword">modify</span> <span class="keyword">id</span> <span class="built_in">int</span>;  <span class="comment">-- 自增主键，取消自增列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">drop</span> primary <span class="keyword">key</span>  <span class="comment">-- 删除主键索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 唯一索引，与普通索引类似，可以有null值</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> tb_name</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> <span class="keyword">unique</span> <span class="keyword">index</span> index_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> tb_name  <span class="comment">-- 删除索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多列索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> people <span class="keyword">ADD</span> <span class="keyword">INDEX</span> lname_fname_age (lame, fname,age);</span><br></pre></td></tr></table></figure>

<h2 id="2-索引的数据结构"><a href="#2-索引的数据结构" class="headerlink" title="2. 索引的数据结构"></a>2. 索引的数据结构</h2><blockquote>
<p>索引的数据结构和具体存储引擎的实现有关，在MySql中常用的有Hash索引和B+树索引，而常用的<code>InnoDB</code>存储引擎的默认索引实现为：B+树索引。</p>
</blockquote>
<ul>
<li>Hash索引</li>
</ul>
<blockquote>
<p>Hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获取实际数据。</p>
</blockquote>
<ul>
<li>B+树索引</li>
</ul>
<blockquote>
<p>B+树索引底层实现是多路平衡查找树，所有节点遵循左节点小于父节点，右节点大于父节点；对于每一次查询都是从根节点出发，查找到叶子节点方可以获取所查询的键值，然后根据查询判断是否需要返回表查询数据。</p>
</blockquote>
<blockquote>
<p>Hash索引与B+树所以的差异：</p>
</blockquote>
<ul>
<li>hash索引进行等值查询比较快，但是无法进行范围查询，而B+支持范围查询；</li>
<li>hash索引不支持使用索引排序；</li>
<li>hash索引不支持模糊查询以及多列索引的最左前缀匹配；</li>
<li>hash索引避免不了回表查询数据，而B+树在（聚簇索引、覆盖索引）的时候可以只通过索引完成查询；</li>
<li>hash索引不稳定，性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率极差，而B+树查询效率比较稳定，所有查询都是从根节点到叶子节点，且树的高度较低。</li>
</ul>
<h2 id="3-聚簇索引与非聚簇索引"><a href="#3-聚簇索引与非聚簇索引" class="headerlink" title="3. 聚簇索引与非聚簇索引"></a>3. 聚簇索引与非聚簇索引</h2><blockquote>
<p>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。以<code>InnoDB</code>作为存储引擎的数据表中，只有主键索引才是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引；如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p>
</blockquote>
<blockquote>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用在进行回表查询。</p>
</blockquote>
<blockquote>
<p>非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据还需要根据主键再去聚集索引中进行查找，也就是回表查询。非聚簇索引也不一定会回表查询，因为这涉及到查询语句所要求的字段是否全部命中了索引，如果是，那么就不用再进行回表查询了。</p>
</blockquote>
<h2 id="4-什么是索引覆盖"><a href="#4-什么是索引覆盖" class="headerlink" title="4. 什么是索引覆盖"></a>4. 什么是索引覆盖</h2><blockquote>
<p>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。</p>
</blockquote>
<blockquote>
<p>可以利用索引覆盖来优化SQL的场景：</p>
</blockquote>
<ul>
<li>全表count查询优化</li>
<li>列查询回表优化</li>
<li>分页查询</li>
</ul>
<h2 id="5-什么是回表查询"><a href="#5-什么是回表查询" class="headerlink" title="5. 什么是回表查询"></a>5. 什么是回表查询</h2><blockquote>
<p>先定位主键值，再定位行记录，它的性能比扫一遍索引树更低。</p>
</blockquote>
<h2 id="6-建立索引需要考虑的因素"><a href="#6-建立索引需要考虑的因素" class="headerlink" title="6. 建立索引需要考虑的因素"></a>6. 建立索引需要考虑的因素</h2><ul>
<li>考虑字段的使用频率，经常作为条件进行查询的字段；</li>
<li>经常作为表连接的字段考虑建索引，可以加快连接的速度；</li>
<li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度；</li>
<li>经常在order by、group by之后的字段考虑建索引；</li>
<li>考虑联合索引中的顺序，否则无法命中索引</li>
<li>对非空字段<code>(NOT NULL)</code>创建索引，Mysql很难对控制做查询优化</li>
<li>索引适合区分度高、离散程度大的字段，有大量重复值的字段不适合建索引；</li>
<li>索引的长度不能太长，耗时；</li>
<li>对于那些定义为text, image和bit数据类型的列不应该增加索引；</li>
</ul>
<h2 id="7-联合索引"><a href="#7-联合索引" class="headerlink" title="7. 联合索引"></a>7. 联合索引</h2><blockquote>
<p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p>
</blockquote>
<blockquote>
<p>因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p>
</blockquote>
<h2 id="8-查看索引是否被使用到"><a href="#8-查看索引是否被使用到" class="headerlink" title="8. 查看索引是否被使用到"></a>8. 查看索引是否被使用到</h2><blockquote>
<p>MySQL提供了explain命令来查看语句的执行计划，MySQL在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。可以通过其中和索引有关的信息来分析是否命中了索引，如<code>possilbe_key, key,key_len</code>等字段，分别说明了此语句可能会使用的索引、实际使用的索引以及使用的索引长度。</p>
</blockquote>
<blockquote>
<p>Mysql索引未被使用到的情况：</p>
</blockquote>
<ul>
<li>列参与了数学运算或者函数；</li>
<li>在字符串like时，左边是通配符，如’%aaa’;</li>
<li>当Mysql分析全表扫描比使用索引快的时候不用索引；</li>
<li>当使用联合索引，前面一个条件为范围查询，后面的即使符合最左前缀原则，也无法使用索引；</li>
</ul>
<h2 id="9-为什么要尽量设定一个主键"><a href="#9-为什么要尽量设定一个主键" class="headerlink" title="9. 为什么要尽量设定一个主键"></a>9. 为什么要尽量设定一个主键</h2><blockquote>
<p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p>
</blockquote>
<h2 id="10-主键使用自增ID还是UUID"><a href="#10-主键使用自增ID还是UUID" class="headerlink" title="10. 主键使用自增ID还是UUID"></a>10. 主键使用自增ID还是UUID</h2><blockquote>
<p>推荐使用自增ID，不要使用UUID（通用唯一识别码，Universally Unique Identifier）。因为在<code>InnoDB</code>存储引擎中，主键索引是作为聚簇索引存在的，也就是说主键索引的B+树叶子节点上存储了主键索引以及全部的数据，如果主键索引是自增ID,那么只需要不断向后排序即可；如果用UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入、数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p>
</blockquote>
<h2 id="11-字段为什么要求定义为NOT-NULL"><a href="#11-字段为什么要求定义为NOT-NULL" class="headerlink" title="11. 字段为什么要求定义为NOT NULL"></a>11. 字段为什么要求定义为NOT NULL</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL官网这样介绍：</span></span><br><span class="line">NULL columns require additional space in the rowto record whether their <span class="keyword">values</span> <span class="keyword">are</span> NULL. <span class="keyword">For</span> MyISAM <span class="keyword">tables</span>, <span class="keyword">each</span> <span class="literal">NULL</span> columntakes one <span class="built_in">bit</span> extra, rounded up <span class="keyword">to</span> the nearest byte.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>NULL值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p>
</blockquote>
<h2 id="12-如果要存储用户的密码散列，应该使用什么字段进行存储"><a href="#12-如果要存储用户的密码散列，应该使用什么字段进行存储" class="headerlink" title="12. 如果要存储用户的密码散列，应该使用什么字段进行存储"></a>12. 如果要存储用户的密码散列，应该使用什么字段进行存储</h2><blockquote>
<p>密码散列、盐、用户身份证号等固定长度的字符串应该使用<code>char</code>而不是<code>varchar</code>来存储,这样可以节省空间且提高检索效率.</p>
</blockquote>
<h2 id="13-什么是事务"><a href="#13-什么是事务" class="headerlink" title="13. 什么是事务"></a>13. 什么是事务</h2><blockquote>
<p>在MySQL中只有使用了<code>Innodb</code>数据库引擎的数据库或表才支持事务；事务是数据库并发控制的基本单位；事务可以用来管理<code>INSERT/UPDATE/DELETE</code>操作语句；事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行（回滚）。</p>
</blockquote>
<h2 id="14-事务的特性"><a href="#14-事务的特性" class="headerlink" title="14. 事务的特性"></a>14. 事务的特性</h2><ul>
<li>原子性(Atomicity)</li>
</ul>
<blockquote>
<p>事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。</p>
</blockquote>
<ul>
<li>一致性(Consistency)</li>
</ul>
<blockquote>
<p>几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。</p>
</blockquote>
<ul>
<li>隔离性(Isolation)</li>
</ul>
<blockquote>
<p>事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。</p>
</blockquote>
<ul>
<li>持久性(Durability)</li>
</ul>
<blockquote>
<p>对于任意已交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现异常。</p>
</blockquote>
<h2 id="15-MySql的事务隔离级别"><a href="#15-MySql的事务隔离级别" class="headerlink" title="15. MySql的事务隔离级别"></a>15. MySql的事务隔离级别</h2><ul>
<li>读未提交（Read uncommitted）</li>
</ul>
<blockquote>
<p>事物A和事物B，事物A未提交的数据，事物B可以读取到”脏数据”；隔离级别低，一般都高于该级别。</p>
</blockquote>
<ul>
<li>读已提交（Read committed）</li>
</ul>
<blockquote>
<p>事物A和事物B，事物A提交的数据，事物B才能读取到;隔离级别高于读未提交，可以避免脏读，但是可能会导致不可重复读和幻读。（是Oracle默认隔离级别）</p>
</blockquote>
<ul>
<li>可重复读（Repeatable read）</li>
</ul>
<blockquote>
<p>事务A和事务B，事务A提交之后的数据，事务B是可重复读取数据这时事务B读取不到；该隔离级别高于读已提交，可以避免不可重复读，但有可能导致幻读，MySQL（也是InnoDB）默认隔离级别。</p>
</blockquote>
<ul>
<li>串行化（Serializable）</li>
</ul>
<blockquote>
<p>事务A和事务B，事务A在操作数据库时，事务B只能排队等待；这种隔离级别很少使用，吞吐量太低，用户体验差，这种级别可以避免脏读、重复读、幻读，每一次读取的都是数据库中真实存在数据，这时事务A与事务B串行，而不是并发。</p>
</blockquote>
<p><strong><a href="https://blog.csdn.net/JIESA/article/details/51317164" target="_blank" rel="noopener">四个隔离级别可能出现脏读、不可重复读、幻读问题</a></strong></p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center"></th>
<th align="center">出现情况</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">脏读</td>
<td align="center">不可重复读</td>
<td align="center">幻读</td>
</tr>
<tr>
<td align="center">读未提交</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">读已提交</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h2 id="16-同时多个事务并发执行可能造成的问题"><a href="#16-同时多个事务并发执行可能造成的问题" class="headerlink" title="16. 同时多个事务并发执行可能造成的问题"></a>16. 同时多个事务并发执行可能造成的问题</h2><ul>
<li>脏读：就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问这个数据，然后使用了这个数据。</li>
<li>不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。</li>
<li>幻读：事务在插入已经检查过不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测获取到的数据如同鬼影一般。</li>
<li>丢失修改：并发写入造成其中一些修改丢失。</li>
</ul>
<h2 id="17-不可重复读和幻读的区别"><a href="#17-不可重复读和幻读的区别" class="headerlink" title="17. 不可重复读和幻读的区别"></a>17. 不可重复读和幻读的区别</h2><ul>
<li>不可重复读是读取了其他事务更改的数据，针对update操作</li>
</ul>
<blockquote>
<p>解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。</p>
</blockquote>
<ul>
<li>幻读是读取了其他事务新增的数据，针对insert与delete操作</li>
</ul>
<blockquote>
<p>解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。</p>
</blockquote>
<h2 id="18-共享锁与排他锁"><a href="#18-共享锁与排他锁" class="headerlink" title="18. 共享锁与排他锁"></a>18. 共享锁与排他锁</h2><blockquote>
<p>共享锁(shared lock)，又叫读锁，读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，而不会造成阻塞。当用户要进行数据的读取时，对数据加上共享锁，共享锁可以同时加上多个。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>排他锁(exclusive lock)，又叫写锁，写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，它和其他的排他锁、共享锁都相斥。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure>

<h2 id="19-表级锁、行级锁、页级锁"><a href="#19-表级锁、行级锁、页级锁" class="headerlink" title="19. 表级锁、行级锁、页级锁"></a>19. 表级锁、行级锁、页级锁</h2><p><strong><a href="https://www.cnblogs.com/luyucheng/p/6297752.html" target="_blank" rel="noopener">MySQL锁详解</a></strong></p>
<blockquote>
<p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。</p>
</blockquote>
<ul>
<li>使用表级锁的主要是MyISAM、MEMORY、CSV等一些非事务性存储引擎。</li>
</ul>
<blockquote>
<p>行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。<br>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。</p>
</blockquote>
<ul>
<li>使用行级锁的主要是InnoDB存储引擎。</li>
</ul>
<blockquote>
<p>页级锁是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。</p>
</blockquote>
<ul>
<li>使用页级锁的主要是BerkeleyDB存储引擎。</li>
</ul>
<p><strong>MySQL中这三种锁的总结</strong></p>
<blockquote>
<p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；</p>
</blockquote>
<blockquote>
<p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；</p>
</blockquote>
<blockquote>
<p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>
</blockquote>
<blockquote>
<p>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p>
</blockquote>
<h2 id="20-死锁"><a href="#20-死锁" class="headerlink" title="20. 死锁"></a>20. 死锁</h2><blockquote>
<p>在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，当两个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。</p>
</blockquote>
<blockquote>
<p>在InnoDB的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在。当InnoDB检测到系统中产生了死锁之后，InnoDB会通过相应的判断来选这产生死锁的两个事务中较小的事务来回滚，而让另外一个较大的事务成功完成。实际上在InnoDB发现死锁之后，会计算出两个事务各自插入、更新或者删除的数据量来判定两个事务的大小。也就是说哪个事务所改变的记录条数越多，在死锁中就越不会被回滚掉。</p>
</blockquote>
<blockquote>
<p>避免死锁的常用方法：</p>
</blockquote>
<ul>
<li><p>在应用中，如果不同的程序会并发存储多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的概率。</p>
</li>
<li><p>在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能。</p>
</li>
<li><p>在事务中，如果要更新记录，应该直接申请足够级别的锁，及排他锁，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能又已经获得相同记录的共享锁，从而造成锁冲突，甚至死锁。</p>
</li>
<li><p>在可重复读隔离级别下，如果两个线程同时对相同条件记录用<code>select ... for update</code>加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么，就会出现死锁。这种情况下，将隔离级别该为读已提交，就可以避免问题。</p>
</li>
<li><p>当隔离级别为读已提交时，如果两个线程都先执行<code>select ... for update</code>，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现等待，当第一个线程提交后，第二个线程会因主键重复出错，但虽然这个线程出错了，却获得一个排他锁。这时，如果有第三个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后在捕获主键异常，或在遇到主键重错误时，总是执行Rollback释放获得的排他锁。</p>
</li>
<li><p>查出线程杀死kill：<code>SELECT try_MySQL_thread_id FROM information_schema.INNODB_TRX;</code></p>
</li>
<li><p>设置锁超时时间：<code>set innodb_lock_wait_timeout=1000;</code></p>
</li>
</ul>
<h2 id="21-什么是悲观锁"><a href="#21-什么是悲观锁" class="headerlink" title="21. 什么是悲观锁"></a>21. 什么是悲观锁</h2><blockquote>
<p>悲观锁(Pessimistic Lock)，顾名思义就是很悲观。每次去操作数据的时候，都会认为别人会修改。所以为了防止别人修改，就在操作的时候上锁。这样别人来访问的时候就会阻塞在那里直到锁被是释放。传统的关系型数据库里面就用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。</p>
</blockquote>
<blockquote>
<p>遵循逻辑为一锁二查三更新(select for update)会把数据给锁住，其中MySQL默认InnoDB引擎，默认是行级锁，基于索引的，若SQL语句用不到索引，则不会使用行级锁的，会使用表级锁将整张表锁住。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 来源：https://www.jianshu.com/p/083bbe5f5534</span></span><br><span class="line"><span class="comment">-- encoding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 场景：商品goods表中有一个字段status，status为1代表商品未被下单，status为2代表商品已经被下单，那么我们对某个商品下单的时候必须确保该商品status为1。假设商品id为1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果不使用锁,那么操作方法如下:</span></span><br><span class="line"><span class="comment">-- 1.查询出商品信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.根据商品信息生成订单</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_orders(<span class="keyword">id</span>,goods_d) <span class="keyword">values</span>(<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 3.修改商品status为2</span></span><br><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 上面这种场景在高并发访问的情况下很可能会出现问题。</span></span><br><span class="line"><span class="comment">-- 前面已经提到，只有上status为1的时候，才能对该商品下单，上面的第一步操作中查询出来的上面品status为1，但是当我们执行第二步的时候，很有可能有的人先一步执行了步骤2和步骤3，此时订单已经被下过了，然后我们又下了一次。很有可能就出现一个订单被下单了两次的情况。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解决这种问题的方法，我们使用悲观锁来实现。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在上面的场景中，商品信息从查询出来到修改，中间有一个处理订单的过程。使用悲观锁的原理就是,当我们查询goods的信息时，就把当前的数据锁住，直到我们修改完毕后再解锁。那么在这个过程中，因为goods被锁定了，就不会出现有第三者来对其进行修改了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：如果要使用悲观锁，我们必须将mysql数据库的自动提交功能关闭。因为mysql默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySql会立即将结果进行提交。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 我们可以使用命令设置MySQL为非autocommit的模式:</span></span><br><span class="line"><span class="keyword">set</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 设置完autocommit后,我们就可以执行我们的正常业务了。具体如下：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 0.事务开始</span></span><br><span class="line"><span class="keyword">begin</span>;/<span class="keyword">begin</span> <span class="keyword">work</span>;/<span class="keyword">start</span> trasaction;  <span class="comment">-- 三者选一即可</span></span><br><span class="line"><span class="comment">-- 1.查询出商品信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">-- 2.根据商品信息生成订单</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_orders (<span class="keyword">id</span> ,goods_id) <span class="keyword">values</span> (<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 3.修改商品status为2</span></span><br><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 4.提交事务</span></span><br><span class="line"><span class="keyword">commit</span>;/ commint work;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 上面的第一步我们执行了一次查询操作:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> t_goods <span class="keyword">from</span> t_good <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 与普通查询不一样的是，我们使用了select... for update的方式，这样就通过数据库实现了悲观锁。此时t_goods表中，id为1的那条数据就被我们锁定了，其他的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其他事务修改。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>悲观锁的优缺点：悲观锁的策略是先取锁在访问，保证了数据的安全性，但是效率方面，处理锁机制会让数据库产生额外开销，还有可能增加产生死锁的可能，所以一般只有在写操作冲突很多的时候才使用悲观锁，而读操作不需要加锁。</p>
</blockquote>
<h2 id="22-什么是乐观锁"><a href="#22-什么是乐观锁" class="headerlink" title="22. 什么是乐观锁"></a>22. 什么是乐观锁</h2><blockquote>
<p>乐观锁(Optimistic Lock)，顾名思义就是很乐观，每次去拿数据的时候都认为比人不会修改，所以不会上锁。但是在更新数据的时候，会判断一下在更新数据的这段时间内，数据有没有被修改；如果被修改了，就取消这次操作；如果没有被修改，则使得这次操作生效。一般使用版本号或者时间戳的方式来实现。</p>
</blockquote>
<blockquote>
<p>遵循先修改，更新时发现数据已经变了就回滚(check and set)，乐观锁一般通过数据库版本号或时间戳实现。在数据库增加一个字段version，当我们操作数据的时候，将版本号一同取出来，当我们更新数据，在提交更新的时候，会再去数据查询下当前的版本号，跟我们之前取出来的版本号，是否一致。如果一致，就使得这次更新生效。并且在每次更新数据的时候，都使得版本号加1。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用版本号时,可以再数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断一下当前的版本号是不是该数据的最新的版本号。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1. 查询出商品信息</span></span><br><span class="line"><span class="keyword">select</span> (<span class="keyword">status</span>, <span class="keyword">version</span>) <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'id'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.根据商品信息生成订单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.修改商品status为2</span></span><br><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>, <span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">'id'</span> <span class="keyword">and</span> <span class="keyword">version</span>=<span class="string">'version'</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>乐观锁的优缺点：乐观并发控制相信事务之间的数据竞争的概率是比较小的，会先进行操作。再提交的时候，再进行验证这次提交是否可行，因此不会有任何的死锁和锁。但是这样做还是有问题的，例如如果某两个事务对同一行的数据同时进行了修改，经过修改之后，同时写进了数据库，这时就会出现问题。所以乐观锁，一般用在读数据比较多的地方。而对于写数据比较多的地方，我们最好使用悲观锁来解决。</p>
</blockquote>
<h2 id="23-MySQL支持哪些存储引擎"><a href="#23-MySQL支持哪些存储引擎" class="headerlink" title="23. MySQL支持哪些存储引擎"></a>23. MySQL支持哪些存储引擎</h2><p><strong><a href="https://blog.csdn.net/holysll/article/details/89197810" target="_blank" rel="noopener">MySQL的存储引擎的特点比较</a></strong></p>
<h3 id="1-InnoDB存储引擎"><a href="#1-InnoDB存储引擎" class="headerlink" title="(1) InnoDB存储引擎"></a>(1) InnoDB存储引擎</h3><blockquote>
<p>MySQL的默认存储引擎，提供事务安全表，该存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。用于事务处理应用程序，具有众多特性，包括ACID事务支持。相对于MyISAM引擎，写的处理效率会差一些，并且会占用更多的磁盘空间以保留数据和索引。</p>
</blockquote>
<blockquote>
<p>InnoDB主要特点：</p>
</blockquote>
<ul>
<li>InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎；</li>
<li>InnoDB有强大的CPU效率，能够处理巨大数据量；</li>
<li>InnoDB存储引擎完全与MySQL服务器整合，将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件，表可以是任何尺寸；</li>
<li>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键。</li>
</ul>
<h3 id="2-MyISAM存储引擎"><a href="#2-MyISAM存储引擎" class="headerlink" title="(2) MyISAM存储引擎"></a>(2) MyISAM存储引擎</h3><blockquote>
<p>MyISAM存储引擎是管理非事务表，不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表，支持3种不同的存储格式，分别是：静态表（字段长度固定）、动态表（字段长度动态不固定）、压缩表（每个记录单独被压缩，访问开支小）。默认的MySQL插件式存储引擎，它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。</p>
</blockquote>
<blockquote>
<p>MyISAM的主要特点：</p>
</blockquote>
<ul>
<li>大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持；</li>
<li>当把删除和更新及插入操作混合使用的时候，动态大小的行产生更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块自动完成；</li>
<li>每个MyISAM表最大索引数是64，这可以通过重新编译来改变，每个索引最大的列数是16；</li>
<li>NULL被允许在索引的列中，这个值占每个键的0~1个字节；</li>
<li>可以把数据文件和索引文件放在不同目录；</li>
</ul>
<h3 id="3-MEMORY存储引擎"><a href="#3-MEMORY存储引擎" class="headerlink" title="(3) MEMORY存储引擎"></a>(3) MEMORY存储引擎</h3><blockquote>
<p>Memory存储引擎使用存在于内存中的内容来创建表。每个Memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失掉。将所有数据保存在RAM中，在需要快速查找引用和其他类似数据的环境下，可提供极快的访问。Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果。</p>
</blockquote>
<h3 id="4-MERGE存储引擎"><a href="#4-MERGE存储引擎" class="headerlink" title="(4) MERGE存储引擎"></a>(4) MERGE存储引擎</h3><blockquote>
<p>Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，Merge表本身并没有数据，对Merge类型的表可以进行select、update、delete操作，这些操作实际上是对内部的MyISAM表进行的。允许MySQL DBA或开发人员将一系列等同的MyISAM表以逻辑方式组合在一起，并作为1个对象引用它们。对于诸如数据仓储等VLDB环境十分适合。</p>
</blockquote>
<h3 id="5-Archive存储引擎"><a href="#5-Archive存储引擎" class="headerlink" title="(5) Archive存储引擎"></a>(5) Archive存储引擎</h3><blockquote>
<p>存储引擎被用来无索引的、非常小的覆盖存储大量数据。为大量很少引用的历史、归档、或安全审计信息的存储和检索提供了完美的解决方案。</p>
</blockquote>
<h3 id="6-EXAMPLE存储引擎"><a href="#6-EXAMPLE存储引擎" class="headerlink" title="(6) EXAMPLE存储引擎"></a>(6) EXAMPLE存储引擎</h3><blockquote>
<p>EXAMPLE存储引擎是一个“存根”引擎，可以用这个引擎创建表，但没有数据被存储于其中或从其中检索，这个引擎的目的是服务，可为快速创建定制的插件式存储引擎提供帮助。</p>
</blockquote>
<h3 id="7-NDB-Cluster存储引擎"><a href="#7-NDB-Cluster存储引擎" class="headerlink" title="(7) NDB Cluster存储引擎"></a>(7) NDB Cluster存储引擎</h3><blockquote>
<p>MySQL的簇式数据库引擎，是被MySQL Cluster用来实现分割到多台计算机上的表的存储引擎，尤其适合于具有高性能查找要求的应用程序，这类查找需求还要求具有最高的正常工作时间和可用性。</p>
</blockquote>
<h3 id="8-FEDERATED存储引擎"><a href="#8-FEDERATED存储引擎" class="headerlink" title="(8) FEDERATED存储引擎"></a>(8) FEDERATED存储引擎</h3><blockquote>
<p>FEDERATED存储引擎把数据存在远程数据库中。在MySQL 5.1中，它只和MySQL一起工作，使用MySQL C Client API。能够将多个分离的MySQL服务器链接起来，从多个物理服务器创建一个逻辑数据库。十分适合于分布式环境或数据集市环境。</p>
</blockquote>
<h3 id="9-CSV存储引擎"><a href="#9-CSV存储引擎" class="headerlink" title="(9) CSV存储引擎"></a>(9) CSV存储引擎</h3><blockquote>
<p>CSV存储引擎把数据以逗号分隔的格式存储在文本文件中。</p>
</blockquote>
<h3 id="10-BLACKHOLE存储引擎"><a href="#10-BLACKHOLE存储引擎" class="headerlink" title="(10) BLACKHOLE存储引擎"></a>(10) BLACKHOLE存储引擎</h3><blockquote>
<p>BLACKHOLE存储引擎接受但不存储数据，并且检索总是返回一个空集。用于临时禁止对数据库的应用程序输入。</p>
</blockquote>
<h2 id="24-MyISAM和InnoDB的区别"><a href="#24-MyISAM和InnoDB的区别" class="headerlink" title="24. MyISAM和InnoDB的区别"></a>24. MyISAM和InnoDB的区别</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="left">MyISAM</th>
<th align="left">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">构成</td>
<td align="left">表定义文件：.frm；数据文件：.MYD；索引文件：.MYI；</td>
<td align="left">表大小只限制与操作系统文件的大熊啊，一般为2G</td>
</tr>
<tr>
<td align="center">事务处理</td>
<td align="left">性能快，但不支持事务和外键</td>
<td align="left">支持事务，支持外键</td>
</tr>
<tr>
<td align="center">增删改查</td>
<td align="left">适合执行大量的SELECT操作</td>
<td align="left">执行大量数据的INSERT或UPDATE；删除不会重新建表，而是一行行删除</td>
</tr>
<tr>
<td align="center">AUTO_INCREMENT操作</td>
<td align="left">MyISAM 为 INSERT 和 UPDATE 操作自动更新这一列；</td>
<td align="left">在数据词典里的InnoDB表句柄包含一个名为自动增长计数器的计数器，仅被存储在主内存中，而不是存在磁盘上</td>
</tr>
<tr>
<td align="center">表行数</td>
<td align="left">执行<code>select count(*) from table</code>保存行数</td>
<td align="left">执行<code>select count(*) from table</code>且要扫描整表去计算行数</td>
</tr>
<tr>
<td align="center">锁</td>
<td align="left">表级锁</td>
<td align="left">行级锁</td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="left">支持全文索引</td>
<td align="left">支持全文索引(&gt;=5.6)</td>
</tr>
<tr>
<td align="center">多版本并发控制</td>
<td align="left">不支持MVCC</td>
<td align="left">支持MVCC</td>
</tr>
</tbody></table>
<h2 id="25-存储过程"><a href="#25-存储过程" class="headerlink" title="25. 存储过程"></a>25. 存储过程</h2><blockquote>
<p>存储过程是一些预编译的SQL语句，执行效率比较高，一个存储过程代替大量的T-SQL语句，可以降低网络通信量，提高通信速率，可以一定程度上确保数据安全。</p>
</blockquote>
<blockquote>
<p>通俗的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能，然后再给这个代码块取一个别名，调用时直接用别名调用。</p>
</blockquote>
<blockquote>
<p>存储过程的优缺点</p>
</blockquote>
<ul>
<li>优点：<ul>
<li>存储过程是预编译过的，执行效率高；</li>
<li>存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯；</li>
<li>安全性高，执行存储过程需要一定权限的用户；</li>
<li>存储过程可以重复使用，可减少数据库开发人员的工作量；</li>
</ul>
</li>
<li>缺点：移植性差</li>
</ul>
<h2 id="26-什么是视图"><a href="#26-什么是视图" class="headerlink" title="26. 什么是视图"></a>26. 什么是视图</h2><blockquote>
<p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增、改、查操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。</p>
</blockquote>
<blockquote>
<p>视图的优缺点</p>
</blockquote>
<ul>
<li>优点：<ul>
<li>对数据库的访问，因为视图可以有选择性的选取数据库里的一部分；</li>
<li>用户通过简单的查询可以从复杂查询中得到结果；</li>
<li>维护数据的独立性，视图可从多个表检索数据；</li>
<li>对于相同的数据可产生不同的视图；</li>
</ul>
</li>
<li>缺点：<ul>
<li>查询视图时，必须把视图的查询转化成基本表的查询，如果这个视图是由一个复杂的夺标查询所定义的，那么就无法更改数据。</li>
</ul>
</li>
</ul>
<h2 id="27-什么是游标"><a href="#27-什么是游标" class="headerlink" title="27. 什么是游标"></a>27. 什么是游标</h2><blockquote>
<p>游标是对查询出来的结果作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或者多行。可以对结果集当前行做修改。一般不用游标，主要用在逐条处理数据时。</p>
</blockquote>
<h2 id="28-触发器"><a href="#28-触发器" class="headerlink" title="28. 触发器"></a>28. 触发器</h2><blockquote>
<p>触发器是一种特殊的存储过程，主要是通过实践来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算，如某表上的触发器包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p>
</blockquote>
<h2 id="29-drop、truncate、delete区别"><a href="#29-drop、truncate、delete区别" class="headerlink" title="29. drop、truncate、delete区别"></a>29. drop、truncate、delete区别</h2><ul>
<li>drop直接删除表</li>
<li>truncate删除表中的数据，再插入时自增长id又从1开始</li>
<li>delete删除表中的数据，可以加where语句</li>
</ul>
<h2 id="30-临时表"><a href="#30-临时表" class="headerlink" title="30. 临时表"></a>30. 临时表</h2><blockquote>
<p>MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。默认情况下，当你断开与数据库的连接后，临时表就会自动被销毁。当然你也可以在当前MySQL会话使用 DROP TABLE 命令来手动删除临时表。</p>
</blockquote>
<h2 id="31-数据库范式"><a href="#31-数据库范式" class="headerlink" title="31. 数据库范式"></a>31. 数据库范式</h2><blockquote>
<p>第一范式：最基本范式，数据库表中所有字段都是不可分解的原子值。</p>
</blockquote>
<blockquote>
<p>第二范式：在一个数据表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据表中。主要针对联合主键而言，确保数据表中的每一列都和主键相关，而不能只与主键的某一部分相关。</p>
</blockquote>
<blockquote>
<p>第三范式：确保数据表中的每一列数据都和主键直接相关，而不是间接相关。</p>
</blockquote>
<blockquote>
<p><strong>一般，一个数据库设计符合3NF或BCNF就可以了</strong></p>
</blockquote>
<blockquote>
<p>第四范式：要求把统一表内的多对多关系删除。</p>
</blockquote>
<blockquote>
<p>第五范式：从最终结构重新建立原始结构。</p>
</blockquote>
<h2 id="32-关系型数据库与非关系型数据库优势和区别"><a href="#32-关系型数据库与非关系型数据库优势和区别" class="headerlink" title="32. 关系型数据库与非关系型数据库优势和区别"></a>32. 关系型数据库与非关系型数据库优势和区别</h2><ul>
<li><p>关系型数据库</p>
<ul>
<li>复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li>
<li>事务支持：使得对安全性能很高的数据访问要求得以实现。</li>
</ul>
</li>
<li><p>非关系型数据库</p>
<ul>
<li>性能：NoSQL基于k-v键值对，不需要经过SQL层的解析，性能非常高。</li>
<li>可扩展性：因为基于键值对，数据之间没有耦合性，所以水平扩展非常容易。</li>
</ul>
</li>
<li><p>趋势</p>
<ul>
<li>NoSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，如MongoDB。</li>
<li>对于事务的支持，也可以用一些系统级的原子操作（乐观锁之类的方法）来解决，比如redis set nx</li>
</ul>
</li>
</ul>
<h2 id="33-SQL语言分类"><a href="#33-SQL语言分类" class="headerlink" title="33. SQL语言分类"></a>33. SQL语言分类</h2><ul>
<li>数据查询语言DQL：主要是<code>SELECT</code>、<code>FROM</code>、<code>WHERE</code>语句</li>
<li>数据操纵语句DML：主要是<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code></li>
<li>数据定义语言DDL：创建数据库中的各种对象（表、视图、索引、同义词）<code>CREATE TABLE/VIEW/INDEX/SYN/CLUSTER</code></li>
<li>数据控制语言DCL：授权（<code>GRANT</code>）、回滚上次最后提交的状态（<code>ROLLBACK</code>）、回退到某个点（<code>ROLLBACK WORK TO [SAVEPOINT</code>）、提交（<code>COMMIT WORK</code>）。</li>
</ul>
<h2 id="34-count-、count-1-和count-column-的区别"><a href="#34-count-、count-1-和count-column-的区别" class="headerlink" title="34. count(*)、count(1)和count(column)的区别"></a>34. count(*)、count(1)和count(column)的区别</h2><ul>
<li><code>count(*)</code>：对行的数目进行计算，包含NULL，跟<code>count(非主键)</code>一样，扫描整个表；</li>
<li><code>count(1)</code>：与<code>count(主键)</code>是一样的，只扫描主键；</li>
<li><code>count(column)</code>：对特定的类的值具体的函数进行计算，不包含NULL值；</li>
</ul>
<blockquote>
<p>特别注意：</p>
</blockquote>
<ul>
<li>任何情况下<code>SELECT COUNT(*) FROM tablename</code>是最优选择；</li>
<li>尽量减少<code>SELECT COUNT(*) FROM tablename WHERE COL = &#39;value&#39;</code>这种查询；</li>
<li>杜绝<code>SELECT COUNT(COL) FROM tablename WHERE COL1 = &#39;value&#39;</code>的出现；</li>
<li>如果表没有主键，那么<code>count(1)</code>比<code>count(*)</code>快；若果有主键，那么<code>count(主键，联合主键)</code>比<code>count(*)</code>快；若过表只有一个字段，<code>count(*)</code>最快。</li>
</ul>
<h2 id="35-like、百分号和下划线的区别"><a href="#35-like、百分号和下划线的区别" class="headerlink" title="35. like、百分号和下划线的区别"></a>35. like、百分号和下划线的区别</h2><ul>
<li>like操作符：LIKE作用是指示MySQL后面的搜索模式是利用通配符而不是直接相等匹配进行比较；若like后面没有通配符，则跟=等号效果一致。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> products.prod_name <span class="keyword">like</span> <span class="string">'1000'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>%百分号通配符：表示任何字符出现任意次数（可以是0次），但是不能匹配NULL。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 匹配以aaa开头的记录，包括aaa</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> products.prod_name <span class="keyword">like</span> <span class="string">'aaa%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配包含aaa开头的记录，包括aaa</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> products.prod_name <span class="keyword">like</span> <span class="string">'%aaa%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配以aaa结尾的记录，仅仅包括aaa（后面不能有空格）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> products.prod_name <span class="keyword">like</span> <span class="string">'%aaa'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>_下划线通配符：表示只能匹配单个字符，不能多也不能少，就一个字符。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 向前匹配一个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> products.prod_name <span class="keyword">like</span> <span class="string">'_aaa'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 向后匹配一个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> products.prod_name <span class="keyword">like</span> <span class="string">'aaa_'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>特别注意</p>
<ul>
<li>MySQL的通配符很有用，但这种通配符搜索的处理一般比较慢。</li>
<li>不要过度使用通配符,如果其他操作符能达到相同的目的，应该使用其他操作符;</li>
<li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处，因为会很慢；</li>
<li>仔细注意通配符的位置，如果放错地方，可能不会返回想要的结果。</li>
</ul>
</li>
</ul>
<h2 id="36-最左前缀原则"><a href="#36-最左前缀原则" class="headerlink" title="36. 最左前缀原则"></a>36. 最左前缀原则</h2><blockquote>
<p>最左前缀原则：顾名思义，就是最左优先。在mysql中执行查询时，只能使用一个索引；在多列分别建索引，执行查询时，只用使用一个索引，mysql会选择一个最严格的的索引（获得结果集记录数最少的）。</p>
</blockquote>
<h2 id="37-超大分页处理"><a href="#37-超大分页处理" class="headerlink" title="37. 超大分页处理"></a>37. 超大分页处理</h2><ul>
<li>数据库层面：核心思想是减少load数据，适当利用所应覆盖</li>
<li>靠缓存机制解决，可预测性地提前查到所需的内存，缓存到redis等k-v数据库中，直接返回即可。</li>
</ul>
<h2 id="38-慢查询优化"><a href="#38-慢查询优化" class="headerlink" title="38. 慢查询优化"></a>38. 慢查询优化</h2><ul>
<li>首先分析语句，查看是否load了额外的数据，可能是查询了多余的行并抛弃了，可能是加载了许多结果中并不需要的列，对语句进行分析并重写；</li>
<li>分析语句的执行计划，然后获得其索引情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引；</li>
<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或纵向的分表；</li>
<li><code>slow_query_log_file</code> 查看慢查询日志，调整数据修改索引</li>
</ul>
<h2 id="39-横向分表和纵向分表"><a href="#39-横向分表和纵向分表" class="headerlink" title="39. 横向分表和纵向分表"></a>39. 横向分表和纵向分表</h2><blockquote>
<p>横向分表是按行分表，假设我们有一张用户表，主键是自增ID且同时是用户的ID。数据量较大，有1亿多条，那么此时放在一张表里的查询效果就不太理想。我们可以根据主键ID进行分表，无论是按尾号分，或者按ID的区间分都是可以的。假设按照尾号0-99分为100个表，那么每张表中的数据就仅有100w。这时的查询效率无疑是可以满足要求的。</p>
</blockquote>
<blockquote>
<p>纵向分表是按列分表，假设我们现在有一张文章表。包含字段id-摘要-内容。而系统中的展示形式是刷新出一个列表，列表中仅包含标题和摘要，当用户点击某篇文章进入详情时才需要正文内容。此时，如果数据量大，将内容这个很大且不经常使用的列放在一起会拖慢原表的查询速度。我们可以将上面的表分为两张。id-摘要，id-内容，当用户点击详情，那主键再来取一次内容即可，而增加的存储量只是很小的主键字段，代价很小。</p>
</blockquote>
<h2 id="40-B-树和B树的区别"><a href="#40-B-树和B树的区别" class="headerlink" title="40. B+树和B树的区别"></a>40. B+树和B树的区别</h2><p><strong><a href="https://www.cnblogs.com/zhuyeshen/p/12082839.html" target="_blank" rel="noopener">MySQL索引-B+树（看完你就明白了）</a></strong></p>
<p><strong><a href="https://blog.csdn.net/qq_35571554/article/details/82759668" target="_blank" rel="noopener">漫画叙述B+树和B-树</a></strong></p>
<blockquote>
<p>(1). B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。</p>
</blockquote>
<blockquote>
<p>(2). B+ 树的阶数是等于键值的数量的，如果我们的 B+ 树一个节点可以存储 1000 个键值，那么 3 层 B+ 树可以存储 1000×1000×1000=10 亿个数据。一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。</p>
</blockquote>
<blockquote>
<p>(3). B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。</p>
</blockquote>
<blockquote>
<p>(4). B+ 树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。在<code>InnoDB</code>中，数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据；在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。</p>
</blockquote>
<blockquote>
<p>(5). B+树的磁盘读写代价更低，IO 次数少，数据查询的效率也会更快；B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路，路径长度相同，所以每一个数据的查询效率相当。</p>
</blockquote>
<h2 id="41-查询语句中用到的关键词"><a href="#41-查询语句中用到的关键词" class="headerlink" title="41. 查询语句中用到的关键词"></a>41. 查询语句中用到的关键词</h2><blockquote>
<p>查询中用到的关键词主要包含六个，且执行顺序为<code>select--&gt;from--&gt;where--&gt;group by--&gt;having--order by</code></p>
</blockquote>
<blockquote>
<p>select和from是必须的，其他可选；</p>
</blockquote>
<blockquote>
<p>where: 过滤表中数据的条件；</p>
</blockquote>
<blockquote>
<p>group by：如何将上面过滤出的数据分组；</p>
</blockquote>
<blockquote>
<p>having：对上面已经分组的数据进行过滤的条件；</p>
</blockquote>
<blockquote>
<p>order by：按照什么样的顺序来查看返回的数据；</p>
</blockquote>
<blockquote>
<p><strong>from后面的表关联，是自右向左解析，而where条件的解析顺序是自下而上的：</strong> 在写SQL语句的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在where语句的最左边（用小表去匹配大表）。</p>
</blockquote>
<h2 id="42-使用explain优化SQL和索引"><a href="#42-使用explain优化SQL和索引" class="headerlink" title="42. 使用explain优化SQL和索引"></a>42. 使用explain优化SQL和索引</h2><blockquote>
<p>对于复杂、效率低的sql语句，可以使用<code>explain + sql</code>的格式来分析sql语句，可以打印出语句执行的过程，以便分析与优化。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>table</code></td>
<td align="left">显示这一行的数据是关于哪张表的</td>
</tr>
<tr>
<td align="center"><code>type</code></td>
<td align="left">这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL</td>
</tr>
<tr>
<td align="center"><code>all</code></td>
<td align="left"><code>full table scan</code> 即MySQL将遍历全表以找到匹配的行</td>
</tr>
<tr>
<td align="center"><code>index</code></td>
<td align="left"><code>index scan</code> index 和 all的区别在于index类型只遍历索引</td>
</tr>
<tr>
<td align="center"><code>range</code></td>
<td align="left">索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between，等查询</td>
</tr>
<tr>
<td align="center"><code>ref</code></td>
<td align="left">非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找</td>
</tr>
<tr>
<td align="center"><code>eq_ref</code></td>
<td align="left">唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描</td>
</tr>
<tr>
<td align="center"><code>const, system</code></td>
<td align="left">当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量</td>
</tr>
<tr>
<td align="center"><code>possible_keys</code></td>
<td align="left">显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</td>
</tr>
<tr>
<td align="center"><code>key</code></td>
<td align="left">实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用<code>USE INDEX（indexname）</code>来强制使用一个索引或者用<code>IGNORE INDEX（indexname）</code>来强制MySQL忽略索引</td>
</tr>
<tr>
<td align="center"><code>key_len</code></td>
<td align="left">使用的索引的长度。在不损失精确性的情况下，长度越短越好</td>
</tr>
<tr>
<td align="center"><code>rows</code></td>
<td align="left">MySQL认为必须检查的用来返回请求数据的行数</td>
</tr>
<tr>
<td align="center"><code>Extra</code></td>
<td align="left">关于MySQL如何解析查询的额外信息</td>
</tr>
</tbody></table>
<h2 id="43-数据库组主从复制的方式"><a href="#43-数据库组主从复制的方式" class="headerlink" title="43. 数据库组主从复制的方式"></a>43. 数据库组主从复制的方式</h2><ul>
<li>同步复制</li>
</ul>
<blockquote>
<p>所谓同步复制，意思是master的变化，必须等待<code>slave-1, slave-2, ..., slave-n</code>完成后才能返回。这显然不可取，也不是MySQL复制的默认设置。比如在Web全段页面上，用户增加了一条记录，需要等待很长时间。</p>
</blockquote>
<ul>
<li>异步复制</li>
</ul>
<blockquote>
<p>异步也就同ajax请求一样，master秩序完成自己的数据操作即可，至于slaves是否接收到二进制日志、是否完成操作，不需要关心，这是MySQL的默认设置。</p>
</blockquote>
<ul>
<li>半同步复制</li>
</ul>
<blockquote>
<p>master只保证slaves中的一个操作成功就返回，其他的不管。这个是由goole为MySQL引入的。</p>
</blockquote>
<h2 id="44-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）"><a href="#44-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）" class="headerlink" title="44. 数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）"></a>44. 数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）</h2><ul>
<li>Undo Log</li>
</ul>
<blockquote>
<p>为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog），然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。</p>
</blockquote>
<blockquote>
<p>为了保证事务持久性，必须将数据在事务提交前写到磁盘,只要事务成功提交，数据必然已经持久化。Undo log必须先于数据持久化到磁盘，如果在G,H之间系统崩溃，undo log是完整的， 可以用来回滚事务；如果在A-F之间系统崩溃，因为数据没有持久化到磁盘，所以磁盘上的数据还是保持在事务开始前的状态。</p>
</blockquote>
<blockquote>
<p>缺陷：每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少IO提高性能，但这样就会丧失事务的持久性。</p>
</blockquote>
<ul>
<li>Redo Log</li>
</ul>
<blockquote>
<p>原理和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化，系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。</p>
</blockquote>
<h1 id="Mysql数据库"><a href="#Mysql数据库" class="headerlink" title="Mysql数据库"></a>Mysql数据库</h1><h2 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1. 创建数据库"></a>1. 创建数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- utf-8</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_name <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- gbk</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_name <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> gbk <span class="keyword">COLLATE</span> gbk_chinese_ci;</span><br></pre></td></tr></table></figure>

<h2 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2. 用户管理"></a>2. 用户管理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建用户</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'密码'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除用户</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改用户</span></span><br><span class="line"><span class="keyword">rename</span> <span class="keyword">user</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span>; to '新用户名'@'IP地址';;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改密码</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">password</span> <span class="keyword">for</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span> = <span class="keyword">Password</span>(<span class="string">'新密码'</span>);</span><br><span class="line"><span class="comment">-- 或者用update更新user</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">password</span>=<span class="keyword">password</span>(<span class="string">'123'</span>) <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">'root'</span> <span class="keyword">and</span> host=<span class="string">'localhost'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改需要刷新才生效</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-授权管理"><a href="#3-授权管理" class="headerlink" title="3. 授权管理"></a>3. 授权管理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看权限</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">grant</span> <span class="keyword">for</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授权</span></span><br><span class="line"><span class="keyword">grant</span> 权限 <span class="keyword">on</span> database1.table1 <span class="keyword">to</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 取消权限</span></span><br><span class="line"><span class="keyword">revoke</span> 权限 <span class="keyword">on</span> database1.table1 <span class="keyword">from</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-修改表的列"><a href="#4-修改表的列" class="headerlink" title="4. 修改表的列"></a>4. 修改表的列</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">column</span> <span class="built_in">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 默认添加到最后一列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> age <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加到第一列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> addr <span class="built_in">char</span>(<span class="number">12</span>) <span class="keyword">first</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加到addr列后面</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> phone <span class="keyword">after</span> addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">drop</span> phone;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改列，只修改类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">modify</span> <span class="keyword">column</span> phone <span class="built_in">INTEGER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列名和类型同时修改</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">change</span> <span class="keyword">column</span> <span class="keyword">name</span> myname <span class="built_in">varchar</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h2 id="5-键的操作"><a href="#5-键的操作" class="headerlink" title="5. 键的操作"></a>5. 键的操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加主键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> primary <span class="keyword">key</span>(<span class="keyword">id</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除主键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">drop</span> primary <span class="keyword">key</span>(<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">modify</span> <span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">drop</span> primary <span class="keyword">key</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 从表 <span class="keyword">add</span> <span class="keyword">constraint</span> 从键名称 foreign_key 从表(外键字段)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> foreign_key key_name</span><br></pre></td></tr></table></figure>

<h2 id="6-设置默认值"><a href="#6-设置默认值" class="headerlink" title="6. 设置默认值"></a>6. 设置默认值</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置默认值</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">alter</span> age <span class="keyword">set</span> <span class="keyword">default</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除默认值</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">alter</span> age <span class="keyword">drop</span> <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<h2 id="7-SQL语句基础"><a href="#7-SQL语句基础" class="headerlink" title="7. SQL语句基础"></a>7. SQL语句基础</h2><p><strong><a href="https://www.runoob.com/sql/sql-tutorial.html" target="_blank" rel="noopener">SQL基础知识</a></strong></p>
<ul>
<li>select语句</li>
</ul>
<blockquote>
<p>格式：select 字段 from 表名； 全部字段可以用 *</p>
</blockquote>
<ul>
<li>where 用于限制查询的结果</li>
</ul>
<blockquote>
<p>格式：<code>where 字段=&#39;xxx&#39;;</code> 查询条件&gt; &lt; &gt;= &lt;= = !=</p>
</blockquote>
<ul>
<li><p>与(AND)或(OR)</p>
</li>
<li><p>在(IN)不在(NOT IN)</p>
</li>
<li><p>空(NULL)非空(NOT NULL)</p>
</li>
<li><p>全部(ALL) 任一(ANY)</p>
</li>
<li><p>在[a,b]之间</p>
</li>
</ul>
<blockquote>
<p>格式：between a and b</p>
</blockquote>
<ul>
<li>排重DISTINCT</li>
</ul>
<blockquote>
<p>格式：<code>select DISTINCT 字段 from 表名;</code></p>
</blockquote>
<ul>
<li>insert语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(列名,列名) <span class="keyword">values</span>(值,值);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb1(<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'luck'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>update语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更新数据</span></span><br><span class="line"><span class="keyword">update</span> tb1 <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'zhangsan'</span> <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>delete语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb1 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">name</span> = <span class="string">'luck'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="8-排序"><a href="#8-排序" class="headerlink" title="8. 排序"></a>8. 排序</h2><ul>
<li>ORDER BY语句</li>
</ul>
<blockquote>
<p>格式：<code>select 字段 from 表名 where 条件 ORDER BY 字段;</code></p>
</blockquote>
<ul>
<li>升序(ASC)与降序(DESC)</li>
</ul>
<blockquote>
<p>格式：<code>select 字段 from 表名 where 条件 ORDER BY 字段 ASC;</code></p>
</blockquote>
<blockquote>
<p>格式：<code>select 字段 from 表名 where 条件 ORDER BY 字段 DESC;</code>  </p>
</blockquote>
<ul>
<li>多项排序</li>
</ul>
<blockquote>
<p>格式：<code>select 字段 from 表名 where 条件 ORDER BY 字段 ASC|DESC，字段ASC|DESC;</code></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 升序</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表 <span class="keyword">order</span> <span class="keyword">by</span> 列 <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 降序</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表 <span class="keyword">order</span> <span class="keyword">by</span> 列 <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多项排序</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表 <span class="keyword">order</span> <span class="keyword">by</span> 列<span class="number">1</span> <span class="keyword">desc</span>,列<span class="number">2</span> <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>

<h2 id="9-聚合函数"><a href="#9-聚合函数" class="headerlink" title="9. 聚合函数"></a>9. 聚合函数</h2><blockquote>
<p>把 select 语句的查询结果汇聚成一个结果，这样的函数叫聚合函数。</p>
</blockquote>
<ul>
<li><p>最大值(MAX)</p>
</li>
<li><p>最小值(MIN)</p>
</li>
<li><p>平均值(SVG)</p>
</li>
<li><p>求和(SUM)</p>
</li>
<li><p>统计数量(COUNT)</p>
</li>
</ul>
<h2 id="10-分组"><a href="#10-分组" class="headerlink" title="10. 分组"></a>10. 分组</h2><ul>
<li>GROUP BY</li>
</ul>
<blockquote>
<p>格式：<code>select 组函数 from 表 where 条件 group by 字段;</code><br>特别的<code>group by</code> 必须在where之后,<code>order by</code>之前</p>
</blockquote>
<ul>
<li>HAVING 组判断条件，它的真假决定一组数据是否返回</li>
</ul>
<blockquote>
<p>格式：<code>select 组函数 from 表 where 条件 group by 字段 having 组判断条件;</code></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> tb1 <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">num</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">num</span>, <span class="keyword">id</span> <span class="keyword">from</span> tb1 <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">num</span>, <span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">num</span>, <span class="keyword">id</span> <span class="keyword">from</span> tb1 <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">5</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">num</span>, <span class="keyword">id</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">num</span>, <span class="keyword">id</span> <span class="keyword">count</span>(*), <span class="keyword">sum</span>(score), <span class="keyword">max</span>(score), <span class="keyword">min</span>(score) <span class="keyword">from</span> tb1 <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">num</span>, <span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> tb1 <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">num</span> <span class="keyword">having</span> <span class="keyword">max</span>(<span class="keyword">id</span>) &gt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="11-关联查询"><a href="#11-关联查询" class="headerlink" title="11. 关联查询"></a>11. 关联查询</h2><ul>
<li>JOIN：如果表中有至少一个匹配，则返回行  </li>
</ul>
<blockquote>
<p>格式：<code>select * from a join b on a.id=b.id;</code></p>
</blockquote>
<ul>
<li>内连接(INNER JOIN)：只返回两个表中联结字段相等的行</li>
</ul>
<blockquote>
<p>格式：<code>select * from a inner join b on a.id=b.id;</code>  其中inner可以省略，等同于JOIN的用法</p>
</blockquote>
<ul>
<li>左外连接(LEFT JOIN 或 LEFT OUTER JOIN)：即使右表中没有匹配，也从左表返回所有的行</li>
</ul>
<blockquote>
<p>格式：<code>select * from a left outer join b on a.id=b.aid;</code>  其中outer可忽略</p>
</blockquote>
<ul>
<li>右外连接(RIGHT JOIN 或 RIGHT OUTER JOIN)：即使左表中没有匹配，也从右表返回所有的行</li>
</ul>
<blockquote>
<p>格式：<code>select * from a right outer join b on a.id=b.aid;</code>  其中outer可忽略</p>
</blockquote>
<ul>
<li>全连接(FULL JOIN 或 FULL OUTER JOIN): 只要其中一个表中存在匹配，就返回行。相当于左外连接+右外链接，注意mysql不支持全连接</li>
</ul>
<blockquote>
<p>格式：<code>select * from a full outer join b on a.id=b.id;</code> 其中outer可忽略</p>
</blockquote>
<ul>
<li>自连接：自连接意思是把自身表当成另外一张表看待，互相关联查询，连接方式可以使用以上的内外连接，这种连接方式可以解决很多奇怪的问题。</li>
</ul>
<blockquote>
<p>格式：<code>SELECT ab.* from a ab,a ac where ab.id&gt;ac.id;</code></p>
</blockquote>
<h2 id="12-组合"><a href="#12-组合" class="headerlink" title="12. 组合"></a>12. 组合</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 组合，自动处理重合</span></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> A <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> B;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 组合，不处理重合</span></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> A <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> B;</span><br></pre></td></tr></table></figure>

<h2 id="13-LIMIT的用法"><a href="#13-LIMIT的用法" class="headerlink" title="13. LIMIT的用法"></a>13. LIMIT的用法</h2><blockquote>
<p>格式：<code>select * from student limit 10;</code>  查询前10条数据，显示1-10条数据</p>
</blockquote>
<blockquote>
<p>格式：<code>select * from student limit 1,10;</code>  查询从第2行开始，累加10条id记录，共显示id为2….11</p>
</blockquote>
<blockquote>
<p>格式：<code>select * from student limit 5,10;</code>  查询从第6行开始向前加10条数据，共显示id为6,7….15  </p>
</blockquote>
<blockquote>
<p>格式：<code>select * from student limit i,n;</code>  i: 为查询结果的索引值(默认从0开始),当i=0时可省略i; n: 为查询结果返回的数量</p>
</blockquote>
<h2 id="14-case-when"><a href="#14-case-when" class="headerlink" title="14. case when"></a>14. case when</h2><p><strong><a href="https://www.cnblogs.com/aipan/p/7770611.html" target="_blank" rel="noopener">CASE WHEN 及 SELECT CASE WHEN的用法</a></strong><br><strong><a href="https://www.cnblogs.com/cx-zyq/archive/2013/05/16/3082295.html" target="_blank" rel="noopener">SQL Case when 的使用方法</a></strong></p>
<ul>
<li>简单Case函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CASE sex</span><br><span class="line">WHEN '1' THEN '男'</span><br><span class="line">WHEN '2' THEN '女'</span><br><span class="line">ELSE '其他' <span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Case搜索函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CASE WHEN sex = '1' THEN '男'</span><br><span class="line">WHEN sex = '2' THEN '女'</span><br><span class="line">ELSE '其他' <span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>两种方式，可以实现相同的功能。简单Case函数的写法相对比较简洁，但是和Case搜索函数相比，功能方面会有些限制，比如写判断式。还有一个需要注意的问题，Case函数只返回第一个符合条件的值，剩下的Case部分将会被自动忽略。</p>
</blockquote>
<p><strong>实例分析：</strong></p>
<p>(1). 已知数据按照另外一种方式进行分组，分析</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*根据这个国家人口数据，统计亚洲和北美洲的人口数量*/</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">SUM</span>(population),</span><br><span class="line"><span class="keyword">CASE</span> country  <span class="keyword">WHEN</span> <span class="string">'中国'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="string">'印度'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="string">'日本'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="string">'美国'</span> <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="string">'加拿大'</span>  <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="string">'墨西哥'</span>  <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'其他'</span> <span class="keyword">END</span></span><br><span class="line"><span class="keyword">FROM</span>    Table_A</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">CASE</span> country </span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'中国'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'印度'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'日本'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'美国'</span> <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'加拿大'</span>   <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'墨西哥'</span>   <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'其他'</span> <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*判断工资的等级，并统计每一等级的人数*/</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary &lt;= <span class="number">500</span> <span class="keyword">THEN</span> <span class="string">'1'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">500</span> <span class="keyword">AND</span> salary &lt;= <span class="number">600</span>  <span class="keyword">THEN</span> <span class="string">'2'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">600</span> <span class="keyword">AND</span> salary &lt;= <span class="number">800</span>  <span class="keyword">THEN</span> <span class="string">'3'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">800</span> <span class="keyword">AND</span> salary &lt;= <span class="number">1000</span> <span class="keyword">THEN</span> <span class="string">'4'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span> salary_class, <span class="comment">-- 别名命名</span></span><br><span class="line"><span class="keyword">COUNT</span>(*)  <span class="keyword">FROM</span>    Table_A</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary &lt;= <span class="number">500</span> <span class="keyword">THEN</span> <span class="string">'1'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">500</span> <span class="keyword">AND</span> salary &lt;= <span class="number">600</span>  <span class="keyword">THEN</span> <span class="string">'2'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">600</span> <span class="keyword">AND</span> salary &lt;= <span class="number">800</span>  <span class="keyword">THEN</span> <span class="string">'3'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">800</span> <span class="keyword">AND</span> salary &lt;= <span class="number">1000</span> <span class="keyword">THEN</span> <span class="string">'4'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>(2). 用一个SQL语句完成不同条件的分组</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按照国家和性别进行分组*/</span></span><br><span class="line"><span class="keyword">SELECT</span> country, </span><br><span class="line"><span class="keyword">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="string">'1'</span> <span class="keyword">THEN</span>  population <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>),  <span class="comment">--男性人口</span></span><br><span class="line"><span class="keyword">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="string">'2'</span> <span class="keyword">THEN</span>  population <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)   <span class="comment">--女性人口</span></span><br><span class="line"><span class="keyword">FROM</span>  Table_A  <span class="keyword">GROUP</span> <span class="keyword">BY</span> country;</span><br></pre></td></tr></table></figure>

<p>(3). 在Check中使用Case函数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*公司A，这个公司有个规定，女职员的工资必须高于1000块*/</span></span><br><span class="line">CONSTRAINT check_salary <span class="keyword">CHECK</span></span><br><span class="line">( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">THEN</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary &gt; <span class="number">1000</span></span><br><span class="line"><span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="number">1</span> <span class="keyword">END</span> = <span class="number">1</span> )</span><br></pre></td></tr></table></figure>

<p>(4). 根据条件有选择的UPDATE</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1.工资5000以上的职员，工资减少10% */</span></span><br><span class="line"><span class="keyword">UPDATE</span> Personnel  <span class="keyword">SET</span> salary = salary * <span class="number">0.9</span>  <span class="keyword">WHERE</span> salary &gt;= <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.工资在2000到4600之间的职员，工资增加15% */</span></span><br><span class="line"><span class="keyword">UPDATE</span> Personnel  <span class="keyword">SET</span> salary = salary * <span class="number">1.15</span> <span class="keyword">WHERE</span> salary &gt;= <span class="number">2000</span> <span class="keyword">AND</span> salary &lt; <span class="number">4600</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.如果满足条件1和条件2，顺序执行则会出现问题。</span></span><br><span class="line"><span class="comment">假设有个人工资5000块。首先，按照条件1，工资减少10%，变成工资4500。</span></span><br><span class="line"><span class="comment">接下来运行第二个SQL时候，因为这个人的工资是4500在2000到4600的范围之内，需增加15%，</span></span><br><span class="line"><span class="comment">最后这个人的工资结果是5175,不但没有减少，反而增加了。</span></span><br><span class="line"><span class="comment">如果要是反过来执行，那么工资4600的人相反会变成减少工资。 </span></span><br><span class="line"><span class="comment">这里用到case when 进行不同条件的更新*/</span></span><br><span class="line"><span class="keyword">UPDATE</span> Personnel</span><br><span class="line"><span class="keyword">SET</span> salary =</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary &gt;= <span class="number">5000</span>  　                <span class="keyword">THEN</span> salary * <span class="number">0.9</span></span><br><span class="line">     <span class="keyword">WHEN</span> salary &gt;= <span class="number">2000</span> <span class="keyword">AND</span> salary &lt; <span class="number">4600</span>  <span class="keyword">THEN</span> salary * <span class="number">1.15</span></span><br><span class="line"><span class="keyword">ELSE</span> salary <span class="keyword">END</span>;  <span class="comment">-- 这行else必须写，不写会导致不符合这两个条件的工资会变成NULL</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 把主键a和b相互交换 */</span></span><br><span class="line"><span class="keyword">UPDATE</span> SomeTable</span><br><span class="line"><span class="keyword">SET</span> p_key = <span class="keyword">CASE</span> <span class="keyword">WHEN</span> p_key = <span class="string">'a'</span>  <span class="keyword">THEN</span> <span class="string">'b'</span></span><br><span class="line"><span class="keyword">WHEN</span> p_key = <span class="string">'b'</span>  <span class="keyword">THEN</span> <span class="string">'a'</span>  <span class="keyword">ELSE</span> p_key <span class="keyword">END</span></span><br><span class="line"><span class="keyword">WHERE</span> p_key <span class="keyword">IN</span> (<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>检查两个表数据是否一致</li>
</ul>
<blockquote>
<p>Case函数不同于DECODE函数。在Case函数中，可以使用BETWEEN,LIKE,IS NULL,IN,EXISTS等等。比如说使用IN,EXISTS，可以进行子查询，从而 实现更多的功能。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用IN的时候</span></span><br><span class="line"><span class="keyword">SELECT</span> keyCol,</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> keyCol <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> keyCol <span class="keyword">FROM</span> tbl_B )  <span class="keyword">THEN</span> <span class="string">'Matched'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'Unmatched'</span> <span class="keyword">END</span> Label</span><br><span class="line"><span class="keyword">FROM</span> tbl_A;</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用EXISTS的时候</span></span><br><span class="line"><span class="keyword">SELECT</span> keyCol,</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">EXISTS</span> ( <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_B  <span class="keyword">WHERE</span> tbl_A.keyCol = tbl_B.keyCol )  <span class="keyword">THEN</span> <span class="string">'Matched'</span>  <span class="keyword">ELSE</span> <span class="string">'Unmatched'</span> <span class="keyword">END</span> Label</span><br><span class="line"><span class="keyword">FROM</span> tbl_A;</span><br></pre></td></tr></table></figure>

<ul>
<li>在Case函数中使用合计函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Studentclass</span></span><br><span class="line"><span class="comment">+------+----------+--------------+-----------------+</span></span><br><span class="line"><span class="comment">|std_id| class_id |  class_name  |  main_class_flg |</span></span><br><span class="line"><span class="comment">+------+----------+--------------+-----------------+</span></span><br><span class="line"><span class="comment">| 100  |    1     |     经济学    |        Y        |</span></span><br><span class="line"><span class="comment">| 100  |    2     |     历史学    |        N        |</span></span><br><span class="line"><span class="comment">| 200  |    2     |     历史学    |        N        |</span></span><br><span class="line"><span class="comment">| 200  |    3     |     考古学    |        Y        |</span></span><br><span class="line"><span class="comment">| 200  |    4     |     计算机    |        N        |</span></span><br><span class="line"><span class="comment">| 300  |    4     |     计算机    |        N        |</span></span><br><span class="line"><span class="comment">| 400  |    5     |      化学     |        N        |</span></span><br><span class="line"><span class="comment">| 500  |    6     |      数学     |        N        |</span></span><br><span class="line"><span class="comment">+------+----------+---------------+----------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--条件1：只选择了一门课程的学生, 返回那门课程的ID</span></span><br><span class="line"><span class="keyword">SELECT</span> std_id, <span class="keyword">MAX</span>(class_id) <span class="keyword">AS</span> main_class  <span class="keyword">FROM</span> Studentclass  <span class="keyword">GROUP</span> <span class="keyword">BY</span> std_id  <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--条件2：选择多门课程的学生, 返回所选的主课程ID</span></span><br><span class="line"><span class="keyword">SELECT</span> std_id, class_id <span class="keyword">AS</span> main_class  <span class="keyword">FROM</span> Studentclass  <span class="keyword">WHERE</span> main_class_flg = <span class="string">'Y'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用Case函数,满足以上两个条件</span></span><br><span class="line"><span class="keyword">SELECT</span>  std_id, </span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">COUNT</span>(*) = <span class="number">1</span>                   <span class="keyword">THEN</span> <span class="keyword">MAX</span>(class_id)</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> main_class_flg = <span class="string">'Y'</span>  <span class="keyword">THEN</span> class_id  <span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span>)</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> main_class</span><br><span class="line"><span class="keyword">FROM</span> Studentclass  <span class="keyword">GROUP</span> <span class="keyword">BY</span> std_id;</span><br></pre></td></tr></table></figure>

<ul>
<li>select case when</li>
</ul>
<blockquote>
<p>select 与 case结合使用最大的好处有两点，一是在显示查询结果时可以灵活的组织格式，二是有效避免了多次对同一个表或几个表的访问。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 例如表 students(id, name ,birthday, sex, grade)，要求按每个年级统计男生和女生的数量各是多少，统计结果的表头为，年级，男生数量，女生数量。如果不用select case when，为了将男女数量并列显示，统计起来非常麻烦，先确定年级信息，再根据年级取男生数和女生数，而且很容易出错。*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> grade, <span class="keyword">COUNT</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="number">1</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                            <span class="keyword">ELSE</span> <span class="literal">NULL</span></span><br><span class="line">                        <span class="keyword">END</span>) 男生数,</span><br><span class="line">               <span class="keyword">COUNT</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="number">2</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                            <span class="keyword">ELSE</span> <span class="literal">NULL</span></span><br><span class="line">                       <span class="keyword">END</span>) 女生数</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> grade;</span><br></pre></td></tr></table></figure>

<h2 id="15-mysql-常用数据类型"><a href="#15-mysql-常用数据类型" class="headerlink" title="15. mysql 常用数据类型"></a>15. mysql 常用数据类型</h2><ul>
<li><p>字符串类型</p>
<ul>
<li>CHAR：0-255 bytes, 存定长字符串</li>
<li>VARCHAR：0-65535 bytes, 存不定长字符串</li>
<li>TINYBLOB: 0-255 bytes, 不超过 255 个字符的二进制字符串</li>
<li>TINYTEXT: 0-255 bytes, 短文本字符串</li>
<li>BLOB: 0-65535 bytes, 二进制形式的长文本数据</li>
<li>TEXT: 0-65535 bytes, 长文本数据</li>
<li>MEDIUMBLOB: 0-16777215 bytes, 二进制形式的中等长度文本数据</li>
<li>MEDIUMTEXT: 0-16777215 bytes, 中等长度文本数据</li>
<li>LONGBLOB: 0-4294967295 bytes, 二进制形式的极大文本数据</li>
<li>LONGTEXT: 0-4294967295 bytes, 极大文本数据</li>
</ul>
</li>
<li><p>数值类型</p>
<ul>
<li>TINYINT: 1 bytes, 有符号范围(-128，127)、无符号范围(0，255)</li>
<li>SMALLINT: 2 bytes, 有符号范围(-32768，32767)、无符号范围(0，65535)</li>
<li>MEDIUMINT: 3 bytes, 有符号范围(-8388608，8388607)、无符号范围(0，16777215)</li>
<li>INT/INTEGER: 4 bytes, 有符号范围(-2147483648，2147483647)、无符号范围(0，4294967295)</li>
<li>BIGINT: 8 bytes, 有符号范围(-9223372036854775808，9223372036854775807)、无符号范围(0，18446744073709551615)</li>
<li>FLOAT: 4 bytes, 有符号范围[(-3.402823466E+38，-1.175494351 E-38)，0，(1.175494351E-38，3.402823466351E+38)]、无符号范围<code>[0，(1.175494351E-38，3.402823466E+38)]</code></li>
<li>DOUBLE: 8 bytes, 有符号范围[(-1.7976931348623157E+308，-2.2250738585072014E-308)，0，(2.2250738585072014E-308，1.797 6931348623157E+308)]、无符号范围[0，(2.2250738585072014 E-308，1.7976931348623157E+308)]</li>
<li>DECIMAL: DECIMAL(M, D), 若M&gt;D，这为大小为M+2，否则为D+2</li>
</ul>
</li>
<li><p>日期类型</p>
<ul>
<li>DATE: 3 bytes, <code>YYYY-MM-DD（1000-01-01/9999-12-31）</code></li>
<li>TIME: 3 bytes, <code>HH:MM:SS（&#39;-838:59:59&#39;/&#39;838:59:59&#39;）</code></li>
<li>YEAR: 1 bytes, <code>YYYY（1901/2155）</code></li>
<li>DATETIME: 8 bytes, <code>YYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00/9999-12-31 23:59:59）</code></li>
<li>TIMESTAMP: 4 bytes, <code>YYYYMMDD HHMMSS（1970-01-01 00:00:00/2037 年某时）</code></li>
</ul>
</li>
</ul>
<h2 id="16-MySQL读取数据的基本单位"><a href="#16-MySQL读取数据的基本单位" class="headerlink" title="16. MySQL读取数据的基本单位"></a>16. MySQL读取数据的基本单位</h2><blockquote>
<p>在 MySQL 中数据读取的基本单位都是页，InnoDB 中页的默认大小是 16KB。</p>
</blockquote>
<h2 id="17-为什么mysql事务回滚后，自增ID依然自增"><a href="#17-为什么mysql事务回滚后，自增ID依然自增" class="headerlink" title="17. 为什么mysql事务回滚后，自增ID依然自增"></a>17. 为什么mysql事务回滚后，自增ID依然自增</h2><blockquote>
<p>因为<code>innodb</code>的<code>auto_increament</code>的计数器记录的当前值是保存在存内 存中的，并不是存在于磁盘上，当<code>mysql server</code>处于运行的时候，这个计数值只会随着<code>insert</code>改增长，不会随着<code>delete</code>而减少。</p>
</blockquote>
<blockquote>
<p>当<code>mysql server</code>启动时，当我们需要去查询<code>auto_increment</code>计数值时，mysql便会自动执行：<code>SELECT MAX(id) FROM 表名 FOR UPDATE;</code>语句来获得当前<code>auto_increment</code>列的最大值，然后将这个值放到<code>auto_increment</code>计数器中。所以就算Rollback MySQL的<code>auto_increament</code>计数器也不会作负运算。</p>
</blockquote>
<h2 id="18-mysql的主从复制的实现过程"><a href="#18-mysql的主从复制的实现过程" class="headerlink" title="18. mysql的主从复制的实现过程"></a>18. mysql的主从复制的实现过程</h2><p><strong><a href="https://www.cnblogs.com/cocoxu1992/p/10670589.html" target="_blank" rel="noopener">MySQL主从复制的实现过程</a></strong></p>
<ul>
<li><p>主从复制的作用</p>
<ul>
<li>主数据库出现问题，可以切换到从数据库</li>
<li>可以进行数据库层面的读写分离</li>
<li>可以在从数据库上进行日常备份</li>
</ul>
</li>
<li><p>主从复制的过程</p>
<ul>
<li>(1). master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中.</li>
<li>(2). salve开启一个<code>I/O Thread</code>，该线程在master打开一个普通连接，主要工作是<code>binlog dump process</code>。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志（Realy log）中。</li>
<li>(3). SQL Thread会读取中继日志（Realy log），并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</li>
</ul>
</li>
<li><p>具体步骤</p>
<ul>
<li><p>准备两台服务器，安装mysql</p>
<blockquote>
<p>主库是：192.168.x.x master<br>从库是：192.168.x.xx slave</p>
</blockquote>
</li>
<li><p>主库操作：</p>
<ul>
<li>（1）开启binlog功能，修改<code>vim /etc/my.cnf</code>配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">&lt;!-- 指明主库的身份id为1 --&gt;</span><br><span class="line">server-id=1</span><br><span class="line">&lt;!-- 指明binlog的日志名 --&gt;</span><br><span class="line"><span class="built_in">log</span>-bin=/var/<span class="built_in">log</span>/mysql/mysql-bin</span><br><span class="line">&lt;!-- 为了在使用带事务的InnoDB进行复制设置时尽可能提高持久性和一致性 --&gt;</span><br><span class="line">innodb_flush_log_at_trx_commit = 1</span><br><span class="line">sync_binlog = 1</span><br></pre></td></tr></table></figure>

<ul>
<li>（2）创建日志目录并赋予权限，重启mysql，使得binlog生效</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 创建日志目录 --&gt;</span><br><span class="line">mkdir /var/<span class="built_in">log</span>/mysql</span><br><span class="line">&lt;!-- 赋予权限 --&gt;</span><br><span class="line">chown mysql.mysql /varlog/mysql</span><br><span class="line">&lt;!-- mysqld重启服务 --&gt;</span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<ul>
<li>（3）登录mysql，检查主库的状态</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>（4）创建一个用户，用于进行主从同步</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'database_backup'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'database_backup_666'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>（5）授予账号权限，授予一个从库的身份权限</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> . <span class="keyword">to</span> <span class="string">'database_backup'</span>@<span class="string">'%'</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>（6）锁定mysql的表，防止数据写入</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">table</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>（7）这一步需要等下面到处数据完成后，然后解除锁表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出数据</p>
<ul>
<li>导出当前的数据，用于slave机器导入数据，保证在一个起始点</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p <span class="comment">--all-databases &gt; /data/db.dump;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将此db.dump文件远程传输给 slave机器，用于导入</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /data/db.dump root@192.168.x.x:/tmp/</span><br></pre></td></tr></table></figure>
</li>
<li><p>从库操作：</p>
<ul>
<li>（1）修改<code>vim /etc/my.cnf</code>配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=2</span><br></pre></td></tr></table></figure>

<ul>
<li>（2）重启mysql，使得binlog生效</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- mysqld重启服务 --&gt;</span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<ul>
<li>（3）登录slave从库，导入主库的数据信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /tmp/db.dump;</span><br></pre></td></tr></table></figure>

<ul>
<li>（4）从数据库上进行复制行为的相关配置</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">'192.168.x.xx'</span>,</span><br><span class="line">master_user=<span class="string">'database_backup'</span>,</span><br><span class="line">master_password=<span class="string">'database_backup_666'</span>,</span><br><span class="line">master_log_file=<span class="string">'mysql-bin.000001'</span>,  <span class="comment">-- 根据show master status给出的状态</span></span><br><span class="line">master_log_pos=<span class="number">666</span>;  <span class="comment">-- 根据show master status给出的状态</span></span><br></pre></td></tr></table></figure>

<ul>
<li>（5）启动slave线程</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave <span class="keyword">start</span>;</span><br></pre></td></tr></table></figure>

<p>-（6）检查slave状态，检查两条参数，如果都是yes，即主从ok</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="19-mysql高并发环境解决方案"><a href="#19-mysql高并发环境解决方案" class="headerlink" title="19. mysql高并发环境解决方案"></a>19. mysql高并发环境解决方案</h2><ul>
<li>水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力；</li>
<li>集群方案，解决DB宕机带来的单点DB不能访问问题；</li>
<li>读写分离策略，极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力；</li>
</ul>
<h1 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h1><h2 id="1-什么是Redis"><a href="#1-什么是Redis" class="headerlink" title="1. 什么是Redis"></a>1. 什么是Redis</h2><blockquote>
<p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>
</blockquote>
<blockquote>
<p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>
</blockquote>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<blockquote>
<p>Redis的优势：</p>
</blockquote>
<ul>
<li>性能极高：Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>丰富的数据类型：Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>原子性：Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li>丰富的特性：Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>
</ul>
<blockquote>
<p>Redis与其他key-value存储有什么不同</p>
</blockquote>
<ul>
<li><p>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</p>
</li>
<li><p>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p>
</li>
</ul>
<p><strong><a href="https://www.runoob.com/redis/redis-intro.html" target="_blank" rel="noopener">以上来源于《菜鸟教程–Redis简介》</a></strong></p>
<h2 id="2-redis的数据类型"><a href="#2-redis的数据类型" class="headerlink" title="2. redis的数据类型"></a>2. redis的数据类型</h2><ul>
<li>字符串(String)</li>
</ul>
<blockquote>
<p>string类型是二进制安全的，可以包含任何数据，比如JPG图片或者序列化对象。string类型是Redis最基本的数据类型，一个键最大能存储512MB。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置字符串类型</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key value</span><br><span class="line"><span class="comment"># 读取字符串类型</span></span><br><span class="line">127.0.0.1:6379&gt; get key value</span><br></pre></td></tr></table></figure>

<ul>
<li>哈希(Hash)</li>
</ul>
<blockquote>
<p>hash存的是字符串和字符串值之间的映射，是一个键值(key=&gt;value)对集合，比如用户存储姓名、年龄等信息，非常适合存储对象。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立哈希，并赋值</span></span><br><span class="line">127.0.0.1:6379&gt; hmset name key1 value1 key2 value2 ...</span><br><span class="line">127.0.0.1:6379&gt; hmset user:001 username liming <span class="built_in">pwd</span> 123456 age 18</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出哈希的内容</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall user:001</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="string">"username"</span></span><br><span class="line"><span class="string">"liming"</span></span><br><span class="line"><span class="string">"pwd"</span></span><br><span class="line"><span class="string">"123456"</span></span><br><span class="line"><span class="string">"age"</span></span><br><span class="line"><span class="string">"18"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改哈希中的某一个值</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall user:001 <span class="built_in">pwd</span> aaaaaa</span><br><span class="line"><span class="comment"># 查看更改后的哈希的内容</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall user:001</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="string">"username"</span></span><br><span class="line"><span class="string">"liming"</span></span><br><span class="line"><span class="string">"pwd"</span></span><br><span class="line"><span class="string">"aaaaaa"</span></span><br><span class="line"><span class="string">"age"</span></span><br><span class="line"><span class="string">"18"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>列表(List)</li>
</ul>
<blockquote>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序，底层实现是链表，对于一个具有几百上千万个元素的list来说，在头部和尾部插入一个新元素，其时间复杂度是常数级别的，插入速度也是不变的。弊端就是链表型的list比数组型的list定位更慢。list主要应用在消息队列上，可以确保先后顺序，还可以利用<code>lrange</code>实现分页功能，博客系统中评论也可以存入一个单独的list中。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 头部插入元素</span></span><br><span class="line">127.0.0.1:6379&gt; lpush mylist <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尾部插入元素</span></span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">"2"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取list中的元素</span></span><br><span class="line">127.0.0.1:6379&gt; lrange mylist index1 index2 ...</span><br><span class="line"><span class="comment"># 读取list中编号0到倒数第一个元素</span></span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除元素</span></span><br><span class="line">127.0.0.1:6379&gt; lrem mylist index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取list长度</span></span><br><span class="line">127.0.0.1:6379&gt; llen mylist</span><br></pre></td></tr></table></figure>

<ul>
<li>集合(Set)</li>
</ul>
<blockquote>
<p>Redis的Set是string类型的无序且元素不重复的集合，集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)，同时可以进行集合运算：取交集、取并集、取差集等。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">"1"</span></span><br><span class="line"><span class="comment"># 读取元素</span></span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line"><span class="comment"># 删除元素</span></span><br><span class="line">127.0.0.1:6379&gt; srem myset <span class="string">"1"</span></span><br><span class="line"><span class="comment"># 判断元素是否存在，存在返回1，否则返回0</span></span><br><span class="line">127.0.0.1:6379&gt; sismember myset <span class="string">"1"</span></span><br><span class="line"><span class="comment"># 取交集</span></span><br><span class="line">127.0.0.1:6379&gt; sinter set1 set2</span><br><span class="line"><span class="comment"># 取并集</span></span><br><span class="line">127.0.0.1:6379&gt; sunion set1 set2</span><br><span class="line"><span class="comment"># 取差集</span></span><br><span class="line">127.0.0.1:6379&gt; sdiff set1 set2</span><br></pre></td></tr></table></figure>

<ul>
<li>有序集合(sorted set)</li>
</ul>
<blockquote>
<p>有序集合中，每个元素都会关联一个double类型的分数(score)，redis正是通过分数来为集合中的元素进行从小到大的排序。有序集合中的元素是唯一的，但分数(score)可以重复。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加元素，赋予序号1</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 1 aa</span><br><span class="line"><span class="comment"># 添加元素，赋予序号2</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 2 bb</span><br><span class="line"><span class="comment"># 添加元素，赋予序号3</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 3 cc</span><br><span class="line"><span class="comment"># 读取元素，并输出序号（即score）</span></span><br><span class="line">127.0.0.1:6379&gt; zrange myzset 0 -1 with scores</span><br><span class="line"><span class="comment"># 得出排名</span></span><br><span class="line">127.0.0.1:6379&gt; zrange myzset cc</span><br></pre></td></tr></table></figure>

<h2 id="3-两种持久化方式"><a href="#3-两种持久化方式" class="headerlink" title="3. 两种持久化方式"></a>3. 两种持久化方式</h2><blockquote>
<p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
</blockquote>
<ul>
<li>RDB(Redis DataBase)</li>
</ul>
<blockquote>
<p>RDB是Redis默认的方式，就是把某一时刻的数据以快照的方式存储到磁盘等介质上。Redis在进行持久化过程中，会调用rdbSave()函数，把数据写到临时文件中，等持久化过程都结束了，才调用rdbLoad()函数加载上次持久化好的文件，并用新的临时文件进行覆盖，快照文件总是完整的。</p>
</blockquote>
<blockquote>
<p>Redis会单独创建一个子进程进行持久化，而主进程是不会进行任何IO操作，确保了Redis极高的性能。</p>
</blockquote>
<blockquote>
<p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。但是如果对数据的完整性非常敏感，RDB方式安全性低一些，可能在故障时丢失数据。</p>
</blockquote>
<ul>
<li>AOF(Append Only File)</li>
</ul>
<blockquote>
<p>Append Only File意思是只允许最佳不允许改写的文件，AOF的方式是将执行过程的所有写指令记录下来，在数据回复时按照冲钱到后顺序在将指令执行一遍。通过配置redis.conf中的<code>appendonly yes</code>就可以打开AOF功能，每当服务器执行定时任务或者函数时，都会调用<code>flushAppendOnlyFile()</code>函数，根据条件将aof_buf中的缓存写到AOF文件中，而后调用<code>fsync()</code>或 <code>fdatasync()</code>函数将AOF保存到磁盘中。其中AOF默认持久化的策略是每秒钟fsync一次，所以对数据安全更加有保障。</p>
</blockquote>
<blockquote>
<p>因为采用了追加的方式，不做处理的话，AOF文件将会越来越大，所以要使用AOF文件重写机制，当AOF文件大小超过说设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。如100条INCR指令可以合并层一条SET指令。</p>
</blockquote>
<blockquote>
<p>在进行AOF重写时，仍然先写入临时文件，全部完成后再进行替换，因此断电、磁盘满等问题都不会影响AOF文件的可用性。</p>
</blockquote>
<blockquote>
<p>在同样的数据规模下，AOF文件比RDB文件的体积更大，且AOF方式恢复数据的速度也比RDB方式慢。</p>
</blockquote>
<h2 id="4-RDB与AOF比较"><a href="#4-RDB与AOF比较" class="headerlink" title="4. RDB与AOF比较"></a>4. RDB与AOF比较</h2><ul>
<li>AOF文件比RDB更新更加频繁，因此AOF文件更大</li>
<li>AOF方式比RDB方式数据安全性更高</li>
<li>RDB性能比AOF更好</li>
<li>优先使用AOF还原数据</li>
</ul>
<h2 id="5-如果AOF文件出现被写坏的情况，该怎么处理"><a href="#5-如果AOF文件出现被写坏的情况，该怎么处理" class="headerlink" title="5. 如果AOF文件出现被写坏的情况，该怎么处理"></a>5. 如果AOF文件出现被写坏的情况，该怎么处理</h2><blockquote>
<p>出现AOF文件被写坏的情况，Redis并不会冒然加载这个有问题的AOF文件，而是报错退出，这时可以用过以下步骤来修复出错文件：</p>
</blockquote>
<ul>
<li>备份被写坏的AOF文件</li>
<li>运行<code>redis-check-aof -fix</code>进行修复</li>
<li>用<code>diff -u</code>比两个文件的差异，定位问题点并修复</li>
<li>重启redis，加载修复后的AOF文件</li>
</ul>
<h2 id="6-redis-和-memcached-的主要区别"><a href="#6-redis-和-memcached-的主要区别" class="headerlink" title="6. redis 和 memcached 的主要区别"></a>6. redis 和 memcached 的主要区别</h2><p><strong><a href="https://www.cnblogs.com/xingxia/p/redis_compare_memcache.html" target="_blank" rel="noopener">redis和memcached的区别详解</a></strong></p>
<ul>
<li>Redis支持服务器端的数据操作：相比于memcached，redis拥有更多是数据结构，所以支持更多的数据操作，而在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。</li>
<li>内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。</li>
<li>性能对比：redis只支持单核，memcached可以使用多核，所以平均每一个核上 redis 在存储小数据时比 memcached 性能更高，但是在大数据存储上的处理memcached性能更高。</li>
<li>redis内部使用的是文件事件处理器<code>file event handler</code>，是单线程模型，处理效率高。文件事件处理器的结构包含多个socket、IO多路复用程序（非阻塞）、文件事件分派器、事件处理器四个部分。</li>
<li>存储数据安全：Redis拥有持久化机制，而memcached没有。</li>
<li>应用场景：Redis除了作为NoSQL数据库使用外，还能做消息队列、数据堆栈和数据缓存等；而Memcached适用于缓存SQL语句、数据集、用户临时性数据、延迟查询数据和session等。</li>
</ul>
<h2 id="7-事务处理"><a href="#7-事务处理" class="headerlink" title="7. 事务处理"></a>7. 事务处理</h2><blockquote>
<p>Redis 事务可以一次执行多个命令，并且带有以下三个重要的保证：</p>
</blockquote>
<ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中</li>
</ul>
<blockquote>
<p>一个事务从开始到执行会经历开始事务、命令入队、执行事务三个阶段。</p>
</blockquote>
<blockquote>
<p>redis 通过 MULTI、EXEC、DISCARD、WATCH四个指令实现事务处理</p>
</blockquote>
<ul>
<li>MULTI用来组装一个事务</li>
<li>EXEC用来执行一个事务</li>
<li>DISCARD用来取消一个事务</li>
<li>WATCH用来监视一些key，一旦这些key在事务执行之前被改变，则取消事务的执行</li>
</ul>
<h2 id="8-Redis常见的架构模式"><a href="#8-Redis常见的架构模式" class="headerlink" title="8. Redis常见的架构模式"></a>8. Redis常见的架构模式</h2><h3 id="1-单机模式"><a href="#1-单机模式" class="headerlink" title="(1) 单机模式"></a>(1) 单机模式</h3><ul>
<li>内存容量有限</li>
<li>处理能力有限</li>
<li>无法高可用</li>
</ul>
<h3 id="2-主从复制模式"><a href="#2-主从复制模式" class="headerlink" title="(2) 主从复制模式"></a>(2) 主从复制模式</h3><blockquote>
<p>MySQL一样，redis是支持主从同步的，而且也支持一主多从以及多级从结构。一是为了纯粹的冗余备份，二是为了提升读性能。</p>
</blockquote>
<blockquote>
<p>通常我们会设置一个主节点，N个从节点，默认情况下，主节点负责处理使用者的IO操作，而从节点则会对主节点的数据进行备份，并且也会对外提供读操作的处理。</p>
</blockquote>
<blockquote>
<p>主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。</p>
</blockquote>
<blockquote>
<p>Redis的主从同步是异步进行的，不会阻塞主节点，主节点和从节点是读写分离的。</p>
</blockquote>
<blockquote>
<p>全量同步：Redis全量复制一般发生在slave初始化阶段，这时，需要将Master上所有数据都复制一份。具体步骤如下：</p>
</blockquote>
<ul>
<li>从服务器连接主服务器，发送SYNC命令</li>
<li>主服务器接收到SYNC命令后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令</li>
<li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令</li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照</li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令</li>
<li>从服务器完成对快照的载入，开始接受命令请求 ，并执行来自主服务器缓冲区的写命令</li>
</ul>
<blockquote>
<p>增量同步：通常情况下，Master每执行一个写命令就回向Slave发送相同的命令，然后slave接收并执行。只有slave第一次连接是全量同步，断线重连有可能是全量同步，也有可能是增量同步；除此之外都是增量同步。</p>
</blockquote>
<blockquote>
<p>Redis主从复制模式的优点：</p>
</blockquote>
<ul>
<li>解决数据备份问题</li>
<li>实现读写分离，降低读压力，提高服务器性能</li>
</ul>
<blockquote>
<p>Redis主从复制模式的缺点：</p>
</blockquote>
<ul>
<li>无法实现高可用，一旦出现故障需要人工进行故障转移</li>
<li>无法实现动态扩容，受单击控制</li>
</ul>
<h3 id="3-哨兵模式"><a href="#3-哨兵模式" class="headerlink" title="(3) 哨兵模式"></a>(3) 哨兵模式</h3><blockquote>
<p>sentinel是基于主从模式进行优化，能够为Redis提供高可用性。在实际生产中，服务器难免遇到服务器宕机、停电、硬件损坏等突发状况，哨兵模式可以一定程度上帮助规避这些意外情况导致的灾难性的后果。核心还是主从复制，增加了由一个或多个Sentinel实例组成的Sentinel系统，监视任意多个主服务器以及这些主服务器属下的所有从服务器，当主服务器宕机导致不可写或者下线状态时，自动将主服务器下的某个服务器升级为新的主服务器。这样，就保证了Redis的高可用，规避数据丢失风险。</p>
</blockquote>
<blockquote>
<p>sentinel的特点：</p>
</blockquote>
<ul>
<li>监控（Monitoring）：它会监听不断检查主服务器和从服务器之间是否在正常工作。</li>
<li>通知（Notification）：当监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理管或者其他应用程序发送通知。</li>
<li>故障自动转移（Automatic failover）：当一个主服务器出现故障不能正常工作时，Sentinel会在所有从服务器中选择一个作为新的主服务器，实现故障自动转移。</li>
<li>提供主服务器地址：能够向当前使用者提供当前主节点的地址，特别是在故障自动转移后，使用者不用做任何修改就可以知道当前的主节点地址。</li>
<li>sentinel也可以集群，部署多个哨兵，sentinel可以通过发布和订阅(pub/sub)来自动发现Redis集群上的其他Sentinel。sentinel在发现其它sentinel进程后，会将其放入一个列表中，这个列表存储了所有已被发现的sentinel。</li>
</ul>
<blockquote>
<p>Redis哨兵模式的优点：</p>
</blockquote>
<ul>
<li>保证高可用</li>
<li>监控各个节点</li>
<li>自动故障迁移</li>
</ul>
<blockquote>
<p>Redis哨兵模式的缺点：</p>
</blockquote>
<ul>
<li>切换需要时间，可能存在丢失数据风险</li>
<li>从节点下线，故障不能自动转移</li>
<li>无法实现动态扩容</li>
</ul>
<h3 id="4-集群模式"><a href="#4-集群模式" class="headerlink" title="(4) 集群模式"></a>(4) 集群模式</h3><p><strong><a href="http://www.redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">Redis 集群</a></strong></p>
<blockquote>
<p>Redis 集群是一个提供在多个Redis间节点间共享数据的程序集。Redis集群并不支持处理多个keys的命令，因为这需要在不同的节点间移动数据，从而达不到像Redis那样的性能，在高负载的情况下可能会导致不可预料的错误。</p>
</blockquote>
<blockquote>
<p>Redis 集群通过分区来提供一定程度的可用性，在实际环境中当某个节点宕机或者不可达的情况下继续处理命令。</p>
</blockquote>
<blockquote>
<p>Redis 集群没有使用一致性hash, 而是引入了 哈希槽的概念。Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽。集群的每个节点负责一部分hash槽，比如当前集群有3个节点，那么节点 A 包含 0 到 5500号哈希槽；节点 B 包含5501 到 11000 号哈希槽；节点 C 包含11001 到 16384号哈希槽；这种结构很容易添加或者删除节点，比如如果我想新添加个节点D，我需要从节点 A, B, C中得部分槽到D上。如果我想移除节点A，需要将A中的槽移到B和C节点上，然后将没有任何槽的A节点从集群中移除即可。由于从一个节点将哈希槽移动到另一个节点并不会停止服务，所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态。</p>
</blockquote>
<blockquote>
<p>一致哈希算法根据数据的key值计算映射位置时和所使用的节点数量有非常大的关系。一致哈希分区的实现思路是为系统中每个节点分配一个token，范围一般在0~2^32，这些token构成一个哈希环，数据读写执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于等于该hash值的token节点，需要操作的数据就保存在该节点上。</p>
</blockquote>
<blockquote>
<p>Redis 一致性保证 Redis 并不能保证数据的强一致性。这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
</blockquote>
<blockquote>
<p>投票过程是集群中所有master参与，如果半数以上master节点与master节点通信超时(cluster-node-timeout)，认为当前master节点挂掉。这时如果当前master没有slave，集群就进入fail状态；当集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态。</p>
</blockquote>
<blockquote>
<p>一般集群建议搭建三主三从架构，三主提供服务，三从提供备份功能。</p>
</blockquote>
<blockquote>
<p>Redis集群模式的优点：</p>
</blockquote>
<ul>
<li>有效解决了Redis在分布式方面的需求</li>
<li>遇到单击内存，并发和流量瓶颈问题时，可采用Cluster方案达到负载均衡的目的</li>
<li>可实现动态扩容，可线性扩展到1000个节点，节点可以动态的添加或删除</li>
<li>P2P模式，无中心化</li>
<li>自动故障转移，节点间通过Gossip协议同步节点信息，用投票机制完成slave到maser的角色提升</li>
<li>数据按照Slot存储分布在多个节点，节点间数据共享，可动态调整数据分布。</li>
<li>高可用性，部分节点不可用时，集群仍然可用，通过增加slave做备份数据副本</li>
</ul>
<blockquote>
<p>Redis集群模式的缺点：</p>
</blockquote>
<ul>
<li>架构比较新，最佳时间比较少</li>
<li>为了性能提升，客户端需要缓存路由表信息</li>
<li>节点发现、reshard操作不够自动化</li>
</ul>
<h2 id="9-Redis如何实现分布式锁"><a href="#9-Redis如何实现分布式锁" class="headerlink" title="9. Redis如何实现分布式锁"></a>9. Redis如何实现分布式锁</h2><blockquote>
<p>使用 setnx 实现枷锁，可以同时通过 expire 添加超时时间</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当key不存在时，为key设置一个值，否则在一定时间内进行尝试</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire_lock</span><span class="params">(conn, lockname, acquire_timeout=<span class="number">10</span>)</span>:</span></span><br><span class="line">    identifier = str(uuid.uuid4())</span><br><span class="line">    end = time.time() + acquire_timeout</span><br><span class="line">    <span class="keyword">while</span> time.time() &lt; end:</span><br><span class="line">        <span class="keyword">if</span> conn.setnx(<span class="string">'lock:'</span> + lockname, identifier):</span><br><span class="line">            <span class="keyword">return</span> identifier</span><br><span class="line">        time.sleep(<span class="number">0.001</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>锁的 value 值可以使用一个随机的 uuid 或者特定的命名</p>
</blockquote>
<blockquote>
<p>释放锁的时候，通过 uuid 判断是否是该锁，是则执行 delete 释放锁</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">release_lock</span><span class="params">(conn, lockname,identifier)</span>:</span></span><br><span class="line">    pipe = conn.pipeline(<span class="literal">True</span>)</span><br><span class="line">    lockname = <span class="string">'lock:'</span> + lockname</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pipe.watch(lockname)</span><br><span class="line">            <span class="keyword">if</span> pipe.get(lockname) == identifier:</span><br><span class="line">                pipe.multi()</span><br><span class="line">                pipe.delete(lockname)</span><br><span class="line">                pipe.execute()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            pipe.unwatch()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.WatcjError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="10-缓存使用场景"><a href="#10-缓存使用场景" class="headerlink" title="10. 缓存使用场景"></a>10. 缓存使用场景</h2><blockquote>
<p>缓解关系数据库并发访问的压力： 热点数据</p>
</blockquote>
<blockquote>
<p>减少响应时间：内存IO速度比磁盘快</p>
</blockquote>
<blockquote>
<p>提升吞吐量：redis等内存数据库单机就可以支撑很大并发</p>
</blockquote>
<h2 id="11-常用的缓存使用模式"><a href="#11-常用的缓存使用模式" class="headerlink" title="11. 常用的缓存使用模式"></a>11. 常用的缓存使用模式</h2><ul>
<li>Cache-Aside</li>
</ul>
<blockquote>
<p>Cache-Aside可能是项目中最常见的一种模式。它是一种控制逻辑都实现在应用程序中的模式。缓存不和数据库直接进行交互，而是由应用程序来同时和缓存以及数据库打交道，即同时更新缓存和数据库。</p>
</blockquote>
<blockquote>
<p>应用场景：应用于缓存不支持Read-Through/Write-Through的系统。</p>
</blockquote>
<blockquote>
<p>优点：缓存仅仅保存被请求的数据，属于懒加载模式，避免了任何数据都被写入缓存造成缓存频繁的更新。</p>
</blockquote>
<blockquote>
<p>缺点：当发生缓存未命中的情况时，则会比较慢，因为要经过三个步骤，查询缓存、从数据库读取、写入缓存；复杂的逻辑都在应用程序中，如果实现微服务，多个微服务中会有重复的逻辑代码。</p>
</blockquote>
<ul>
<li>Read-Through / Write Through</li>
</ul>
<blockquote>
<p>这种模式中，应用程序将缓存作为主要的数据源，而数据库对于应用程序是透明的，更新数据库和从数据库的读取的任务都交给缓存来代理了，所以对于应用程序来说，简单很多。先更新缓存，缓存负责同步更新数据库。</p>
</blockquote>
<blockquote>
<p>应用场景：写入之后经常被读取的应用。</p>
</blockquote>
<blockquote>
<p>优点：缓存不存在脏数据；相比较Cache-Aside懒加载模式，读取速度更高，因为较少因为缓存未命中而从数据库中查找；应用程序的逻辑相对简单。</p>
</blockquote>
<blockquote>
<p>缺点：对于总是写入却很少被读取的应用，那么Write-Through会非常浪费性能，因为数据可能更改了很多次，却没有被读取，白白的每次都写入缓存造成写入延迟。</p>
</blockquote>
<ul>
<li>Write-Back</li>
</ul>
<blockquote>
<p>又叫做Write-Behind，和Write-Through写入的时机不同，Write-Back将缓存作为可靠的数据源，每次都只写入缓存，而写入数据库则采用异步的方式，比如当数据要被移除出缓存的时候再存储到数据库或者一段时间之后批量更新数据库。即先更新缓存，缓存定期异步更新数据库。</p>
</blockquote>
<blockquote>
<p>应用场景：读写效率都非常好，写的时候因为异步存储到数据库，提升了写的效率，适用于读写密集的应用。</p>
</blockquote>
<blockquote>
<p>优点：写入和读取数据都非常的快，因为都是从缓存中直接读取和写入；对于数据库不可用的情况有一定的容忍度，即使数据库暂时不可用，系统也整体可用，当数据库之后恢复的时候，再将数据写入数据库。</p>
</blockquote>
<blockquote>
<p>缺点：有数据丢失的风险，如果缓存挂掉而数据没有及时写到数据库中，那么缓存中的有些数据将永久的丢失了。</p>
</blockquote>
<ul>
<li>Write-Around</li>
</ul>
<blockquote>
<p>和Write-Through不同，更新的时候只写入数据库，不写入缓存，结合Read-Through或者Cache-Aside使用，只在缓存未命中的情况下写缓存。</p>
</blockquote>
<blockquote>
<p>应用场景：适合于只写入一次而很少被读取的应用。</p>
</blockquote>
<blockquote>
<p>优点：相比较Write-Through写入的时候的效率较高，如果数据写入后很少被读取，缓存也不会被没用到的数据占满。</p>
</blockquote>
<blockquote>
<p>缺点：如果数据会写入多次，那么可能存在缓存和数据库不一致</p>
</blockquote>
<h2 id="12-什么是缓存穿透"><a href="#12-什么是缓存穿透" class="headerlink" title="12. 什么是缓存穿透"></a>12. 什么是缓存穿透</h2><blockquote>
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
</blockquote>
<blockquote>
<p>解决：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存；对一定不存在的key进行过滤，可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。</p>
</blockquote>
<h2 id="13-什么是缓存击穿"><a href="#13-什么是缓存击穿" class="headerlink" title="13. 什么是缓存击穿"></a>13. 什么是缓存击穿</h2><blockquote>
<p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期，热点数据key失效），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</p>
</blockquote>
<blockquote>
<p>解决：设置热点数据永远不过期；分布式锁；异步后台更新，后台任务针对过期的key自动刷新。</p>
</blockquote>
<h2 id="14-什么是缓存雪崩"><a href="#14-什么是缓存雪崩" class="headerlink" title="14. 什么是缓存雪崩"></a>14. 什么是缓存雪崩</h2><blockquote>
<p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力，导致系统崩溃。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
</blockquote>
<blockquote>
<p>解决：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量，比如对某个key只允许一个线程查询数据和写缓存，其他线程等待；做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期；不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
</blockquote>
<blockquote>
<p>架构层面解决： 提升系统可用性， 监控、报警完善</p>
</blockquote>
<h2 id="15-连接Redis"><a href="#15-连接Redis" class="headerlink" title="15. 连接Redis"></a>15. 连接Redis</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># StrictRedis方式</span></span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis</span><br><span class="line">redis = StrictRedis(host=<span class="string">'localhost'</span>, prot=<span class="number">6379</span>, db=<span class="string">'test'</span>, password=<span class="string">'123456'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个字符串值</span></span><br><span class="line">redis.set(<span class="string">'name'</span>, <span class="string">'Bob'</span>)</span><br><span class="line">print(redis.get(<span class="string">'name'</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">b'Bob'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ConnectionPool连接方式</span></span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis, ConnectionPool</span><br><span class="line">pool = ConnectionPool(host=<span class="string">'localhost'</span>, port=<span class="number">63799</span>, db=<span class="string">'test'</span>, password=<span class="string">'123456'</span>)</span><br><span class="line">redis = StrictRedis(connection_pool=pool)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ConnectionPool支持通过URL来构建</span></span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis, ConnectionPool</span><br><span class="line">url = <span class="string">'redis://:123456@localhost:6379/test'</span></span><br><span class="line">pool = ConnectionPool.from_url(url)</span><br><span class="line">redis = StrictRedis(connect_pool=pool)</span><br></pre></td></tr></table></figure>

<h2 id="16-Redis异步队列"><a href="#16-Redis异步队列" class="headerlink" title="16. Redis异步队列"></a>16. Redis异步队列</h2><blockquote>
<p>一般使用list结构作为队列，rpush生产消息，lpop消费消息，当lpop没有消息的时候，要适当sleep一会再重试。</p>
</blockquote>
<blockquote>
<p>缺点：在消费者下线的情况，生产者的消息会丢失，得使用专业的消息队列如Rabbitmq。</p>
</blockquote>
<h2 id="17-生产一次消费多次"><a href="#17-生产一次消费多次" class="headerlink" title="17. 生产一次消费多次"></a>17. 生产一次消费多次</h2><blockquote>
<p>使用pub/sub主题订阅者模式，可以实现1：N的消息队列。</p>
</blockquote>
<h2 id="18-Redis分区"><a href="#18-Redis分区" class="headerlink" title="18. Redis分区"></a>18. Redis分区</h2><blockquote>
<p>分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。</p>
</blockquote>
<blockquote>
<p>分区的优势：</p>
</blockquote>
<ul>
<li>通过利用多台计算机内存的和值，允许我们构造更大的数据库。</li>
<li>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。</li>
</ul>
<blockquote>
<p>分区的不足：</p>
</blockquote>
<ul>
<li>涉及多个key的操作通常是不被支持的，如当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。</li>
<li>涉及多个key的redis事务不能使用。</li>
<li>当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。</li>
<li>增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。</li>
</ul>
<blockquote>
<p>分区类型：</p>
</blockquote>
<ul>
<li>范围分区：最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。</li>
<li>哈希分区：另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name: 这种形式。</li>
</ul>
<h1 id="MongoDB数据库"><a href="#MongoDB数据库" class="headerlink" title="MongoDB数据库"></a>MongoDB数据库</h1><h2 id="1-MongoDB常用的操作"><a href="#1-MongoDB常用的操作" class="headerlink" title="1. MongoDB常用的操作"></a>1. MongoDB常用的操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">'localhost'</span>, port=<span class="number">27017</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定数据库test</span></span><br><span class="line">db = client.test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定集合</span></span><br><span class="line">collection = db.students</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line">student1 = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20180101'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'zhangsan'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line">student2 = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20180102'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'lisi'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line">result = collection.insert([student1, student2])</span><br><span class="line">result = collection.insert_one(student1)</span><br><span class="line">result = collection.insert_many([student1, student2])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询</span></span><br><span class="line">result = collection.find_one(&#123;<span class="string">'name'</span>: <span class="string">'zhangsan'</span>&#125;)</span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> results:</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 年龄小于20的数据</span></span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$lt'</span>: <span class="number">20</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 年龄小于等于20的数据</span></span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$lte'</span>: <span class="number">20</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 年龄大于20的数据</span></span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$gt'</span>: <span class="number">20</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 年龄大于等于20的数据</span></span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$gte'</span>: <span class="number">20</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 年龄不等于20的数据</span></span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$ne'</span>: <span class="number">20</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 年龄在[18, 25]范围内的数据</span></span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$in'</span>: [<span class="number">18</span>,<span class="number">23</span>]&#125;&#125;)</span><br><span class="line"><span class="comment"># 年龄不在[18, 25]范围内的数据</span></span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$nin'</span>: [<span class="number">18</span>,<span class="number">23</span>]&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则查询，匹配以M开头的数据</span></span><br><span class="line">results = collection.find(&#123;<span class="string">'name'</span>: &#123;<span class="string">'$regex'</span>: <span class="string">'^M.*'</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计数</span></span><br><span class="line">num = collection.find(&#123;<span class="string">'age'</span>: <span class="number">20</span>&#125;).count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据字段，升序ASCENDING/降序DESCENDING</span></span><br><span class="line">results = collection.find().sort(<span class="string">'name'</span>, pymongo.ASCENDING)</span><br><span class="line">print(result[<span class="string">'name'</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 偏移位置，skip(n)忽略前n个元素</span></span><br><span class="line">results = collection.find().sort(<span class="string">'name'</span>, pymongo.ASCENDING).skip(<span class="number">2</span>)</span><br><span class="line">print(result[<span class="string">'name'</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制返回结果个数limit(n)，从左到右</span></span><br><span class="line">results = collection.find().sort(<span class="string">'name'</span>, pymongo.ASCENDING).limit(<span class="number">2</span>)</span><br><span class="line">print(result[<span class="string">'name'</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新update()</span></span><br><span class="line">condition = &#123;<span class="string">'name'</span>: <span class="string">'wangwu'</span>&#125;</span><br><span class="line">student = collection.find_one(condition)</span><br><span class="line">student[<span class="string">'age'</span>] = <span class="number">25</span></span><br><span class="line">result = collection.update(condition, student)</span><br><span class="line"></span><br><span class="line"><span class="comment"># $set操作符只更新student字典内存在的字段，其他字段不更新也不删除</span></span><br><span class="line">result = collection.update(condition, &#123;<span class="string">'$set'</span>: student&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># update_one()</span></span><br><span class="line">result = collection.update_one(condition, &#123;<span class="string">'$set'</span>: student&#125;)</span><br><span class="line"><span class="comment"># 查看获得匹配的数据条数和影响的数据条数</span></span><br><span class="line">print(result.matched_count, result.modified_count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># update_many()</span></span><br><span class="line">condition = &#123;<span class="string">'age'</span>: &#123;<span class="string">'$gt'</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line">result = collection.update_many(condition, &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'age'</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment"># 查看获得匹配的数据条数和影响的数据条数</span></span><br><span class="line">print(result.matched_count, result.modified_count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">result = collection.remove(&#123;<span class="string">'name'</span>: <span class="string">'zhangsan'</span>&#125;)</span><br><span class="line">result = collection.delete_one(&#123;<span class="string">'name'</span>: <span class="string">'zhangsan'</span>&#125;)</span><br><span class="line">result = collection.delete_many(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$lt'</span>: <span class="number">20</span>&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Elasticsearch数据库"><a href="#Elasticsearch数据库" class="headerlink" title="Elasticsearch数据库"></a>Elasticsearch数据库</h1><h2 id="1-索引如何存储"><a href="#1-索引如何存储" class="headerlink" title="1. 索引如何存储"></a>1. 索引如何存储</h2><h2 id="2-介绍下Elastisearch原理和用途"><a href="#2-介绍下Elastisearch原理和用途" class="headerlink" title="2. 介绍下Elastisearch原理和用途"></a>2. 介绍下Elastisearch原理和用途</h2><h2 id="3-分布式实时日志使用ELK"><a href="#3-分布式实时日志使用ELK" class="headerlink" title="3. 分布式实时日志使用ELK"></a>3. 分布式实时日志使用ELK</h2><h1 id="Hive数据库"><a href="#Hive数据库" class="headerlink" title="Hive数据库"></a>Hive数据库</h1><h1 id="Hbase数据库"><a href="#Hbase数据库" class="headerlink" title="Hbase数据库"></a>Hbase数据库</h1><h1 id="Hadoop生态"><a href="#Hadoop生态" class="headerlink" title="Hadoop生态"></a>Hadoop生态</h1>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>Copyright： </strong>
              Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://yoursite.com/2020/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mysql/" rel="tag">Mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/05/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            操作系统知识点总结归纳
          
        </div>
      </a>
    
    
      <a href="/2020/05/08/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">网络知识点总结归纳</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'monsterid',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2019-2020
        <i class="ri-heart-fill heart_icon"></i> holysll
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/logo.svg" alt="holysll"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/null">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Subtitle -->

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['此岸流水，彼岸花开', '半生已过，学会沉默，凡事先讨好自己，至于别人，分心情，谈交情！', '认真且怂，从一而终；不畏将来，不念过去！'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
    console.log(err)
  }
</script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>



    
  </div>
</body>

</html>