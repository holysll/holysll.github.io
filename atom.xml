<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>holysll</title>
  
  <subtitle>彼岸花开</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-12T16:37:29.045Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>holysll</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo使用教程与常用命令</title>
    <link href="http://yoursite.com/2020/05/12/Hexo%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/05/12/Hexo%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2020-05-12T15:34:02.000Z</published>
    <updated>2020-05-12T16:37:29.045Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎使用<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! 更多信息可以查看<a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo官方文档</a> 。如果你在使用过程中遇到任何问题，可以在这<a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">提问</a> 或者在<a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a> 上留言，这篇文章简单介绍下Hexo的使用以及常用的命令。</p><a id="more"></a><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><h3 id="创建一篇文章"><a href="#创建一篇文章" class="headerlink" title="创建一篇文章"></a>创建一篇文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"文章标题"</span></span><br><span class="line">或者</span><br><span class="line">$ hexo n <span class="string">"文章标题"</span></span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">writing</a></p><h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">或者</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">或者</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="部署到远端"><a href="#部署到远端" class="headerlink" title="部署到远端"></a>部署到远端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">或者</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>更多信息:: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><h2 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h2><h3 id="获取主题"><a href="#获取主题" class="headerlink" title="获取主题"></a>获取主题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/holysll/hexo-theme-ayer</span><br></pre></td></tr></table></figure><h3 id="修改主题配置"><a href="#修改主题配置" class="headerlink" title="修改主题配置"></a>修改主题配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">vi _config.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: hexo-theme-ayer</span><br></pre></td></tr></table></figure><h3 id="清除缓存并部署"><a href="#清除缓存并部署" class="headerlink" title="清除缓存并部署"></a>清除缓存并部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎使用&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! 更多信息可以查看&lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo官方文档&lt;/a&gt; 。如果你在使用过程中遇到任何问题，可以在这&lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;提问&lt;/a&gt; 或者在&lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt; 上留言，这篇文章简单介绍下Hexo的使用以及常用的命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="个人博客" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Python语言知识点总结归纳</title>
    <link href="http://yoursite.com/2020/05/12/Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/05/12/Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</id>
    <published>2020-05-11T17:22:53.287Z</published>
    <updated>2020-06-03T14:25:23.375Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要对python语言基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。</p></blockquote><a id="more"></a><div style='display: none'><!-- TOC --><ul><li><a href="#1-python语言的特性">1. Python语言的特性</a></li><li><a href="#2-python语言相比其他语言的优点和缺点">2. python语言相比其他语言的优点和缺点</a></li><li><a href="#3-python中的元类metaclass">3. python中的元类metaclass</a></li><li><a href="#4-staticmethod和classmethod和实例方法">4. @staticmethod和@classmethod和实例方法</a></li><li><a href="#5-单例模式">5. 单例模式</a></li><li><a href="#6-python常用库">6. python常用库</a></li><li><a href="#7-python中的类型转换">7. python中的类型转换</a></li><li><a href="#8-文件流操作">8. 文件流操作</a></li><li><a href="#9-__new__-和-__init__的区别">9. <strong>new</strong> 和 <strong>init</strong>的区别</a></li><li><a href="#10-python内存管理与垃圾回收机制">10. python内存管理与垃圾回收机制</a></li><li><a href="#11-python2x-与python3x的主要区别">11. python2.x 与python3.x的主要区别</a></li><li><a href="#12-如何将python2的代码迁移到python3">12. 如何将python2的代码迁移到python3</a></li><li><a href="#13-python新式类和旧式类的区别">13. python新式类和旧式类的区别</a></li><li><a href="#14-鸭子类型">14. 鸭子类型</a></li><li><a href="#15-python自省">15. python自省</a></li><li><a href="#16-猴子补丁技术">16. 猴子补丁技术</a></li><li><a href="#17-python语法糖有哪些">17. python语法糖有哪些</a></li><li><a href="#18-迭代器和生成器">18. 迭代器和生成器</a></li><li><a href="#19-闭包">19. 闭包</a></li><li><a href="#20-装饰器">20. 装饰器</a></li><li><a href="#21-浅拷贝与深拷贝">21. 浅拷贝与深拷贝</a></li><li><a href="#22-设计模式">22. 设计模式</a></li><li><a href="#23-gil全局解释器锁">23. GIL全局解释器锁</a></li><li><a href="#24-函数是一等公民">24. 函数是一等公民？</a></li><li><a href="#25-函数与方法的区别">25. 函数与方法的区别</a></li><li><a href="#26-range与xrange的区别">26. range与Xrange的区别</a></li><li><a href="#27-search与match的区别">27. search与match的区别</a></li><li><a href="#28-面向对象编程oop">28. 面向对象编程OOP</a></li><li><a href="#29-面向切面编程aop">29. 面向切面编程AOP</a></li><li><a href="#30-封装">30. 封装</a></li><li><a href="#31-继承">31. 继承</a></li><li><a href="#32-多态与多态性">32. 多态与多态性</a></li><li><a href="#33-重载">33. 重载</a></li><li><a href="#34-函数式编程">34. 函数式编程</a></li><li><a href="#35-python中的高阶函数">35. python中的高阶函数</a></li><li><a href="#36-返回函数">36. 返回函数</a></li><li><a href="#37-匿名函数">37. 匿名函数</a></li><li><a href="#38-偏函数">38. 偏函数</a></li><li><a href="#39-元编程">39. 元编程</a></li><li><a href="#40-捕获异常">40. 捕获异常</a></li><li><a href="#41-python常见的内置数据结构">41. python常见的内置数据结构</a></li><li><a href="#42-python-新增内置数据结构--bytesbytearray">42. python 新增内置数据结构–bytes、bytearray</a></li><li><a href="#43-空">43. 空</a></li><li><a href="#44-python中参数类型有哪些">44. python中参数类型有哪些</a></li><li><a href="#45-python中函数传参过程">45. python中函数传参过程</a></li><li><a href="#46-args和kwargs">46. <em>args和*</em>kwargs</a></li><li><a href="#47-实参和形参的区别">47. 实参和形参的区别</a></li><li><a href="#48-python中可变对象和不可变对象">48. python中可变对象和不可变对象</a></li><li><a href="#49-python中正则使用方式">49. python中正则使用方式</a></li><li><a href="#50-numpy与scipy的区别">50. Numpy与Scipy的区别</a></li><li><a href="#51-python中反射机制">51. python中反射机制</a></li><li><a href="#52-python中如何管理依赖">52. python中如何管理依赖</a></li><li><a href="#53-如何分析python代码性能">53. 如何分析python代码性能</a></li><li><a href="#54-列表的线性访问和随机访问">54. 列表的线性访问和随机访问</a></li><li><a href="#55-python中单下划线和双下划线">55. Python中单下划线和双下划线</a></li><li><a href="#56-python的作用域以及python搜索变量的顺序">56. Python的作用域以及Python搜索变量的顺序</a></li><li><a href="#57-编码与解码">57. 编码与解码</a></li><li><a href="#58-字符串格式化">58. 字符串格式化</a></li><li><a href="#59-增量赋值">59. 增量赋值</a></li><li><a href="#60-字典推导式">60. 字典推导式</a></li><li><a href="#61-exec对字符串执行和eval对字符串求值">61. exec对字符串执行和eval对字符串求值</a></li><li><a href="#62-raise语句的作用">62. raise语句的作用</a></li><li><a href="#63-yeild语句的作用">63. yeild语句的作用</a></li><li><a href="#64-socket编程">64. socket编程</a></li><li><a href="#65-urllib和urllib2">65. urllib和urllib2</a></li><li><a href="#66-requests">66. requests</a></li><li><a href="#67-beautiful-soup">67. Beautiful Soup</a></li><li><a href="#68-selectpoll和epoll">68. select,poll和epoll</a></li><li><a href="#69-python中实现io多路复用">69. python中实现IO多路复用</a></li><li><a href="#68-python常用的并发网络库">68. python常用的并发网络库</a></li><li><a href="#70-python-decimal精确计算">70. python decimal精确计算</a></li></ul><!-- /TOC --></div><h2 id="1-Python语言的特性"><a href="#1-Python语言的特性" class="headerlink" title="1. Python语言的特性"></a>1. Python语言的特性</h2><p>   Python是一种解释型语言，不需要再运行之前进行编译。<br>   Python是一种动态类型语言，不需要声明变量的类型。<br>   python适合面向对象编程，允许类的定义以及组合和继承。  </p><h2 id="2-python语言相比其他语言的优点和缺点"><a href="#2-python语言相比其他语言的优点和缺点" class="headerlink" title="2. python语言相比其他语言的优点和缺点"></a>2. python语言相比其他语言的优点和缺点</h2><p><strong>优点</strong></p><ul><li>简单易懂，灵活简洁</li><li>强大的标准库和三方库</li><li>活跃的社区，许多开源项目</li><li>开发效率高，迭代便捷</li><li>应用领域广泛，Web开发、网络编程、自动化运维、Linux系统管理、数据分析、科学计算、人工智能、机器学习</li></ul><p><strong>缺点</strong></p><ul><li>执行效率较差,</li><li>异步生态不完善，相关的库较少(tornado)</li><li>GIL的存在，无法充分利用多核的特性</li></ul><h2 id="3-python中的元类metaclass"><a href="#3-python中的元类metaclass" class="headerlink" title="3. python中的元类metaclass"></a>3. python中的元类metaclass</h2><blockquote><p>不会很常用，在ORM这种复杂结构中晦遇到，同时在看一些框架源代码的过程中可能会遇到很多元类的实例，看起来很晦涩。推荐<a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python" target="_blank" rel="noopener">Stack overflow</a> 一些专业解答，也可以参考下<a href="https://www.cnblogs.com/tkqasn/p/6524879.html" target="_blank" rel="noopener">这篇博客</a>的深刻理解，很详细。</p></blockquote><ul><li><strong>str是用来创建字符串对象的类</strong></li><li><strong>int是用来创建整数对象的类</strong></li><li><strong>type就是创建类对象的类</strong></li></ul><blockquote><p>通过type函数动态创建类</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># type的语法</span></span><br><span class="line">type(class_name, class_parents, class_attr_dict)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    class_name: 类名</span></span><br><span class="line"><span class="string">    class_parents: 父类的元组(针对集成的情况，可为空)</span></span><br><span class="line"><span class="string">    class_attr_dict: 包函属性的字典</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    MyClass = type(<span class="string">'MyClass'</span>, (), &#123;<span class="string">'foo'</span>:<span class="literal">True</span>&#125;)</span><br></pre></td></tr></table></figure><p><strong>元类：就是能够创建python中类这种对象的东西，如type就是Python的内建元类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass = MetaClass()  <span class="comment"># 元类的创建</span></span><br><span class="line">my_class = MyClass()  <span class="comment"># 类的实例</span></span><br></pre></td></tr></table></figure><blockquote><p>实际上Myclass就是通过type()来创建出的MyClass类，它是type()类的一个实例。<br>同时，MyClass本身也是累，也可以创建自己的实例my_class。</p></blockquote><ul><li><strong><strong>metaclass</strong></strong></li></ul><blockquote><p>可以再写一个类的时候为其添加<strong>metaclass</strong>属性，这样就定义了这个类的元类。<strong>metaclass</strong>实际上可以被任意调用，它并不需要是一个正式的类。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># py2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = something</span><br><span class="line"></span><br><span class="line"><span class="comment"># py3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(metaclass=something)</span>:</span></span><br><span class="line">    __metaclass__ = something</span><br></pre></td></tr></table></figure><ul><li><strong>自定义元类</strong></li></ul><blockquote><p>元类的主要目的为了当创建类时能够自动改变类，通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。</p></blockquote><ul><li>可以使用函数当做元类</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元类通常会将你传给type的参数作为自己的参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upper_attr</span><span class="params">(future_class_name, future_class_parents, future_class_attr)</span>:</span></span><br><span class="line">    <span class="string">"""返回一个类对象，将属性都转为大写形式"""</span></span><br><span class="line">    <span class="comment"># 选择所有不以'__'开头的属性</span></span><br><span class="line">    attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> future_class_attr.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>))</span><br><span class="line">    <span class="comment"># 将他们转化为大写形式</span></span><br><span class="line">    uppercase_attr = dict&#123;(name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs&#125;</span><br><span class="line">    <span class="comment"># 通过type来做类对象的创建</span></span><br><span class="line">    <span class="keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)  <span class="comment"># 返回一个对象，这个对象是个类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(metaclass=upper_attr)</span>:</span></span><br><span class="line">    _metaclass__ = upper_attr</span><br><span class="line">    bar = <span class="string">'bip'</span></span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, <span class="string">'bar'</span>))  <span class="comment"># False</span></span><br><span class="line">print(hasattr(Foo, <span class="string">'BAR'</span>))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line">print(f.BAR)  <span class="comment"># 'bip'</span></span><br></pre></td></tr></table></figure><ul><li>可以使用class来当做元类</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaClass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr)</span>:</span></span><br><span class="line">        attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> future_class_attr.items() <span class="keyword">if</span> <span class="keyword">not</span> name.starswith(<span class="string">'__'</span>))</span><br><span class="line">        uppercase_attr = dict((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 复用type.__new__方法，OOP编程。</span></span><br><span class="line">    <span class="comment"># 由于type是元类也是类，本身也是通过__new__方法生成实例，只不过这个实例是一个类。</span></span><br><span class="line">    <span class="keyword">return</span> tpye.__new__(upperattr_metaclass, future_classs_name, future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure><ul><li><strong>真实业务场景下的元类</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaClass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, dct)</span>:</span></span><br><span class="line">        attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> dct.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>))</span><br><span class="line">        uppercase_attr = dict((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, uppercase_attr)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># supper继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaClass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, dct)</span>:</span></span><br><span class="line">        attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> dct.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>))</span><br><span class="line">        uppercase_attr = dict((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line">        <span class="keyword">return</span> supper(UpperAttrMetaClass, cls).__new__(cls, name, bases, uppercase_attr)</span><br></pre></td></tr></table></figure><ul><li><strong>使用元类创建ORM实例</strong></li></ul><blockquote><p>熟悉Django框架的，应该知道ORM结构，元类创建API，使得调用简洁明了。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 1.定义Field类，用于保存数据表的字段名和字段类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, column_type)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.column_type = column_type</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;%s:%s&gt;'</span> % (self.__class__.__name__, self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringField</span><span class="params">(Field)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super().__init__(name, <span class="string">'varchar(100)'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerField</span><span class="params">(Field)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super().__init__(name, <span class="string">'bigint'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义元类，控制Model对象的创建</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelMetaClass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""定义元类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">'Model'</span>:</span><br><span class="line">            <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line">        print(<span class="string">'Found model: %s'</span> % name)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 排除掉对Model类的修改</span></span><br><span class="line">        mappings = dict()</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():</span><br><span class="line">            <span class="comment"># 保存类属性和列的映射关系到mappings字典</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(v, Field):</span><br><span class="line">              print(<span class="string">'Found mapping: %s==&gt;%s'</span> % (k, v)</span><br><span class="line">              mappings[k] = v</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():</span><br><span class="line">            <span class="comment"># 将类属性移除，是定义的类字段不污染User类属性，只在实例中可以访问这些key</span></span><br><span class="line">            attrs.pop(k)</span><br><span class="line">        <span class="comment"># 假设表名为类名的小写，创建类时添加一个__table__类属性</span></span><br><span class="line">        attrs[<span class="string">'__table__'</span>] = name.lower()</span><br><span class="line">        <span class="comment"># 保存属性和列的映射关系，创建类时添加一个__mappings__类属性</span></span><br><span class="line">        attrs[<span class="string">'__mappings__'</span>] = mappings</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写Model基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(dict, metaclass= ModelMetaClass)</span>:</span></span><br><span class="line">    <span class="string">"""只是简单实现了INSERT功能"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kw)</span>:</span></span><br><span class="line">        super(Model, self).__init__(**kw)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">r"'Model' object has no attribute '%s'"</span> % key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self)</span>:</span></span><br><span class="line">        fields = []</span><br><span class="line">        params = []</span><br><span class="line">        args = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__mappings__.items():</span><br><span class="line">            fields.append(v.name)</span><br><span class="line">            params.append(<span class="string">'?'</span>)</span><br><span class="line">            args.append(getattr(self, k, <span class="literal">None</span>))</span><br><span class="line">        sql = <span class="string">'insert into %s (%s) values (%s)'</span> % (self.__table__, <span class="string">','</span>.join(fields), <span class="string">','</span>.join(params))</span><br><span class="line">        print(<span class="string">'SQL: %s'</span> % sql)</span><br><span class="line">        print(<span class="string">'ARGS: %s'</span> % str(args))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个model，用户表User，定义数据字段就可实现数据表和字段的操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Model)</span>：</span></span><br><span class="line">    id = IntegerField('id')  # 对应数据表的id字段</span><br><span class="line">    name = StringField(<span class="string">'username'</span>)  <span class="comment"># 对应数据表的username字段</span></span><br><span class="line">    email = StringField(<span class="string">'email'</span>)  <span class="comment"># 对应数据表的email字段</span></span><br><span class="line">    password = StringField(<span class="string">'password'</span>)  <span class="comment"># 对应数据表的password字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个实例</span></span><br><span class="line">user = User(id=<span class="number">123456</span>, name=<span class="string">'Michael'</span>, email=<span class="string">'test@163.com'</span>, password=<span class="string">'123456'</span>)</span><br><span class="line"><span class="comment"># 保存数据库</span></span><br><span class="line">user.save()</span><br></pre></td></tr></table></figure><h2 id="4-staticmethod和-classmethod和实例方法"><a href="#4-staticmethod和-classmethod和实例方法" class="headerlink" title="4. @staticmethod和@classmethod和实例方法"></a>4. @staticmethod和@classmethod和实例方法</h2><blockquote><p><strong><a href="https://stackoverflow.com/questions/136097/difference-between-staticmethod-and-classmethod" target="_blank" rel="noopener">what-is-the-difference-between-staticmethod-and-classmethod-in-python</a></strong></p></blockquote><blockquote><p><strong><a href="https://realpython.com/instance-class-and-static-methods-demystified/" target="_blank" rel="noopener">real python上详细知识</a></strong></p></blockquote><ul><li><strong>静态方法</strong></li></ul><blockquote><p>静态方法：其实和普通的方法一样，不需要对谁进行绑定，必须有@staticmethod修饰，类和实例都可以访问静态方法，调用方式A。static_foo(x)和a.static_foo(x)。</p></blockquote><ul><li><strong>类方法</strong></li></ul><blockquote><p>类方法：即在类里定义的函数方法，需要@classmethod修饰，并且有个隐藏参数cls，传递的是类而不是实例，类可以访问类方法，也可以访问实例方法，访问实例方法时必须带参数self。</p></blockquote><ul><li><strong>实例方法</strong></li></ul><blockquote><p>实例方法的调用离不开实例，必须有个参数self，把实例自己传给函数，调用是够是a.foo(x)与foo(a, x)等价。实例可以访问实例方法，也可以访问类方法。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>：</span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"executing foo(%s)"</span> % <span class="params">(x)</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(<span class="string">"executing foo(%s, %s)"</span> % (self, x))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span><span class="params">(cls, x)</span>:</span></span><br><span class="line">      print(<span class="string">"executing foo(%s, %s)"</span> % (cls, x)<span class="string">")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # 静态方法</span></span><br><span class="line"><span class="string">    @staticmethod</span></span><br><span class="line"><span class="string">    def static_foo(x):</span></span><br><span class="line"><span class="string">      print("</span>executing foo(%s)<span class="string">" % x)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">a = A()</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">实例/类</th><th align="center">实例方法</th><th align="center">类方法</th><th align="center">静态方法</th></tr></thead><tbody><tr><td align="center">实例: a = A()</td><td align="center">a.foo(x)</td><td align="center">a.class_foo(x)</td><td align="center">a.static_foo(x)</td></tr><tr><td align="center">类: A</td><td align="center">不可用</td><td align="center">A.class_foo(x)</td><td align="center">A.static_foo(x)</td></tr></tbody></table><h2 id="5-单例模式"><a href="#5-单例模式" class="headerlink" title="5. 单例模式"></a>5. 单例模式</h2><ul><li><strong>使用<strong>new</strong>方法</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><strong>共享属性</strong></li></ul><blockquote><p>创建实例时把所有实例的<code>__dict__</code>指向同一个字典,这样它们具有相同的属性和方法.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Borg</span><span class="params">(object)</span>:</span></span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        ob = super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        <span class="keyword">return</span> ob</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span><span class="params">(Borg)</span>:</span></span><br><span class="line">  a = <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><strong>装饰器版本</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getinstance</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> getinstance</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">   ···</span><br></pre></td></tr></table></figure><ul><li><strong>import方法</strong></li></ul><blockquote><p>作为python的模块是天然的单例模式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysingleton.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">my_singleton = My_Singleton()</span><br><span class="line"></span><br><span class="line"><span class="comment"># to use</span></span><br><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> my_singleton</span><br><span class="line"></span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></table></figure><ul><li><strong>元类实现单例</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过__init__方法实现元类（优雅）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"__init__"</span>)</span><br><span class="line">        self.__instance = <span class="literal">None</span></span><br><span class="line">        super(Singleton, self).__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"__call__"</span>)</span><br><span class="line">        <span class="keyword">if</span> self.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.__instance = super(Singleton, self).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> self.__instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">    __metaclass__ = Singleton</span><br><span class="line"></span><br><span class="line">foo1 = Foo()</span><br><span class="line">foo2 = Foo()</span><br><span class="line">print(Foo.__dict__)</span><br><span class="line">print(foo1 <span class="keyword">is</span> foo2)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过元类的__new__方法实现元类（为了实例增加属性重写__new__方法，不推荐）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        print(<span class="string">"__new__"</span>)</span><br><span class="line">        attrs[<span class="string">"_instance"</span>] = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> super(Singleton, cls).__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"__call__"</span>)</span><br><span class="line">        <span class="keyword">if</span> self._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._instance = super(Singleton, self).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> self._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">   __metaclass__ = Singleton</span><br><span class="line"></span><br><span class="line">foo1 = Foo()</span><br><span class="line">foo2 = Foo()</span><br><span class="line">print(Foo.__dict__)</span><br><span class="line">print(foo1 <span class="keyword">is</span> foo2)</span><br></pre></td></tr></table></figure><p><strong><a href="http://python.jobbole.com/87294/" target="_blank" rel="noopener">单例模式伯乐在线详细解释</a></strong></p><h2 id="6-python常用库"><a href="#6-python常用库" class="headerlink" title="6. python常用库"></a>6. python常用库</h2><ul><li><p><strong>标准库</strong></p><p><strong><a href="https://www.cnblogs.com/haochengdu/p/8855028.html" target="_blank" rel="noopener">网友总结参考</a></strong></p><p><strong><a href="https://docs.python.org/zh-cn/3.8/library/index.html" target="_blank" rel="noopener">官网中文参考</a></strong></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">os：提供了不少于操作系统相关联的函数  </span><br><span class="line"></span><br><span class="line">sys：通常用于命令行参数</span><br><span class="line"></span><br><span class="line">res：正则表达式操作</span><br><span class="line"></span><br><span class="line">math：数学运算</span><br><span class="line"></span><br><span class="line">decimal：十进制定点和浮点运算</span><br><span class="line"></span><br><span class="line">datetime：日期时间</span><br><span class="line"></span><br><span class="line">collections：容器数据类型</span><br><span class="line"></span><br><span class="line">json：JSON 编码和解码器</span><br><span class="line"></span><br><span class="line">base64：Base16, Base32, Base64, Base85 数据编码</span><br><span class="line">heapq：堆队列算法</span><br><span class="line"></span><br><span class="line">copy：复制</span><br><span class="line"></span><br><span class="line">threading：基于线程的并行</span><br><span class="line"></span><br><span class="line">multiprocessing：基于进程的并行</span><br><span class="line"></span><br><span class="line">subprocess：子进程管理</span><br><span class="line"></span><br><span class="line">queue：一个同步的队列类</span><br><span class="line"></span><br><span class="line">random：生成伪随机数</span><br><span class="line"></span><br><span class="line">pprint：数据美化输出</span><br><span class="line"></span><br><span class="line">itertools：为高效循环而创建迭代器的函数</span><br><span class="line"></span><br><span class="line">functools：高阶函数和可调用对象上的操作</span><br><span class="line"></span><br><span class="line">operator：标准运算符替代函数</span><br><span class="line"></span><br><span class="line">logging：Python 的日志记录工具</span><br><span class="line"></span><br><span class="line">hashlib：安全哈希与消息摘要</span><br><span class="line"></span><br><span class="line">pickle：Python 对象序列化</span><br><span class="line"></span><br><span class="line">html.parser：简单的 HTML 和 XHTML 解析器</span><br><span class="line"></span><br><span class="line">urllib：URL 处理模块</span><br><span class="line"></span><br><span class="line">traceback：打印或检索堆栈回溯</span><br><span class="line"></span><br><span class="line">__future__：Future 语句定义</span><br><span class="line"></span><br><span class="line">gc：垃圾回收器接口</span><br></pre></td></tr></table></figure><ul><li><p><strong>科学计算与数据分析库</strong></p><blockquote><p>numpy：科学计算包，支持N维数组运算、处理大型矩阵、成熟的广播函数库、矢量运算、线性代数、傅里叶变换、随机数生成，并可与C++/Fortran语言无缝结合。</p></blockquote><blockquote><p>scipy：建立在NumPy基础上，它是离散傅立叶变换、线性代数、优化和稀疏矩阵等多种高级科学和工程模块最有用的库之一。</p></blockquote><blockquote><p>pandas：主要用于结构化数据的运算和操作，广泛用于数据整理和预处理，其有助于提高Python在数据科学社区的使用。</p></blockquote><blockquote><p>matplotlib：主要用于绘制各种各样的图形，从直方图到线图、热力图，还可以使用Latex命令在图像中添加数学符号。</p></blockquote><blockquote><p>Scikit：主要用于机器学习，该库建立在NumPy、SciPy和matplotlib基础上，包含许多有效的机器学习和统计建模工具，如分类、回归、聚类和降维。</p></blockquote><blockquote><p>Statsmodels：用于统计建模，是一个Python中提供用户探索数据、估计统计模型和执行统计测试的模组。可用于不同类型数据的描述性统计，统计测试，绘图功能和结果统计。</p></blockquote><blockquote><p>Seaborn：用于数据可视化，是一个用于在Python中制作有吸引力和翔实的统计图形库。它是基于matplotlib。Seaborn旨在使可视化成为探索和理解数据的核心组成。  </p></blockquote><blockquote><p>Bokeh：用于在现代网络浏览器上创建交互式图表，仪表盘和数据应用程序。它赋予用户以D3.js的风格生成优雅简洁的图形。此外，它具有超大型或流式数据集的高性能交互能力。</p></blockquote><blockquote><p>Blaze: 将Numpy和Pandas的能力扩展到分布式和流式传输数据集。它可以用于从众多来源包括Bcolz，MongDB,SQLAlchemy,Apache Spark,PyTables等访问数据，与Bokeh一起，可以作为在矩形数据模块上创建有效可视化和仪表盘的强大的工具。</p></blockquote><blockquote><p>Sympy：用于符号计算，具有从基本算数符号到微积分、袋鼠、离散数学和量子物理学的广泛能力，另一个有用的功能是将计算结果格式化为LaTeX代码。</p></blockquote></li><li><p><strong>第三方库</strong></p><blockquote><p>pymysqldb：是在 Python2.x 版本中用于连接 MySQL 服务器的一个库，导包：import MySQLdb。</p></blockquote><blockquote><p>PyMySQL：是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，导包：import pymysql，当要向下兼容python2时,可以加上：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个连接对象，再使用创建游标</span></span><br><span class="line">con = pymysql.connect(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'1234'</span>, db=<span class="string">'mysql'</span>)</span><br><span class="line">cursor = con.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一个SQL语句</span></span><br><span class="line">sql = <span class="string">"select * from user"</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从游标中取出所有记录放到一个序列中并关闭游标</span></span><br><span class="line">result = cursor.fetchall()</span><br><span class="line">print(result)</span><br><span class="line">cursor.close()</span><br></pre></td></tr></table></figure><blockquote><p>djano：是一个高层次的web开发框架，特点是开发快、代码少。可扩展性强。采用MTV（Model、Template、View）模型组织资源，框架功能丰富，模板扩展选择最多。</p></blockquote><blockquote><p>flask： 是一个web开发的微框架，严格来说，它仅仅提供web服务器支持，不提供全栈开发支持。然而，Flask非常轻量、非常简单，特别适合小微原型系统的开发，耗时少，开发效率高。  </p></blockquote><blockquote><p>Tornado：是一个基于异步网络功能库的Web开发框架，能够支持几万个开放连接，Web服务比较稳定。比较适合高并发场景下的Web系统，如秒杀系统、抢票系统等，灵活性较差。</p></blockquote><blockquote><p>Falcon：是一个支持大规模微服务API或移动App后端响应的web开发框架，它完全基于python并提供了非常高性能、可靠性和可扩展性。</p></blockquote><blockquote><p>Pyramid：是一个扩展性很强且灵活的web开发框架，上手十分容易，比较适合中等规模且边开发边设计的场景。它不提供绝对严格的框架定义，根据需求可以扩展开发，对高阶程序员十分友好。</p></blockquote><blockquote><p>Quart：是面向ASGI(异步服务器网关接口)开发的web为框架，采用Flask兼容的API接口，提供非常轻量级的开发方式。</p></blockquote><blockquote><p>requests：用于Web访问，类似于python标准库的urllib2，更容易更方便上手，适合初学者。</p></blockquote><blockquote><p>scrapy： 用于网络爬虫，它是获取特定模式数据的非常有用的框架，从网站首页URL开始,然后挖掘网站内的网页内容来手机信息。</p></blockquote><blockquote><p>selenium：是一个用于测试网站的自动化工具，支持Chrome、Firefox、Safari等主流界面浏览器，同时也支持PhantomJS无界面浏览器。</p></blockquote><blockquote><p>celery：是一个由python编写的简单、灵活、可靠的用于处理大量信息的分布式系统，它同时提供操作和维护分布式所需的工具，专注于实时任务，支持任务调度。是一个分布式队列管理工具，可以用celery提供接口快速实现并管理一个分布式任务队列。</p></blockquote></li></ul><h2 id="7-python中的类型转换"><a href="#7-python中的类型转换" class="headerlink" title="7. python中的类型转换"></a>7. python中的类型转换</h2><table><thead><tr><th>函数</th><th>作用</th><th></th><th>函数</th><th>作用</th><th></th><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>int()</td><td>转整型</td><td></td><td>list()</td><td>转列表</td><td></td><td>bin()</td><td>整数转2进制</td></tr><tr><td>float()</td><td>转浮点型</td><td></td><td>dict()</td><td>转字典</td><td></td><td>oct()</td><td>整数转6进制</td></tr><tr><td>str()</td><td>转字符串</td><td></td><td>set()</td><td>转集合</td><td></td><td>hex()</td><td>整数转16进制</td></tr><tr><td>ord()</td><td>字符转整数</td><td></td><td>tuple()</td><td>转元组</td><td></td><td>complex()</td><td>实数转复数</td></tr></tbody></table><h2 id="8-文件流操作"><a href="#8-文件流操作" class="headerlink" title="8. 文件流操作"></a>8. 文件流操作</h2><ul><li><strong>打开文件</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f=open(<span class="string">'file_name'</span>, <span class="string">'file_type'</span>)</span><br><span class="line"><span class="keyword">if</span> f:  <span class="comment"># 判断文件是否打开</span></span><br><span class="line">file_type</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'file_name'</span>, <span class="string">'file_type'</span>) <span class="keyword">as</span> f:</span><br></pre></td></tr></table></figure><ul><li><strong>访问模式</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">w: 只写</span><br><span class="line"></span><br><span class="line">r：只读</span><br><span class="line"></span><br><span class="line">a: 追加写入</span><br><span class="line">rb: 二进制只读</span><br><span class="line"></span><br><span class="line">wb：二进制写入</span><br><span class="line"></span><br><span class="line">ab：二进制追加写入</span><br><span class="line"></span><br><span class="line">r+：打开一个文件用于读写，文件指针将会放在文件的开头。</span><br><span class="line"></span><br><span class="line">w+：打开一个文件用于读写，如果文件已经存在则将其覆盖，如果文件不存在，则创建新文件。</span><br><span class="line"></span><br><span class="line">a+：打开一个文件用于读写，追加模式。如果文件存在，文件指针将会放在文件的结尾；如果该文件不存在，穿件新文件用于读写。</span><br><span class="line"></span><br><span class="line">rb+: 以二进制格式打开一个文件用于读写，文件指正将会放在文件的开头，一般用于非文本文件如图片等。</span><br><span class="line"></span><br><span class="line">wb+:以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件，一般用于非文本文件如图片等。</span><br><span class="line"></span><br><span class="line">ab+:以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾；如果文件不存在，创建新文件用于读写。</span><br></pre></td></tr></table></figure><ul><li><strong>写文件</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.write(content)  <span class="comment"># 打开文件后，将制定内容写入文件中</span></span><br></pre></td></tr></table></figure><ul><li><strong>读取文件</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f.read(lenth)  <span class="comment"># 使用read可以从文件中读取制定长度的数据，并将指针移到这条数据之后。如果为空，则默认读取全部数据。</span></span><br><span class="line"></span><br><span class="line">f.readline()  <span class="comment"># 读取文件中一行数据的信息，指针移动到下一行。</span></span><br><span class="line"></span><br><span class="line">f.readlines() <span class="comment"># 读取整个文件的数据信息，返回一个列表，列表中每个元素为一行数据信息。</span></span><br></pre></td></tr></table></figure><ul><li><strong>查看指针位置</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.tell()  <span class="comment"># 查看单签位置，就是指针对应的位置</span></span><br></pre></td></tr></table></figure><ul><li><strong>指针定位</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">seek(offset, <span class="keyword">from</span>)  <span class="comment"># 将指针定位到某个位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span>: <span class="comment"># 方向，0表示文件开头；1表示文件当前位置；2表示文件的末尾</span></span><br><span class="line">offset: 偏移量</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">    f.seek(<span class="number">5</span>,<span class="number">0</span>)  <span class="comment"># 文件开头，向后偏移5个位置</span></span><br><span class="line">    f.seek(<span class="number">-3</span>,<span class="number">2</span>)  <span class="comment"># 文件结尾，向前偏移3个位置</span></span><br></pre></td></tr></table></figure><h2 id="9-new-和-init的区别"><a href="#9-new-和-init的区别" class="headerlink" title="9. new 和 init的区别"></a>9. <strong>new</strong> 和 <strong>init</strong>的区别</h2><ul><li><strong>new</strong>是一个静态方法，而<strong>init</strong>是一个实例方法</li><li><strong>new</strong>方法会返回一个创建的实例，而<strong>init</strong>什么都不返回</li><li>只有在<strong>new</strong>返回一个cls的实例时，后面的<strong>init</strong>才能被调用</li><li>创建一个新实例时调用<strong>new</strong>方法，初始化一个实例时调用<strong>init</strong>方法</li></ul><h2 id="10-python内存管理与垃圾回收机制"><a href="#10-python内存管理与垃圾回收机制" class="headerlink" title="10. python内存管理与垃圾回收机制"></a>10. python内存管理与垃圾回收机制</h2><p><strong><a href="https://blog.csdn.net/xiongchengluo1129/article/details/80462651" target="_blank" rel="noopener">Python垃圾回收机制详解</a></strong></p><blockquote><p>Python GC主要使用引用计数(reference counting)来跟踪和回收垃圾。在引用计数的基础上，通过标记清除机制(mark and sweep)解决容器对象可能产生的循环引用问题，通过分代回收(generation collection)策略，以以空间换时间的方法来提高垃圾回收的效率。</p></blockquote><ul><li>引用计数</li></ul><blockquote><p>引用计数法的原理是每个对象维护一个ob_ref，用来记录当前对象被引用的次数，也就是来追踪到底有多少引用指向了这个对象，当发生（对象被创建、对象被引用、对象被作为参数传到函数中、对象作为一个元素，存储在容器中）四种情况的时候，该对象的引用计数+1；当发生（该对象的别名被显示销毁时、该对象的引别名被赋予新的对象、一个对象离开它的作用域、该元素从容器中删除时或容器被销毁时），该对象的引用计数器-1。</p></blockquote><p><strong>简而言之，PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当有一个对象有心的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少。当引用计数为0时，该对象生命就结束了。</strong></p><p><strong>优点：</strong><br>① 高效<br>② 运行期没有停顿<br>③ 对象有确定的生命周期<br>④ 易于实现</p><p><strong>缺点：</strong><br>① 维护引用计数消耗资源，维护引用计数的次数和应用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。<br>② 无法解决循环引用的问题。</p><ul><li>标记清除机制(mark and sweep)</li></ul><blockquote><p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没有标记的对象释放。为了保证效率，Python只会在垃圾达到一定阈值时，垃圾回收才会启动。主要处理对象是一些容器对象，如list、dict、tuple、set、instance等，因为对于字符串、数值对象是不可能造成循环引用问题。</p></blockquote><p><strong>缺点：</strong><br>①清除非活动对象前必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。</p><ul><li>分带回收策略</li></ul><blockquote><p>分代回收的整体思想是：将系统中所有的内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，python将内存等为3“代”，分别是年轻代(第0代)、中年代(第1代)、老年代(第2代)，它们对应的是三个链表，它们的垃圾回收集频率随着“代”的存活时间的增大而减小，新创建的对象都会分配在年轻代，年轻代链表总数达到上限时，python垃圾回收机制就回被触发，把那些可以被回收的对象回收，而那些不被回收的对象就会移到中年代去，以此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期，存活时间通常利用经过几次垃圾回收来度量。同时，分代回收是建立在标记清除技术基础之上。</p></blockquote><blockquote><p>Python默认定义三代对象集合，索引越大，对象存活时间越长。</p></blockquote><h2 id="11-python2-x-与python3-x的主要区别"><a href="#11-python2-x-与python3-x的主要区别" class="headerlink" title="11. python2.x 与python3.x的主要区别"></a>11. python2.x 与python3.x的主要区别</h2><p><strong><a href="https://www.pythonheidong.com/blog/article/22/" target="_blank" rel="noopener">比较详细</a></strong></p><ul><li><p>输入， py2中：raw_input(); py3中：input()</p></li><li><p>输出， py2中：print语句; py3中：print()函数</p></li><li><p>除法，py2中整数间进行’/‘和’//‘运算返回的是整数，而py3的’/‘运算返回的是浮点数</p></li><li><p>遍历范围，py2中：range()或xrange(); py3中：不等于，py2中：range</p></li><li><p>不等于，py2中：&lt;&gt;或!= ; py3中：!=</p></li><li><p>编码问题，py3默认使用unicode，字节是bytes；而py2中字节是str, 默认支持ascii编码，unicode需要在前面加u</p></li><li><p>异常，py2中：except exec, var ; py3中：except exec as var</p></li><li><p>八进制字面量，py2中：0o777或0777 ; py3中：0o777</p></li><li><p>去掉了repr表达式``，py2中：反引号相当于repr()的作用; py3中：去除反引号写法</p></li><li><p>多个模块变化</p></li></ul><table><thead><tr><th>旧的名字</th><th>新的名字</th></tr></thead><tbody><tr><td>_winreg</td><td>winreg</td></tr><tr><td>ConfigParser</td><td>configparser</td></tr><tr><td>copy_reg</td><td>copyreg</td></tr><tr><td>Queue</td><td>queue</td></tr><tr><td>SocketServer</td><td>socketserver</td></tr><tr><td>repr</td><td>reprlib</td></tr></tbody></table><ul><li><p>数据类型，py3中去除long类型，只有int</p></li><li><p>rasie，py2中：raise IOError, “file error”; py3中：raise IOError(“file error”)</p></li><li><p>去除.next()，py2中：next(generator)和generator.next(); py3中：next(generator)</p></li><li><p>py3中for循环变量不会导致命名空间泄漏</p></li><li><p>py3中不能比较不可排序类型，需同类型比较</p></li><li><p>py3中range、zip、map、reduce、filter等返回的是可迭代对象，而不是列表</p></li><li><p>py3中新增asynico内置库，async/await原生协程支持异步编程</p></li><li><p>py3中移除cmp函数</p></li><li><p>py3中去除元组参数解包</p></li><li><p>增加了@abstractmethod和 @abstractproperty两个 decorator，编写抽象方法（属性）更加方便</p></li><li><p>移除了cPickle模块，可以使用pickle模块代替</p></li><li><p>移除了new模块</p></li><li><p>移除了 audiodev, Bastion, bsddb185, exceptions, linuxaudiodev, md5, MimeWriter, mimify, popen2,<br>rexec, sets, sha, stringold, strop, sunaudiodev, timing和xmllib模块</p></li><li><p>移除了imageop模块</p></li><li><p>迭代器的next()方法改名为<strong>next</strong>()，并增加内置函数next()，用以调用迭代器的<strong>next</strong>()方法</p></li></ul><h2 id="12-如何将python2的代码迁移到python3"><a href="#12-如何将python2的代码迁移到python3" class="headerlink" title="12. 如何将python2的代码迁移到python3"></a>12. 如何将python2的代码迁移到python3</h2><p><strong><a href="https://docs.python.org/zh-cn/3.9/howto/pyporting.html" target="_blank" rel="noopener">官方文档</a></strong></p><blockquote><p>第一步：使用自带的2to3.py文件，可以实现大部分代码从py2到py3的自动转换。命令：2to3 -w example.py</p></blockquote><blockquote><p>第二步：使用Pylint或者Pyflakes工具，检测代码错误。</p></blockquote><blockquote><p>第三步：检查模块和依赖库的变化。</p></blockquote><blockquote><p>第四步：人工修复被破坏的py2代码。</p></blockquote><p><strong>利用好<strong>future</strong>模块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division  <span class="comment"># 在Python 2 中表现 Python 3.x 中的整除</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals  <span class="comment"># 适应Python 3.x的新的字符串的表示方法</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function  <span class="comment"># 使用打印功能</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> nested_scopes  <span class="comment"># 静态嵌套范围</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> generators  <span class="comment"># 简单生成器</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import  <span class="comment"># 绝对/相对导入</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> with_statement  <span class="comment"># with声明</span></span><br></pre></td></tr></table></figure><h2 id="13-python新式类和旧式类的区别"><a href="#13-python新式类和旧式类的区别" class="headerlink" title="13. python新式类和旧式类的区别"></a>13. python新式类和旧式类的区别</h2><blockquote><p>新式类是在创建的时候继承内置的object对象或者是内置类型如list、dict，而旧式类(经典类)是直接声明的，可以用dir()方法查看新式类中内置了很多性的属性和方法。</p></blockquote><blockquote><p>新式类遍历方法是广度优先，经典类是深度优先。</p></blockquote><h2 id="14-鸭子类型"><a href="#14-鸭子类型" class="headerlink" title="14. 鸭子类型"></a>14. 鸭子类型</h2><blockquote><p>编程语言中动态类型语言的一种设计风格，一个对象的特征不是由父类决定，而是通过对象的方法决定。类与类之间不用共同继承一个父类，只需要将它们做的像一件事物即可。</p></blockquote><blockquote><p>注重对象的行为，而非对象的类型，一个对象能都昨晚函数、表达是的参数，取决于其行为而非类型归属。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gua gua"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"女王大人"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_quack</span><span class="params">(ducker)</span>:</span></span><br><span class="line">    ducker.quack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    d = Duck(<span class="string">'duck'</span>)</span><br><span class="line">    m = Man(<span class="string">'man'</span>)</span><br><span class="line">    do_quack(d)</span><br><span class="line">    do_quack(m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">gua gua</span></span><br><span class="line"><span class="string">女王大人</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="15-python自省"><a href="#15-python自省" class="headerlink" title="15. python自省"></a>15. python自省</h2><blockquote><p>在一些语言中也叫做反射，简单来说就是对象检查。面向对象的语言所写的程序在运行时，所能知道对象的类型。是什么(isinstance)，是什么类型(type)，有那些属性(hasattr)，有哪些变量方法(dir)，有哪些行为(hasattr)，getattr、setattr、delattr、callable。</p></blockquote><h2 id="16-猴子补丁技术"><a href="#16-猴子补丁技术" class="headerlink" title="16. 猴子补丁技术"></a>16. 猴子补丁技术</h2><blockquote><p>是一种让程序行为在运行时扩展或者变更的方法。</p></blockquote><blockquote><p>python充分利用动态语言的特性，在程序运行时动态改变类、模块、属性或方法，为的是将第三方代码打补丁在不按预期运行的bug或者feature上，gevent在这方面运用的比较多。</p></blockquote><h2 id="17-python语法糖有哪些"><a href="#17-python语法糖有哪些" class="headerlink" title="17. python语法糖有哪些"></a>17. python语法糖有哪些</h2><blockquote><p>在计算及科学中，语法糖是某种特殊的语法，对语言的功能没有影响，但对程序员来说，有更好的易用性，简洁性、可读性、方便性。比如索引切片、列表推导式、字典推导式、生成器推导式等等。</p></blockquote><ul><li>切片操作</li></ul><p><strong><a href="https://www.jianshu.com/p/15715d6f4dad" target="_blank" rel="noopener">Python切片操作详细例子</a></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'123456'</span></span><br><span class="line">s[:<span class="number">3</span>]  <span class="comment"># 结果为'123'，取索引索引小于3的值，或叫“取前3位”</span></span><br><span class="line">s[<span class="number">3</span>:]  <span class="comment"># 结果为'456', 取索引大于等于3的值，或叫“从第4位取到最后”</span></span><br><span class="line">s[<span class="number">2</span>:<span class="number">4</span>]  <span class="comment"># 结果为'34', 取索引大于等2，小于4的值，或叫“取第3位到第4位”</span></span><br><span class="line">s[:]  <span class="comment"># 结果为'123456', 取索引全部</span></span><br><span class="line">s[:<span class="number">-1</span>]  <span class="comment"># 结果为'654321' 取倒序</span></span><br><span class="line">s[::<span class="number">2</span>]  <span class="comment"># 结果为'135' 步长为2取值</span></span><br></pre></td></tr></table></figure><ul><li>with打开文件</li></ul><blockquote><p>实现的是一个上下文管理器，它主要的特点就是帮助我们自动管理上下文的衔接。即在需要的时候传给我们，不需要的时候自动关闭上下文对象。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        print(line,end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><ul><li>else语法糖</li></ul><blockquote><p>for-else、while-else 需要和break语句配合使用。</p></blockquote><blockquote><p>try-else-finally</p></blockquote><ul><li><p>动态参数: (<em>args, *</em>kwargs)</p></li><li><p>匿名函数: lambda x: x * 2</p></li><li><p>推导表达式</p></li></ul><blockquote><p>列表推导表达式：[i for i in s if i%2 != 0]<br>生成器推导表达式： (i for i in s if i%2 != 0)<br>集合推导表达式：{i for i in s if i%2 != 0}<br>字典推导表达式：{i:i*2 for i in s if i%2 != 0}</p></blockquote><ul><li>yield表达式</li></ul><blockquote><p>yield是Python中实现<strong>协程(coroutine)</strong>的一个重要基础</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_generator</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">'''生成器'''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">yield</span> i*<span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>装饰器</li></ul><blockquote><p>一种设计模式，本质上也是一种python函数，是一种闭包。装饰器需要返回一个对象，该对象可以是经过处理的原参数对象，一个包装且类似原参数的对象。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">'''装饰器'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure><ul><li>map</li></ul><blockquote><p>map(function, iterable, …) 会根据提供的函数对指定序列做映射。function函数，iterable一个或多个序列，其中py2返回的列表，py3返回的是迭代器。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line">map(square, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">map(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>], [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>])</span><br></pre></td></tr></table></figure><ul><li>reduce</li></ul><blockquote><p>reduce(function, iterable[, initializer]) 函数会对参数序列中元素进行累积。function 有两个参数, iterable可迭代对象，initializer可选，初始参数。用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">reduce(add, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">reduce(<span class="keyword">lambda</span> x, y: x+y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure><ul><li>filter</li></ul><blockquote><p>filter(function, iterable) 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。function判断函数，iterable可迭代对象，该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">odd</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line">newlist = filter(odd, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">print(list(newlist))</span><br></pre></td></tr></table></figure><h2 id="18-迭代器和生成器"><a href="#18-迭代器和生成器" class="headerlink" title="18. 迭代器和生成器"></a>18. 迭代器和生成器</h2><blockquote><p>迭代器是一个更抽象的概念，任何对象，如果它的类有next方法和iter方法返回自己本身。对于string、list、dict、tuple等这类容器对象，使用for循环遍历是很方便的。在后台for语句对容器对象调用iter()函数，iter()是python的内置函数。iter()会返回一个定义了next()方法的迭代器对象，它在容器中逐个访问容器内元素，next()也是python的内置函数。在没有后续元素时，next()会抛出一个StopIteration异常。</p></blockquote><blockquote><p>生成器(Generator)是创建迭代器的简单而强大的工具。它们写起来就像是正规的函数，只是在需要返回数据的时候使用yield语句，生成器使用yield语句返回一个值，yield语句挂起该生成器函数的状态，保留足够的信息，以便之后从它离开的地方继续执行。每次next()被调用时，生成器会返回它脱离的位置（它记忆语句最后一次执行的位置和所有的数据值）。生成器需要注意：只能遍历一次。</p></blockquote><blockquote><p>区别：生成器能做到迭代器能做的所有事，而且因为自动创建了<strong>iter</strong>()和next()方法，生成器显得特别简洁，而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法，当发生器终结时，还会自动抛出StopIteration异常。</p></blockquote><h2 id="19-闭包"><a href="#19-闭包" class="headerlink" title="19. 闭包"></a>19. 闭包</h2><blockquote><p>闭包(closure)是函数式编程的重要的语法结构，也是一种组织代码的结构，提高了代码的复用性。简单说，外函数的内部定义了一个内函数，内部函数使用了外部函数的临时变量，并外函数的返回值是内函数的引用。产生闭包需满足的条件：</p></blockquote><ul><li>必须有一个内嵌函数</li><li>内嵌函数必须引用外部函数的变量</li><li>外部函数的返回值必须是内嵌函数</li></ul><blockquote><p>简单说，闭包就是根据不同的配置信息得到不同的结果，装饰器就是一种闭包，闭包有效的减少了函数所需定义的参数数目。</p></blockquote><blockquote><p>闭包的好处：<br>    - 取代硬编码中的常量<br>    - 避免使用全局值，并提供某种形式的数据隐藏<br>    - 提供一致的函数签名<br>    - 实现面向对象</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">line_conf</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">line</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a*x +b</span><br><span class="line">    <span class="keyword">return</span> line</span><br><span class="line"></span><br><span class="line">line1 = line_conf(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">line2 = line_conf(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">print(line1(<span class="number">5</span>), line2(<span class="number">5</span>))  <span class="comment"># (6, 25)</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>返回闭包时：返回函数不要引用任何循环变量，或者后续会发生变化的变量</strong>。解决方法是在创建一个函数，用函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> j*j</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        fs.append(f(i))</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line">print(f1())</span><br><span class="line">print(f2())</span><br><span class="line">print(f3())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="20-装饰器"><a href="#20-装饰器" class="headerlink" title="20. 装饰器"></a>20. 装饰器</h2><blockquote><p><strong>以下是一些前人的总结参考：</strong></p></blockquote><p><strong><a href="https://blog.csdn.net/tryhardsilently/article/details/90767627" target="_blank" rel="noopener">python装饰器</a></strong></p><p><strong><a href="https://blog.csdn.net/yhy1271927580/article/details/72758577" target="_blank" rel="noopener">Python装饰器各种类型详解</a></strong></p><p><strong><a href="https://blog.csdn.net/five3/article/details/83447467" target="_blank" rel="noopener">Python各种类型装饰器详解说明</a></strong></p><p><strong><a href="https://blog.csdn.net/xiemanr/article/details/72510885" target="_blank" rel="noopener">python装饰器的4种类型</a></strong></p><p><strong><a href="https://blog.csdn.net/weixin_42134789/article/details/84635252?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase" target="_blank" rel="noopener">一文看懂Python系列之装饰器</a></strong></p><p><strong><a href="https://blog.csdn.net/u010358168/article/details/77773199?utm_medium=distribute.pc_relevant_right.none-task-blog-BlogCommendFromMachineLearnPai2-29.nonecase&depth_1-utm_source=distribute.pc_relevant_right.none-task-blog-BlogCommendFromMachineLearnPai2-29.nonecase" target="_blank" rel="noopener">python装饰器简介</a></strong></p><blockquote><p>装饰器本质上是一个函数，可以让其他函数在不需要做任何代码处理的前提下增加额外的功能，装饰器的返回值也是一个函数对象(函数的引用)。它经常用于有切面需求的场景，比如：<strong>插入日志、性能测试、事务处理、缓存、权限校验等场景</strong>，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p></blockquote><ul><li><strong>装饰器自身为函数</strong></li></ul><p>(1). 被装饰的对象为函数，且不带参数  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)  # 保证装饰过的函数__name__属性不变</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"Hello inner"</span>)</span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(func.__name__, end - start))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且不带参数</span></span><br><span class="line"><span class="meta">@time_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"foo is running."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.__name__)</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">inner</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">foo is running.</span></span><br><span class="line"><span class="string">方法foo用时:3.01444411277771秒</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>在以上代码中，@time_decorator装饰器对foo函数进行了装饰，这是一个不带参数的装饰器，当python解释器执行到@time_decorator时，回去调用time_decorator函数，同时将被装饰的对象的函数名foo作为参数传入，这时time_decorator函数接受到一个参数(即方法名foo)，然后进入内嵌函数inner，计算开始时间，调用传进来的foo方法，再计算结束时间，打印函数foo的耗时，最后将结果用内部函数inner返回，其实就是一个闭包函数。</p></blockquote><blockquote><p>首先打印的是foo.<strong>name</strong>，这里是inner而不是foo，本质上是调用inner函数<br>其次打印的是inner的内容”Hello inner”，然后开始调用foo函数，打印”func1 is running.”<br>最后打印”方法foo用时:3.01444411277771秒”</p></blockquote><p>(2). 被装饰的对象为函数，且带参数  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    如果原函数有参数，那闭包函数必须保持参数个数一直，并且将参数传递给原方法</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"><span class="meta">    @wraps(func)  # 保证装饰过的函数__name__属性不变</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(name)</span>:</span>  <span class="comment"># 如果被装饰的函数有形参，那么闭包函数必须有参数，且一致</span></span><br><span class="line">        print(<span class="string">"Hello inner"</span>)</span><br><span class="line">        start = time.time()</span><br><span class="line">        func(name)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(func.__name__, end - start))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数，且带参数</span></span><br><span class="line"><span class="meta">@time_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"hello "</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.__name__)</span><br><span class="line">foo(<span class="string">'lucy'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">hello lucy</span></span><br><span class="line"><span class="string">方法foo用时:3.000863790512085秒</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>当被装饰的函数，带参数时，需要在装饰器的闭包函数inner函数中添加一致的参数name，调用func对象时也需要加上一致的参数name，并且返回了以reurn inner形式返回闭包函数，具体调用过程看结果应该不难理解。</p></blockquote><blockquote><p>当然，如果被装饰函数存在多个参数时，这里使用了python中动态参数的概念，利用<code>(*args, **kwargs)</code>来接收可变参数和关键字参数，这样装饰器就可以支持任意的组合参数的函数了。装饰器修改如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)  # 保证装饰过的函数__name__属性不变</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 接收可变参数和关键字参数</span></span><br><span class="line">        print(<span class="string">"Hello inner"</span>)</span><br><span class="line">        start = time.time()</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(func.__name__, end - start))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数，且带参数</span></span><br><span class="line"><span class="meta">@time_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"hello "</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.__name__)</span><br><span class="line">foo(<span class="string">'lucy'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">hello lucy</span></span><br><span class="line"><span class="string">方法foo用时:3.000807762145996秒</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>(3). 被装饰的对象为函数，且带返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)  # 保证装饰过的函数__name__属性不变</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"Hello inner"</span>)</span><br><span class="line">        start = time.time()</span><br><span class="line">        res = func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(func.__name__, end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且带返回值</span></span><br><span class="line"><span class="meta">@time_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"foo is running."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"this is foo's return value"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.__name__)</span><br><span class="line">res = foo()</span><br><span class="line">print(<span class="string">'返回值：%s'</span> % res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">foo is running.</span></span><br><span class="line"><span class="string">方法foo用时:3.000837802886963秒</span></span><br><span class="line"><span class="string">返回值：this is foo's return value</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>若被装饰的函数是带返回值的，闭包函数inner中，调用func()时必须相应的带返回值，不然装饰函数时，也不进行返回，默认为None。</p></blockquote><p>(4). 被装饰的对象为函数，且装饰器带参数也有返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且带参数带返回值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_decorator</span><span class="params">(arg=None)</span>:</span>  <span class="comment"># 如果在调用装饰器时为给传参数，则默认值为None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)  # 保证装饰过的函数__name__属性不变</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">"Hello inner"</span>)</span><br><span class="line">            print(<span class="string">"装饰器的参数为：&#123;&#125;"</span>.format(arg))</span><br><span class="line">            start = time.time()</span><br><span class="line">            res = func(*args,**kwargs)</span><br><span class="line">            end = time.time()</span><br><span class="line">            print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(func.__name__, end - start))</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且不定参数</span></span><br><span class="line"><span class="meta">@time_decorator('hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"foo is running."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"this is foo's return value"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.__name__)</span><br><span class="line">res = foo()</span><br><span class="line">print(<span class="string">'返回值：%s'</span> % res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">装饰器的参数为：hello</span></span><br><span class="line"><span class="string">foo is running.</span></span><br><span class="line"><span class="string">方法foo用时:3.000739336013794秒</span></span><br><span class="line"><span class="string">返回值：this is foo's return value</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>带有参数的装饰器，需要写三层嵌套函数，最外一层用来传递装饰器的参数。上面的装饰器即带参数也带返回值，先执行time_decorator(‘hello’)，返回wrapper函数的应用，然后使用wrapper对函数foo进行装饰，内层inner使用的是<code>*args,**kwargs</code>接收可变参数和关键字参数，具体运行顺序看结果应该不难理解。</p></blockquote><p>(5). 被装饰的对象为类，且不带参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="comment"># 在装饰器中声明一个变量，用于保存类的实例，那么这个实例对象将始终是通过一个实例对象</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line"><span class="meta">    @wraps(cls)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'Hello inner'</span>)</span><br><span class="line">        print(<span class="string">'class name: &#123;&#125;'</span>.format(cls.__name__))</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls()</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象是类，且不带参数</span></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'lucy'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"her name is &#123;&#125;"</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化装饰后的类</span></span><br><span class="line">print(Foo.__name__)</span><br><span class="line">foo = Foo()</span><br><span class="line">foo.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">class name: Foo</span></span><br><span class="line"><span class="string">her name is lucy</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的例子是基于装饰器的单例模式，通过装饰器装饰这个类，是的类在初始化时候始终将初始化实例赋值给instances，而instances是装饰器的一个实例对象，通过实例赋值，instances始终占有同一个内存空间，也就实现了单例模式设计。</p></blockquote><blockquote><p>当然，如果用这个装饰器对类里面方法say进行装饰的话，此时装饰器single接收到的参数cls=say，所以打印”class name”是say，因为cls__name__就是say，这里等同于函数装饰器给函数进行装饰，于是装饰器的内层函数inner需要接受say带来的参数name，不加参数则会报错，其他与前面一样。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="comment"># 在装饰器中声明一个变量，用于保存类的实例，那么这个实例对象将始终是通过一个实例对象</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line"><span class="meta">    @wraps(cls)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(name)</span>:</span>  <span class="comment"># 必须和所修饰类里面的函数参数个数一致，否则会报错</span></span><br><span class="line">        print(<span class="string">'Hello inner'</span>)</span><br><span class="line">        print(<span class="string">'class name: &#123;&#125;'</span>.format(cls.__name__))</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(name)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象是类中的函数，调用类中的初始化参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'lucy'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @singleton</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"her name is &#123;&#125;"</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化装饰后的类</span></span><br><span class="line">print(Foo.__name__)</span><br><span class="line">foo = Foo()</span><br><span class="line">foo.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">class name: say</span></span><br><span class="line"><span class="string">her name is lucy</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>(6). 被装饰的对象为类，且带参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="comment"># 在装饰器中声明一个变量，用于保存类的实例，那么这个实例对象将始终是通过一个实例对象</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(cls)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Hello inner'</span>)</span><br><span class="line">        print(<span class="string">'class name: &#123;&#125;'</span>.format(cls.__name__))</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象是类，且带参数</span></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.id = args[<span class="number">0</span>]</span><br><span class="line">        self.name = kwargs.get(<span class="string">'name_dict'</span>).get(self.id)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"her name is &#123;&#125;"</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化装饰后的类</span></span><br><span class="line">print(Foo.__name__)</span><br><span class="line">foo = Foo(<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, name_dict=&#123;<span class="string">'1'</span>: <span class="string">'Lucy'</span>, <span class="string">'2'</span>: <span class="string">'Linda'</span>, <span class="string">'3'</span>: <span class="string">'Mary'</span>&#125;)</span><br><span class="line">foo.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">class name: Foo</span></span><br><span class="line"><span class="string">her name is Lucy</span></span><br></pre></td></tr></table></figure><p>(7). 被装饰的对象为类，且装饰器带参数也有返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器为函数，且带参数带返回值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(arg=None)</span>:</span> <span class="comment"># 如果在调用装饰器时为给传参数，则默认值为None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="comment"># 在装饰器中声明一个变量，用于保存类的实例，那么这个实例对象将始终是通过一个实例对象</span></span><br><span class="line">        instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(cls)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">'Hello inner'</span>)</span><br><span class="line">            print(<span class="string">"装饰器的参数为：&#123;&#125;"</span>.format(arg))</span><br><span class="line">            print(<span class="string">'class name: &#123;&#125;'</span>.format(cls.__name__))</span><br><span class="line">            <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">                instances[cls] = cls(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> instances[cls]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象是类，且带参数</span></span><br><span class="line"><span class="meta">@singleton('hello')</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.id = args[<span class="number">0</span>]</span><br><span class="line">        self.name = kwargs.get(<span class="string">'name_dict'</span>).get(self.id)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"her name is &#123;&#125;"</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化装饰后的类</span></span><br><span class="line">print(Foo.__name__)</span><br><span class="line">foo = Foo(<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, name_dict=&#123;<span class="string">'1'</span>: <span class="string">'Lucy'</span>, <span class="string">'2'</span>: <span class="string">'Linda'</span>, <span class="string">'3'</span>: <span class="string">'Mary'</span>&#125;)</span><br><span class="line">foo.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">装饰器的参数为：hello</span></span><br><span class="line"><span class="string">class name: Foo</span></span><br><span class="line"><span class="string">her name is Lucy</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>这里与（4）类似，都是带有参数的装饰器，且装饰器为函数，需要写三层嵌套函数，最外一层用来传递装饰器的参数。上面的装饰器即带参数也带返回值，先执行time_decorator(‘hello’)，返回wrapper函数的应用，然后使用wrapper对函数foo进行装饰，内层inner使用的是<code>*args,**kwargs</code>接收可变参数和关键字参数，具体运行顺序看结果应该不难理解。</p></blockquote><ul><li><strong>装饰器自身为类</strong></li></ul><blockquote><p>类装饰器本质上和函数装饰器原理、作用相同，都是为其它函数增加额外的功能。但是相比于函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器可以直接依靠类内部的<strong>call</strong>方法来实现，当使用 @ 形式将类装饰器附加到函数上时，就会调用类装饰器的<strong>call</strong>方法。而不需要向函数装饰器那样，在装饰器函数中定义嵌套函数，来实现装饰功能。</p></blockquote><p>(1). 被装饰的对象为函数，且不带参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器是类，且不带参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化函数只会调用一次，当第二次装饰的时候，这一步就滤过了</span></span><br><span class="line">        print(<span class="string">'decorator init'</span>)</span><br><span class="line">        print(<span class="string">'func name is &#123;&#125;'</span>.format(func.__name__))</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'装饰器中的功能：&#123;&#125; 睡眠3秒'</span>.format(self.func.__name__))</span><br><span class="line">        start = time.time()</span><br><span class="line">        res = self.func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(self.func.__name__, end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且不带参数</span></span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"foo is running."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.func.__name__)</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator init</span></span><br><span class="line"><span class="string">func name is foo</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">装饰器中的功能：foo 睡眠3秒</span></span><br><span class="line"><span class="string">foo is running.</span></span><br><span class="line"><span class="string">方法foo用时:3.000671863555908秒</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>装饰器为类时，调用<strong>init</strong>方法创建实例、传递参数，并调用<strong>call</strong>方法实现对被装饰函数功能的添加。</p></blockquote><p>(2). 被装饰的对象为函数，且带参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器是类，且不带参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化函数只会调用一次，当第二次装饰的时候，这一步就滤过了</span></span><br><span class="line">        print(<span class="string">'decorator init'</span>)</span><br><span class="line">        print(<span class="string">'func name is &#123;&#125;'</span>.format(func.__name__))</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">'装饰器中的功能：&#123;&#125; 睡眠3秒'</span>.format(self.func.__name__))</span><br><span class="line">        start = time.time()</span><br><span class="line">        res = self.func(name)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(self.func.__name__, end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且带参数</span></span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"hello "</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.func.__name__)</span><br><span class="line">foo(<span class="string">'lucy'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator init</span></span><br><span class="line"><span class="string">func name is foo</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">装饰器中的功能：foo 睡眠3秒</span></span><br><span class="line"><span class="string">hello lucy</span></span><br><span class="line"><span class="string">方法foo用时:3.0009634494781494秒</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>当被装饰的函数，且带参数时，需要在装饰器类的<strong>call</strong>中添加一致的参数name，调用func对象时也需要加上一致的参数name，并且返回了以reurn inner形式返回闭包函数，具体调用过程看结果应该不难理解。</p></blockquote><blockquote><p>当然，如果被装饰函数存在多个参数时，这里使用了python中动态参数的概念，利用<code>(*args, **kwargs)</code>来接收可变参数和关键字参数，这样装饰器就可以支持任意的组合参数的函数了。装饰器修改如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器是类，且不带参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化函数只会调用一次，当第二次装饰的时候，这一步就滤过了</span></span><br><span class="line">        print(<span class="string">'decorator init'</span>)</span><br><span class="line">        print(<span class="string">'func name is &#123;&#125;'</span>.format(func.__name__))</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'装饰器中的功能：&#123;&#125; 睡眠3秒'</span>.format(self.func.__name__))</span><br><span class="line">        start = time.time()</span><br><span class="line">        res = self.func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(self.func.__name__, end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且带参数</span></span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"hello "</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.func.__name__)</span><br><span class="line">foo(<span class="string">'lucy'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator init</span></span><br><span class="line"><span class="string">func name is foo</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">装饰器中的功能：foo 睡眠3秒</span></span><br><span class="line"><span class="string">hello lucy</span></span><br><span class="line"><span class="string">方法foo用时:3.000622510910034秒</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>(3). 被装饰的对象为函数，且带返回值  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器是类，且不带参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化函数只会调用一次，当第二次装饰的时候，这一步就滤过了</span></span><br><span class="line">        print(<span class="string">'decorator init'</span>)</span><br><span class="line">        print(<span class="string">'func name is &#123;&#125;'</span>.format(func.__name__))</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'装饰器中的功能：&#123;&#125; 睡眠3秒'</span>.format(self.func.__name__))</span><br><span class="line">        start = time.time()</span><br><span class="line">        res = self.func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(self.func.__name__, end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且带返回值</span></span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"foo is running."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"this is foo's return value"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.func.__name__)</span><br><span class="line">res = foo()</span><br><span class="line">print(<span class="string">'返回值：%s'</span> % res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator init</span></span><br><span class="line"><span class="string">func name is foo</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">装饰器中的功能：foo 睡眠3秒</span></span><br><span class="line"><span class="string">foo is running.</span></span><br><span class="line"><span class="string">方法foo用时:3.0008039474487305秒</span></span><br><span class="line"><span class="string">返回值：this is foo's return value</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>和之前装饰器是函数一样，若被装饰的函数是带返回值的，闭包函数inner中，调用func()时必须相应的带返回值，不然装饰函数时，也不进行返回，默认为None。</p></blockquote><p>(4). 被装饰的对象为函数，且装饰器带参数也有返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器是类，且带参数带返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg=None)</span>:</span>  <span class="comment"># 如果在调用装饰器时为给传参数，则默认值为None</span></span><br><span class="line">        print(<span class="string">'decorator init'</span>)</span><br><span class="line">        self.arg = arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)  # 保证装饰过的函数__name__属性不变</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">"Hello inner"</span>)</span><br><span class="line">            print(<span class="string">'装饰器的参数为：&#123;&#125;'</span>.format(self.arg))</span><br><span class="line">            print(<span class="string">'装饰器中的功能：&#123;&#125; 睡眠3秒'</span>.format(func.__name__))</span><br><span class="line">            start = time.time()</span><br><span class="line">            res = func(*args, **kwargs)</span><br><span class="line">            end = time.time()</span><br><span class="line">            print(<span class="string">'方法&#123;&#125;用时:&#123;&#125;秒'</span>.format(func.__name__, end - start))</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且不带参数</span></span><br><span class="line"><span class="meta">@Decorator('hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"foo is running."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"this is foo's return value"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">print(foo.__name__)</span><br><span class="line">res = foo()</span><br><span class="line">print(<span class="string">'返回值：%s'</span> % res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator init</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">装饰器的参数为：hello</span></span><br><span class="line"><span class="string">装饰器中的功能：foo 睡眠3秒</span></span><br><span class="line"><span class="string">foo is running.</span></span><br><span class="line"><span class="string">类foo用时:3.000250816345215秒</span></span><br><span class="line"><span class="string">返回值：this is foo's return value</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>和之前装饰器是函数一样，带有参数的装饰器类，会把被装饰函数所带的参数传递给装饰器<strong>init</strong>进行初始化，而<strong>call</strong>作为外层函数接收被装饰函数的函数名，作为参数传递给内层函数inner，这里需要注意的是func传入，不需要在前面加self了，其他的跟函数装饰函数很相似，可以通过结果去理解整个装饰器的运行过程。</p></blockquote><p>(5). 被装饰的对象为类，且不带参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器是类，且不带参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化函数只会调用一次，当第二次装饰的时候，这一步就滤过了</span></span><br><span class="line">        print(<span class="string">'decorator init'</span>)</span><br><span class="line">        print(<span class="string">'class name is &#123;&#125;'</span>.format(func.__name__))</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'装饰器中的功能：&#123;&#125; 睡眠3秒'</span>.format(self.func.__name__))</span><br><span class="line">        start = time.time()</span><br><span class="line">        res = self.func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'类&#123;&#125;用时:&#123;&#125;秒'</span>.format(self.func.__name__, end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为函数，且不带参数</span></span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'lucy'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line">        print(<span class="string">"her name is &#123;&#125;"</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化装饰后的类</span></span><br><span class="line">print(<span class="string">"类名：&#123;&#125;"</span>.format(Foo.func.__name__))</span><br><span class="line">foo = Foo()</span><br><span class="line">foo.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator init</span></span><br><span class="line"><span class="string">func name is Foo</span></span><br><span class="line"><span class="string">类名：Foo</span></span><br><span class="line"><span class="string">装饰器中的功能：Foo 睡眠3秒</span></span><br><span class="line"><span class="string">类Foo用时:0.0秒</span></span><br><span class="line"><span class="string">her name is lucy</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>跟函数装饰器装饰类一样，这里把类Foo通过@Decorator类装饰器传递给参数func，但这个类装饰器没有<strong>get</strong>方法，无法返回装饰后的类，而是进行初始化。第二次调用，这时类Foo()就相当于调用了装饰器的<strong>call</strong>方法，在里面调用self.func()方法</p></blockquote><p>(6). 被装饰的对象为类，且带参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器是类，且不带参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化函数只会调用一次，当第二次装饰的时候，这一步就滤过了</span></span><br><span class="line">        print(<span class="string">'decorator init'</span>)</span><br><span class="line">        print(<span class="string">'class name is &#123;&#125;'</span>.format(func.__name__))</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'装饰器中的功能：&#123;&#125; 睡眠3秒'</span>.format(self.func.__name__))</span><br><span class="line">        start = time.time()</span><br><span class="line">        res = self.func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'类&#123;&#125;用时:&#123;&#125;秒'</span>.format(self.func.__name__, end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为类，且带参数</span></span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.id = args[<span class="number">0</span>]</span><br><span class="line">        self.name = kwargs.get(<span class="string">'name_dict'</span>).get(self.id)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"her name is &#123;&#125;"</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化装饰后的类</span></span><br><span class="line">print(<span class="string">"类名：&#123;&#125;"</span>.format(Foo.func.__name__))</span><br><span class="line">foo = Foo(<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, name_dict=&#123;<span class="string">'1'</span>: <span class="string">'Lucy'</span>, <span class="string">'2'</span>: <span class="string">'Linda'</span>, <span class="string">'3'</span>: <span class="string">'Mary'</span>&#125;)</span><br><span class="line">foo.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator init</span></span><br><span class="line"><span class="string">class name is Foo</span></span><br><span class="line"><span class="string">类名：Foo</span></span><br><span class="line"><span class="string">装饰器中的功能：Foo 睡眠3秒</span></span><br><span class="line"><span class="string">方法Foo用时:0.0秒</span></span><br><span class="line"><span class="string">her name is Lucy</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>(7). 被装饰的对象为类，且装饰器带参数也有返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器是类，且带参数带返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg=None)</span>:</span>  <span class="comment"># 如果在调用装饰器时为给传参数，则默认值为None</span></span><br><span class="line">        print(<span class="string">'decorator init'</span>)</span><br><span class="line">        self.arg = arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)  # 保证装饰过的函数__name__属性不变</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">"Hello inner"</span>)</span><br><span class="line">            print(<span class="string">'装饰器的参数为：&#123;&#125;'</span>.format(self.arg))</span><br><span class="line">            print(<span class="string">'装饰器中的功能：&#123;&#125; 睡眠3秒'</span>.format(func.__name__))</span><br><span class="line">            start = time.time()</span><br><span class="line">            res = func(*args, **kwargs)</span><br><span class="line">            end = time.time()</span><br><span class="line">            print(<span class="string">'类&#123;&#125;用时:&#123;&#125;秒'</span>.format(func.__name__, end - start))</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的对象为类，且带参数</span></span><br><span class="line"><span class="meta">@Decorator('hello')</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.id = args[<span class="number">0</span>]</span><br><span class="line">        self.name = kwargs.get(<span class="string">'name_dict'</span>).get(self.id)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"her name is &#123;&#125;"</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化装饰后的类</span></span><br><span class="line">print(<span class="string">"类名：&#123;&#125;"</span>.format(Foo.func.__name__))</span><br><span class="line">foo = Foo(<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, name_dict=&#123;<span class="string">'1'</span>: <span class="string">'Lucy'</span>, <span class="string">'2'</span>: <span class="string">'Linda'</span>, <span class="string">'3'</span>: <span class="string">'Mary'</span>&#125;)</span><br><span class="line">foo.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator init</span></span><br><span class="line"><span class="string">类名：Foo</span></span><br><span class="line"><span class="string">Hello inner</span></span><br><span class="line"><span class="string">装饰器的参数为：hello</span></span><br><span class="line"><span class="string">装饰器中的功能：Foo 睡眠3秒</span></span><br><span class="line"><span class="string">类Foo用时:0.0秒</span></span><br><span class="line"><span class="string">her name is Lucy</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><ul><li><strong>特殊的装饰器(类静态属性装饰器)</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类静态属性装饰器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, height, weigth)</span>:</span></span><br><span class="line">        self.height = height</span><br><span class="line">        self.weigth = weigth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ratio</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.height / self.weigth</span><br><span class="line"></span><br><span class="line">foo = Foo(<span class="number">176</span>, <span class="number">120</span>)</span><br><span class="line">print(foo.ratio)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为：1.4666666666666666</span></span><br></pre></td></tr></table></figure><blockquote><p>其中，@property是一个特殊的装饰器，把ratio方法变成一个属性，所以调用的时候是foo.ratio而不是foo.ratio()。这类特殊装饰器需要python的特定的属性和机制的支持才可以实现，不同特性的装饰器所需机制不同。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实现@property装饰器效果</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prop</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        self.arg = arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.arg(instance)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用效果与原生的@property装饰器的一样</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, height, weigth)</span>:</span></span><br><span class="line">        self.height = height</span><br><span class="line">        self.weigth = weigth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Prop</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ratio</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.height / self.weigth</span><br><span class="line"></span><br><span class="line">foo = Foo(<span class="number">176</span>, <span class="number">120</span>)</span><br><span class="line">print(foo.ratio)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为：1.4666666666666666</span></span><br></pre></td></tr></table></figure><blockquote><p>经典的装饰器装饰类，通过setattr魔术方法，对Person类进行修改，name作为类属性，<code>name = TypeCheck(name,required_type)</code>，这样修改了Person类，使得Person类有了两个类变量，一个是<code>name = TypeCheck(&#39;name&#39;, required_type)</code>，另一个是<code>age = TypeCheck(&#39;age&#39;, required_type)</code>。</p></blockquote><blockquote><p>因此实例化时<code>Person(&#39;lucy&#39;, 18)</code>，self.name中name不是实例变量而是类变量，会调用描述器TypeCheck，赋值的时候，就会调用<strong>set</strong>方法，取值的时候会调用<strong>get</strong>方法。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 经典的装饰器装饰类</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeCheck</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, srcType, dstType)</span>:</span></span><br><span class="line">        self.srcType = srcType</span><br><span class="line">        self.dstType = dstType</span><br><span class="line"></span><br><span class="line">    <span class="comment"># instance == a, cls == A</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.srcType]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(value, self, dstType):</span><br><span class="line">            instance.__dict__[self.srcType] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'&#123;&#125; should be &#123;&#125;'</span>.format(value, self.dstType))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器自身是一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">type_assert</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wraps</span><span class="params">(*args)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> name, required_type <span class="keyword">in</span> kwargs.items():</span><br><span class="line">                setattr(cls, name, TypeCheck(name, required_type))</span><br><span class="line">            <span class="keyword">return</span> cls(*args)  <span class="comment"># 这里是实例化新的Person类后返回实例对象，也就是p</span></span><br><span class="line">        <span class="keyword">return</span> wraps</span><br><span class="line">    <span class="keyword">return</span> dec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰对象是一个类，且带参数</span></span><br><span class="line"><span class="meta">@type_assert(name=str, age=int)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化新的Person类，这里相对于调用的是wraps函数</span></span><br><span class="line">p = Person(<span class="string">'lucy'</span>, <span class="number">18</span>)</span><br><span class="line">print(p.name)</span><br><span class="line">print(p.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器修改后的Person类为下面这个新的Person类，因此实例化Person的时候，调用的是下面这个新的Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name = TypeCheck(<span class="string">'name'</span>, str)</span><br><span class="line">    age = TypeCheck(<span class="string">'age'</span>, int)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name:str, age:int)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure><ul><li>装饰器顺序</li></ul><blockquote><p>当有两个或两个以上装饰器装饰一个函数时，装饰器是从上到下执行，从下向上装饰，语法糖语句执行流程的顺序是从下往上（就近原则，靠近函数定义的先执行）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个装饰器wrapper1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper1</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"wapper1"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"inner1"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;b&gt;'</span> + func() + <span class="string">'&lt;/b&gt;'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个装饰器wrapper2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper2</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"wapper2"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"inner2"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;i&gt;'</span> + func() + <span class="string">'&lt;/i&gt;'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个装饰器</span></span><br><span class="line"><span class="meta">@wrapper1</span></span><br><span class="line"><span class="meta">@wrapper2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"foo"</span>)</span><br><span class="line">    print(<span class="string">"end"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用装饰后的foo函数</span></span><br><span class="line">res = foo()</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">wapper2</span></span><br><span class="line"><span class="string">wapper1</span></span><br><span class="line"><span class="string">inner1</span></span><br><span class="line"><span class="string">inner2</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">&lt;b&gt;&lt;i&gt;hello&lt;/i&gt;&lt;/b&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>根据结果，函数foo先用wapper2装饰器进行装饰，接着是用wrapper1再进行装饰，但是在调用过程中又是先执行第一个装饰器wrapper1，然后在执行第二个装饰器wrapper2。</p></blockquote><blockquote><p>具体分析其过程，就近原则先用第二个装饰器wrapper2进行装饰，@wrapper2等价于<code>foo = wrapper2(foo)</code>，此时括号内的foo即是函数名，而外部的foo实际指向的是wrapper2的inner。<br>@wrapper1等价于<code>foo = wrapper1(foo)</code>，此时括号内的foo指向的是<code>wrapper2.inner</code>，而外部的foo指向wrapper1的inner。</p></blockquote><blockquote><p>当执行到@wrapper1时要对下面的函数进行装饰，此时解释器继续往下走，发现并不是一个函数名，而又是一个装饰器，这时@wrapper1装饰器暂停执行，而接着执行接下来的装饰器@wrapper2，接着把foo函数名传入到装饰器wrapper2函数func，从而打印”wrapper2”，在wrapper2装饰完后，此时的foo指向wrapper2的inner函数地址，这是又返回来执行@wrapper1，接着把新的foo（即wrapper2.inner）传入wrapper装饰器函数中，因此打印”wrapper1”，在wrapper1装饰完后，此时的foo指向wrapper1的inner函数地址。</p></blockquote><blockquote><p>在调用foo函数的时候，根据上述分析，此时foo指向wrapper1的inner函数地址，故打印”inner1”，接下来调用func()的时候，实际上调用的是wrapper2.inner()函数，所以会打印”inner2”，而wrapper2.inner()函数中，调用的func()才是最初传入的foo函数，所以打印”foo”和”end”，最后一层层调用完后打印的”<code>&lt;b&gt;&lt;i&gt;hello&lt;/i&gt;&lt;/b&gt;</code>“。</p></blockquote><ul><li>通用万能装饰</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_all</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"万能装饰器"</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><h2 id="21-浅拷贝与深拷贝"><a href="#21-浅拷贝与深拷贝" class="headerlink" title="21. 浅拷贝与深拷贝"></a>21. 浅拷贝与深拷贝</h2><blockquote><p>赋值：对象赋值实际上是对象的引用。类似于改名字，内部结构、内存空间地址都一样，赋值给另一个变量的时候，并没有拷贝这个对象，而是拷贝了这个对象的引用。</p></blockquote><blockquote><p>浅拷贝：另开辟新内存空间，只拷贝父结构，没有拷贝子对象，所以原始数据改变，子对象会改变。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line">a.append(<span class="number">5</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果1</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a = [1, 2, 3, ['a', 'b'], 5]</span></span><br><span class="line"><span class="string">b = [1, 2, 3, ['a', 'b']]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 若a的子对象['a', 'b']发生改变</span></span><br><span class="line">a[<span class="number">3</span>].append(<span class="string">'c'</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果2</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a = [1, 2, 3, ['a', 'b', 'c'], 5]</span></span><br><span class="line"><span class="string">b = [1, 2, 3, ['a', 'b', 'c']]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>深拷贝：另开辟新内存空间，拷贝对象里面所有的元素，包括父子任何元素，与原始对象已经无任何关系，所以原始对象改变不会造成深拷贝后任何父子元素的改变。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br><span class="line">c = copy.deepcopy(a)</span><br><span class="line">a.append(<span class="number">5</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果1</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a = [1, 2, 3, ['a', 'b'], 5]</span></span><br><span class="line"><span class="string">c = [1, 2, 3, ['a', 'b']]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 若a的子对象['a', 'b']发生改变，而C始终不变</span></span><br><span class="line">a[<span class="number">3</span>].append(<span class="string">'c'</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果2</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a = [1, 2, 3, ['a', 'b', 'c'], 5]</span></span><br><span class="line"><span class="string">b = [1, 2, 3, ['a', 'b']]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="22-设计模式"><a href="#22-设计模式" class="headerlink" title="22. 设计模式"></a>22. 设计模式</h2><p><strong><a href="https://github.com/weilanhanf/python-design-patterns" target="_blank" rel="noopener">Python 实现23种设计模式</a></strong></p><ul><li>工厂模式</li><li>构造模式</li><li>原型模式</li><li>单例模式</li><li>装饰器模式</li><li>代理模式</li><li>适配器模式</li><li>外观模式</li><li>享元模式</li><li>MVC模式</li><li>惰性计算模式</li><li>迭代器模式</li><li>观察者模式</li><li>策略模式</li></ul><h2 id="23-GIL全局解释器锁"><a href="#23-GIL全局解释器锁" class="headerlink" title="23. GIL全局解释器锁"></a>23. GIL全局解释器锁</h2><p><strong><a href="https://www.oschina.net/translate/pythons-hardest-problem" target="_blank" rel="noopener">Python的底层</a></strong></p><blockquote><p>要理解GIL的含义，我们需要从Python的基础讲起。像C++这样的语言是编译型语言，所谓编译型语言，是指程序输入到编译器，编译器再根据语言的语法进行解析，然后翻译成语言独立的中间表示，最终链接成具有高度优化的机器码的可执行程序。编译器之所以可以深层次的对代码进行优化，是因为它可以看到整个程序（或者一大块独立的部分）。这使得它可以对不同的语言指令之间的交互进行推理，从而给出更有效的优化手段。</p></blockquote><blockquote><p>与此相反，Python是解释型语言。程序被输入到解释器来运行。解释器在程序执行之前对其并不了解；它所知道的只是Python的规则，以及在执行过程中怎样去动态的应用这些规则。它也有一些优化，但是这基本上只是另一个级别的优化。由于解释器没法很好的对程序进行推导，Python的大部分优化其实是解释器自身的优化。更快的解释器自然意味着程序的运行也能“免费”的更快。也就是说，解释器优化后，Python程序不用做修改就可以享受优化后的好处。</p></blockquote><blockquote><p>要想利用多核系统，Python必须支持多线程运行。作为解释型语言，Python的解释器必须做到既安全又高效，但多线程编程会遇到问题，解释器要留意的是避免在不同的线程操作内部共享的数据，同时它还要保证在管理用户线程时保证总是有最大化的计算资源。这时，为了不同线程同时访问时保护数据，当一个线程运行python程序的时候会霸占整个python解释器，也就是给解释器加了一把全局锁，这使得对于任何python程序，不管有多少处理器，多少线程，任何时候都自由一个线程在执行，其他线程在等待正在运行的线程完成才能运行。</p></blockquote><blockquote><p>如果线程运行过程中遇到耗时操作，超时时间超过一个固定值，则单线线程将会解开全局解释器锁，使其他线程运行。所以在多线程中是有先后顺序的，并不是同时运行的。多进程因每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现多个进程同时运行，缺点就是系统资源开销大。</p></blockquote><h2 id="24-函数是一等公民？"><a href="#24-函数是一等公民？" class="headerlink" title="24. 函数是一等公民？"></a>24. 函数是一等公民？</h2><blockquote><p>在python中一切皆对象，num、list、dict、tuple、function、class和模块等都是对象，如公民一样地位平等，可以在运行时创建，并能被赋值给变量，作为集合对象的元素，还能够作为函数的参数和返回值。</p></blockquote><blockquote><p>Python 中函数是一等公民，意思是 Python 中的函数和整数、字符串等常见概念的地位是平等的，一个整数和一个字符串等对象可以干的事，一个函数也可以办到。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    returns n!</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Domo</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">items = [<span class="number">1</span>, <span class="number">1.0</span>, <span class="string">'hello'</span>, [<span class="number">1</span>], &#123;<span class="string">'a'</span>: <span class="number">1</span>&#125;, &#123;<span class="number">1</span>&#125;, factorial, Domo(), re, <span class="literal">None</span>, object]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    print(<span class="string">f'对象 <span class="subst">&#123;item&#125;</span> 的类型是 <span class="subst">&#123;type(item).__name__&#125;</span>,'</span>, <span class="string">f'对象 <span class="subst">&#123;type(item).__name__&#125;</span>类 的类型是 <span class="subst">&#123;type(type(item)).__name__&#125;</span>.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">对象 1 的类型是 int, 对象 int类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 1.0 的类型是 float, 对象 float类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 hello 的类型是 str, 对象 str类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 [1] 的类型是 list, 对象 list类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 &#123;'a': 1&#125; 的类型是 dict, 对象 dict类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 &#123;1&#125; 的类型是 set, 对象 set类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 &lt;function factorial at ...&gt; 的类型是 function, 对象 function类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 &lt;__main__.Dumb object at ...&gt; 的类型是 Dumb, 对象 Dumb类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 &lt;module 're' from 'C:\\...\\re.py'&gt; 的类型是 module, 对象 module类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 None 的类型是 NoneType, 对象 NoneType类 的类型是 type.</span></span><br><span class="line"><span class="string">对象 &lt;class 'object'&gt; 的类型是 type, 对象 type类 的类型是 type</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    print(<span class="string">f'类对象 <span class="subst">&#123;item.__class__.__name__&#125;</span> 的基类是: <span class="subst">&#123;item.__class__.__bases__&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'类对象 <span class="subst">&#123;object.__name__&#125;</span> 的基类是: <span class="subst">&#123;object.__bases__&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">类对象 int 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 float 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 str 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 list 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 dict 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 set 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 function 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 Dumb 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 module 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 NoneType 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 type 的基类是: (&lt;class 'object'&gt;,)</span></span><br><span class="line"><span class="string">类对象 object 的基类是: ()</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="25-函数与方法的区别"><a href="#25-函数与方法的区别" class="headerlink" title="25. 函数与方法的区别"></a>25. 函数与方法的区别</h2><blockquote><p>函数的本质是FunctionObject，其中包括内置函数、匿名函数、递归函数、自定义函数。<br>函数的作用域是从函数调用开始至函数执行完成，返回给调用者后，在执行过程中开辟的空间会自动释放，即函数执行完成后，函数体内部通过赋值等方式修改变量的值不会保留，会随着返回给调用者后，开辟的空间自动释放。<br>函数通过”函数名()”形式调用。</p></blockquote><blockquote><p>方法的本质是PyMethodObject，其中包括普通方法（直接用self调用的方法）、私有方法（<strong>函数名,只能在类中被调用的方法）、属性方法（@property，将方法伪装成属性）、特殊方法（`</strong>init__, <strong>call</strong>,<strong>getattr</strong>`等）、类方法、静态方法。<br>方法的作用域是通过实例化的对象进行方法的调用，调用后开辟的空间不会释放，即调用方法中对变量的修改值会一直保留。<br>方法是通过”对象.方法名”的方式进行调用。</p></blockquote><h2 id="26-range与Xrange的区别"><a href="#26-range与Xrange的区别" class="headerlink" title="26. range与Xrange的区别"></a>26. range与Xrange的区别</h2><blockquote><p>range()是Python的内置函数，用于创建整数的列表，可以生成递减或者递增的数列。<br>用法：<code>range(start, stop, step)</code>，生成一个序列。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3下的range，其实已经把xrange合并过来了</span></span><br><span class="line">x = range(<span class="number">0</span>，<span class="number">5</span>)</span><br><span class="line">print(type(x))</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python3结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;class 'range'&gt;</span></span><br><span class="line"><span class="string">range(0, 5)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python2结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;type 'list'&gt;</span></span><br><span class="line"><span class="string">[0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>xrange()在python3中已经移除，xrange用法与range完全相同，但是得到的是一个生成器对象，惰性求值，xrange()函数比range()函数更快。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xrange</span></span><br><span class="line">x = xrange(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">print(type(xrange(<span class="number">0</span>, <span class="number">5</span>)))</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;class 'range'&gt;</span></span><br><span class="line"><span class="string">range(0, 5)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="27-search与match的区别"><a href="#27-search与match的区别" class="headerlink" title="27. search与match的区别"></a>27. search与match的区别</h2><blockquote><p>search()函数会在整个字符串内查找模式匹配，直到找到第一个匹配，然后返回一个包含匹配信息的对象，该对象可以通过group()方法得到匹配的字符串，如果没有字符串没有匹配到，则返回None。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">print(re.search(<span class="string">"time"</span>, <span class="string">"datetime"</span>))</span><br><span class="line">print(re.search(<span class="string">"time"</span>, <span class="string">"datetime"</span>).span())</span><br><span class="line">print(re.search(<span class="string">"time1"</span>, <span class="string">"datetime"</span>))</span><br><span class="line">print(re.search(<span class="string">"hello"</span>, <span class="string">"hihelloworld"</span>).span())</span><br><span class="line">print(re.search(<span class="string">"hello"</span>, <span class="string">"hihelloworld"</span>).group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;re.Match object; span=(4, 8), match='time'&gt;</span></span><br><span class="line"><span class="string">(4, 8)</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">(2, 7)</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>match()函数只检测字符串开头位置是否匹配，匹配成功才会返回结果，否则返回None。</p></blockquote><ul><li>group() 返回被 RE 匹配的字符串</li><li>start() 返回匹配开始的位置</li><li>end() 返回匹配结束的位置</li><li>span()返回一个元组包含匹配 (开始,结束) 的位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">print(re.match(<span class="string">"time"</span>, <span class="string">"datetime"</span>))</span><br><span class="line">print(re.match(<span class="string">"time"</span>, <span class="string">"timedate"</span>))</span><br><span class="line">print(re.match(<span class="string">"time"</span>, <span class="string">"timedate"</span>).span())</span><br><span class="line">print(re.match(<span class="string">"time"</span>, <span class="string">"timedate"</span>).group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">&lt;re.Match object; span=(0, 4), match='time'&gt;</span></span><br><span class="line"><span class="string">(0, 4)</span></span><br><span class="line"><span class="string">time</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="28-面向对象编程OOP"><a href="#28-面向对象编程OOP" class="headerlink" title="28. 面向对象编程OOP"></a>28. 面向对象编程OOP</h2><blockquote><p>面向对象编程OOP（Object Oriented Programming）是一种程序设计思想，把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。面向对象的程序设计过程吧计算机程序视为一组对象的集合，而每个对象都可以接受其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在对象之间传递。</p></blockquote><blockquote><p>在Python中，一切皆对象，当然也可以自定义对象。自定义对象的数据类型就是面向对象中的类的概念，面向对象的设计思想是抽象出类(Class)，根据类(Class)创建实例(instance)。面向对象的抽象程度又比函数要高，因为一个类(Class)既包含数据又包含操作数据的方法。</p></blockquote><blockquote><p>面向对象的三大特性：封装、继承、多态。</p></blockquote><h2 id="29-面向切面编程AOP"><a href="#29-面向切面编程AOP" class="headerlink" title="29. 面向切面编程AOP"></a>29. 面向切面编程AOP</h2><blockquote><p>AOP(Aspect Oriented Programming)是一种编程方式，就是在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</p></blockquote><blockquote><p>AOP主要作用就是将类似于日志记录，性能统计，安全控制，事务处理，异常处理等重复性的代码块从业务逻辑代码中划分出来，对这些行为的分离。并且将它们独立到非知道业务逻辑的方法中，从而做到改变这些行为的时候不影响业务逻辑代码。</p></blockquote><blockquote><p>AOP带来的优点：</p></blockquote><ul><li>降低系统的反复代码</li><li>降低模块间的耦合度</li><li>提高系统可扩展性</li><li>增加代码可维护性</li></ul><blockquote><p>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，装饰器的作用就是为已经存在的对象添加额外的功能，所以python中使用装饰器实现AOP。</p></blockquote><h2 id="30-封装"><a href="#30-封装" class="headerlink" title="30. 封装"></a>30. 封装</h2><p><strong><a href="https://blog.csdn.net/max_like/article/details/81346484" target="_blank" rel="noopener">python 类的封装</a></strong></p><blockquote><p>面向对象编程的一个重要特点就是数据封装。类的封装包含数据封装、方法封装、属性封装。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据封装，将程序中需要的数据按照统一的格式封装在类型的内部，通过该类型的对象包装使用数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法封装，函数和方法混合开发，  处理和某个数据关联的功能-&gt; 功能代码封装成函数，将函数封装在类型中处理具体功能的方法，就和对应的数据强制关联，方便统一管理维护</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">student = Student(<span class="string">"张三"</span>, <span class="string">"18"</span>, get_name())</span><br></pre></td></tr></table></figure><ul><li><strong>属性封装</strong>(重点重点重点)</li></ul><blockquote><p>属性是属于对象的特征，对象的特征是属于对象的数据，对象的数据一般不让外界直接访问。但是默认<code>self.name</code>不做任何添加的是公共的public，允许内部和外部的访问。</p></blockquote><blockquote><p>受保护的protected：在对象成员前面加一个下划线<code>self._name</code>，允许类中或子类中都可以进行访问，但外部不可以访问。</p></blockquote><blockquote><p>私有的private：在成员前面添加两个下划线<code>self.__name</code>，私有成员是高级别的封装，只有当前类对象自己能访问，连子类对象也不能访问到这个数据。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 属性封装的装饰器(https://blog.csdn.net/MrNoboday/article/details/89371430)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = <span class="number">0</span></span><br><span class="line">        self.__gender = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property  # 只读</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.__age == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"you haven't set age!"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gender</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.__gender <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">"you haven't set gender!"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.__gender</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter  # 只写</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt; age &lt; <span class="number">120</span>:</span><br><span class="line">            self.__age = age</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"age set failure!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @gender.setter  # 只写</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gender</span><span class="params">(self, gender)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> gender.lower() <span class="keyword">in</span> [<span class="string">'man'</span>, <span class="string">'wowan'</span>]:</span><br><span class="line">            self.__gender = gender.lower()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'gender set failure!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    user = User(<span class="string">'zhangsan'</span>)</span><br><span class="line">    print(<span class="string">'name:'</span>, user.name, <span class="string">'gender:'</span>, user.gender, <span class="string">'age:'</span>,user.age)</span><br><span class="line">    user.age = <span class="number">18</span></span><br><span class="line">    user.gender = <span class="string">'man'</span></span><br><span class="line">    print(<span class="string">'name:'</span>, user.name, <span class="string">'gender:'</span>, user.gender, <span class="string">'age:'</span>,user.age)</span><br><span class="line">    user.age = <span class="number">1000</span></span><br><span class="line">    user.gender = <span class="string">'double'</span></span><br><span class="line">    print(<span class="string">'name:'</span>, user.name, <span class="string">'gender:'</span>, user.gender, <span class="string">'age:'</span>,user.age)</span><br><span class="line">    user.age = <span class="number">99</span>  <span class="comment"># 这里用了@property装饰器把方法变成属性调用的，所以直接赋值</span></span><br><span class="line">    print(<span class="string">"间接修改的年龄: %s"</span> % user.age)</span><br><span class="line">    print(user._User__age = <span class="number">88</span>)</span><br><span class="line">    print(<span class="string">"直接修改的年龄: %s"</span> % user.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">you haven't set gender!</span></span><br><span class="line"><span class="string">you haven't set age!</span></span><br><span class="line"><span class="string">name: zhangsan gender: None age: None</span></span><br><span class="line"><span class="string">name: zhangsan gender: man age: 18</span></span><br><span class="line"><span class="string">age set failure!</span></span><br><span class="line"><span class="string">gender set failure!</span></span><br><span class="line"><span class="string">name: zhangsan gender: man age: 18</span></span><br><span class="line"><span class="string">间接修改的年龄: 99</span></span><br><span class="line"><span class="string">直接修改的年龄: 88</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>可以通过属性封装的装饰器去更改私有变量的值。当然还有两种常用的方法：</p></blockquote><ul><li>间接：为这个私有变量提供一个操作方法，如<code>def age(self, age)</code></li><li>直接：实例名._类名<strong>私有变量名 = 值，如`user_User</strong>age = 100`</li></ul><h2 id="31-继承"><a href="#31-继承" class="headerlink" title="31. 继承"></a>31. 继承</h2><blockquote><p>继承是一种创建新类的方式，新创建的类加子类，继承的叫父类、超类、基类。继承是类与类之间的关系，继承的作用是减少代码冗余、提高重用性。</p></blockquote><blockquote><p>继承的特征：所有的类都继承自object类，即所有的类都是object类的子类；<br>            子类一旦继承父类，则可以使用父类中除了私有成员外的所有内容；<br>            子类继承父类后，并没有捡父类成员完全复制到子类中，而是通过引用关系访问调用；<br>            子类可以定义独有的成员属性和方法；<br>            子类中定义的成员和父类成员如果同名，则优先使用子类成员；<br>            子类如果想扩充父类的方法，可以再定义新方法的同时访问父类的成员进行代码重用；</p></blockquote><ul><li>单继承</li></ul><blockquote><p>每个类只能继承一个类，优点是传承有序、逻辑清晰、语法简单、隐患少；缺点是功能不能无限扩展，只能在当前唯一的继承链中扩展。</p></blockquote><ul><li>多继承</li></ul><blockquote><p>每个类允许继承多个类，优点是类功能扩展方便；缺点是继承关系混乱。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swim</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am swimming..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am flying..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am working..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alien</span><span class="params">(Fish, Bird, Person)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">print(<span class="string">"="</span> * <span class="number">10</span> + <span class="string">" 单继承 "</span> + <span class="string">"="</span> * <span class="number">10</span>)</span><br><span class="line">student = Student(<span class="string">"zhangsan"</span>)</span><br><span class="line">student.work()</span><br><span class="line">print(<span class="string">"="</span> * <span class="number">10</span> + <span class="string">" 多继承 "</span> + <span class="string">"="</span> * <span class="number">10</span>)</span><br><span class="line">alien = Alien(<span class="string">"&amp;%$#^@"</span>)</span><br><span class="line">alien.swim()</span><br><span class="line">alien.fly()</span><br><span class="line">alien.work()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">========== 单继承 ==========</span></span><br><span class="line"><span class="string">I am working...</span></span><br><span class="line"><span class="string">========== 多继承 ==========</span></span><br><span class="line"><span class="string">I am swimming...</span></span><br><span class="line"><span class="string">I am flying...</span></span><br><span class="line"><span class="string">I am working...</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>继承变量函数的查找顺序：<br>    优先查找自己的变量，没有则继续往上（父类）查找；构造函数如果本类中没定义，则自动查找调用父类构造函数，如果本类中有定义，则不用继续向上查找。</p></blockquote><blockquote><p>构造函数：是一类特使的函数，在类进行实例化之前调用，如果定义了构造函数，则实例化的时候使用此构造函数，而不查找父类构造函数；如果没有定义构造函数，则自动向上查找父类构造函数；如果子类没有定义构造函数，而父类的构造函数带参数，则实例化子类时，应该按父类构造函数参数进行传参。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span><span class="params">(Animal)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">"我是一只宠物 %s"</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Pet)</span>:</span></span><br><span class="line">    <span class="comment"># __init__就是构造函数，记住一定要有这个参数</span></span><br><span class="line">    <span class="comment"># 每次进行实例化的时候，第一个被自动调用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"我初始化为一只小狗"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化的时候，括号内的参数要与构造函数的参数匹配</span></span><br><span class="line">dog = Dog()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Pet)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Cat类中，没有找到构造函数，自动从继承的父类Pet中查找</span></span><br><span class="line">cat = Cat(<span class="string">"嘟嘟"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">我初始化为一只小狗</span></span><br><span class="line"><span class="string">我是一只宠物 嘟嘟</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>super<br>    不是一个关键数字，而是一个类。super的作用是获取MRO（Method Resolution Order）方法解析顺序列表中的第一个类，而这个类往往就是它的父类，和父类没有任何实质性关系，可以用super()调用父类的初始化构造函数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">print(type(super))</span><br><span class="line">help(super)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;class 'type'&gt;</span></span><br><span class="line"><span class="string">Help on class super in module builtins:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class super(object)</span></span><br><span class="line"><span class="string"> |  super() -&gt; same as super(__class__, &lt;first argument&gt;)</span></span><br><span class="line"><span class="string"> |  super(type) -&gt; unbound super object</span></span><br><span class="line"><span class="string"> |  super(type, obj) -&gt; bound super object; requires isinstance(obj, type)</span></span><br><span class="line"><span class="string"> |  super(type, type2) -&gt; bound super object; requires issubclass(type2, type)</span></span><br><span class="line"><span class="string"> |  Typical use to call a cooperative superclass method:</span></span><br><span class="line"><span class="string"> |  class C(B):</span></span><br><span class="line"><span class="string"> |      def meth(self, arg):</span></span><br><span class="line"><span class="string"> |          super().meth(arg)</span></span><br><span class="line"><span class="string"> |  This works for class methods too:</span></span><br><span class="line"><span class="string"> |  class C(B):</span></span><br><span class="line"><span class="string"> |      @classmethod</span></span><br><span class="line"><span class="string"> |      def cmeth(cls, arg):</span></span><br><span class="line"><span class="string"> |          super().cmeth(arg)</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  Methods defined here:</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  __get__(self, instance, owner, /)</span></span><br><span class="line"><span class="string"> |      Return an attribute of instance, which is of type owner.</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  __getattribute__(self, name, /)</span></span><br><span class="line"><span class="string"> |      Return getattr(self, name).</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  __init__(self, /, *args, **kwargs)</span></span><br><span class="line"><span class="string"> |      Initialize self.  See help(type(self)) for accurate signature.</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  __repr__(self, /)</span></span><br><span class="line"><span class="string"> |      Return repr(self).</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  ----------------------------------------------------------------------</span></span><br><span class="line"><span class="string"> |  Static methods defined here:</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  __new__(*args, **kwargs) from builtins.type</span></span><br><span class="line"><span class="string"> |      Create and return a new object.  See help(type) for accurate signature.</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  ----------------------------------------------------------------------</span></span><br><span class="line"><span class="string"> |  Data descriptors defined here:</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  __self__</span></span><br><span class="line"><span class="string"> |      the instance invoking super(); may be None</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  __self_class__</span></span><br><span class="line"><span class="string"> |      the type of the instance invoking super(); may be None</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  __thisclass__</span></span><br><span class="line"><span class="string"> |      the class invoking super()</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>菱形继承/钻石继承问题：<br>    （1）多个子类继承自同一个父类，这些子类又被同一个类继承，于是继承关系图形成了一个菱形图谱。<br>    （2）多继承的MRO用于保存继承顺序的一个列表，MRO列表的计算原则：子类永远在父类前面；如果多个父类，则根据继承语法中括号内的书写顺序存放；如果多个类继承了同一个父类，孙子类中只会选取继承语法括号中的第一个父类的父类。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(D.__mro__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>派生类：派生就是子类在继承父类的基础上衍生出新的属性，子类中独有的，父类中没有的；或子类定义与父类重名的东西，子类有不同于父类的属性，这个子类叫做派生类。通常情况下，子类和派生类是同一个概念，因为子类都是有不同于父类的属性，如果子类和父类属性相同，就没必要创建子类了。</p></blockquote><h2 id="32-多态与多态性"><a href="#32-多态与多态性" class="headerlink" title="32. 多态与多态性"></a>32. 多态与多态性</h2><blockquote><p>多态：指的是以类事物有多种形态，如一个抽象类有多个子类，多态的概念依赖于继承；如在java中，一个函数由于函数签名不同，可以有同名的不同函数存在，调用的时候根据函数签名不同自动找到相应的函数执行。简单来说，就是同一事物的多种形态。Python中的多态不是语法，而是一种设计思想，多态的设计就是要完成对不同类型对象使用相同方法调用能得到各自期望的结果。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多态：同一种事物的多种形态，动物分为人、猪、狗等等</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">'子类必须实现这个方法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'人正在走'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'猪正在散步'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'狗正在走'</span>)</span><br><span class="line"></span><br><span class="line">people = People()</span><br><span class="line">pig = Pig()</span><br><span class="line">dog = Dog()</span><br><span class="line"></span><br><span class="line">people.run()</span><br><span class="line">pig.run()</span><br><span class="line">dog.run()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">人正在走</span></span><br><span class="line"><span class="string">猪正在散步</span></span><br><span class="line"><span class="string">狗正在走</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同一类事物：文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span> </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件的形态之一：文本文件 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span><span class="params">(File)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'open file'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#文件的形态之二：可执行文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExeFile</span><span class="params">(File)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'execute file'</span>)</span><br><span class="line"></span><br><span class="line">text = Text()</span><br><span class="line">exefile = ExeFile()</span><br><span class="line"></span><br><span class="line">text.click()</span><br><span class="line">exefile.click()</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">open file</span></span><br><span class="line"><span class="string">execute file</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>多态性：指具有不同功能的函数可以使用相同的函数名，这样可以用一个函数名调用不同内容的函数（如向不同的对象发送同一条消息，不同的对象接受时会执行不同的行为）。简单来说，就是一种调用方式，产生不同的执行效果。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多态性：一种调用方式，不同的执行效果（多态性）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">'子类必须实现这个方法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'人正在走'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'猪正在散步'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'狗正在走'</span>)</span><br><span class="line"></span><br><span class="line">people = People()</span><br><span class="line">pig = Pig()</span><br><span class="line">dog = Dog()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多态性：定义统一的接口</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(obj)</span>:</span>  <span class="comment"># obj这个参数没有类型限制，可以传入不同类型的值</span></span><br><span class="line">    obj.run()  <span class="comment"># 调用的逻辑都一样，执行的结果却不一样</span></span><br><span class="line"></span><br><span class="line">func(people)</span><br><span class="line">func(pig)</span><br><span class="line">func(dog)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">人正在走</span></span><br><span class="line"><span class="string">猪正在散步</span></span><br><span class="line"><span class="string">狗正在走</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多态性</span></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同一类事物：文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span> </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件的形态之一：文本文件 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span><span class="params">(File)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'open file'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#文件的形态之二：可执行文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExeFile</span><span class="params">(File)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'execute file'</span>)</span><br><span class="line"></span><br><span class="line">text = Text()</span><br><span class="line">exefile = ExeFile()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(f)</span>:</span></span><br><span class="line">    f.click()</span><br><span class="line"></span><br><span class="line">func(text)</span><br><span class="line">func(exefile)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">open file</span></span><br><span class="line"><span class="string">execute file</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>多态性的好处：<br>    - 增加了程序的灵活性<br>    - 增加程序的可扩展性</p></blockquote><h2 id="33-重载"><a href="#33-重载" class="headerlink" title="33. 重载"></a>33. 重载</h2><p><strong><a href="https://blog.csdn.net/qq_37049781/article/details/83959365" target="_blank" rel="noopener">python 中的重载</a></strong></p><blockquote><p>在Python中，具有重载的思想却没有重载的概念。实际上，Python编程中具有重载的目的却无重载的行为，或者说python并不需要重载。python是一门动态语言，不需要声明变量类型，函数中可以接受任何类型的参数也就无法根据参数类型来支持重载，python没有必要去考虑参数的类型问题，这些都可以在函数内部判断处理，并无必要去在写一个函数。python 有多种传参方式，默认参数、可变参数、可变关键字参数，可以处理函数参数中参数可变的问题。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3.4 中提供的一个转发机制来实现重载</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch  # 只支持根据第一个参数的类型来重载，不支持多参数重载</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">(obj)</span>:</span>  <span class="comment"># 被重载的函数</span></span><br><span class="line">    print(<span class="string">'%r'</span> % (obj))</span><br><span class="line"></span><br><span class="line"><span class="meta">@function.register(int)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_int</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">'Integer: %d'</span> % (obj))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@function.register(str)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_str</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">'String: %s'</span> % (obj))</span><br><span class="line"></span><br><span class="line"><span class="meta">@function.register(list)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_list</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">'List: %r'</span> % (obj))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    function(<span class="number">1</span>)</span><br><span class="line">    function(<span class="string">'hello'</span>) </span><br><span class="line">    function(range(<span class="number">3</span>)) </span><br><span class="line">    function(object)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Integer: 1</span></span><br><span class="line"><span class="string">String: hello</span></span><br><span class="line"><span class="string">range(0, 3)</span></span><br><span class="line"><span class="string">&lt;class 'object'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>重载是对继承的父类方法进行重新定义，重载可以重新定义方法还可以重新定义运算符。因为通过继承的类不一定能满足当前类的需求，在当前类中只需要修改部分内容而达到自己的需求。</p></blockquote><blockquote><p>重载的特点：<br>    - 减少代码量和灵活指定型类<br>    - 子类具有父类的方法和属性<br>    - 子类不能继承父类的私有方法或属性<br>    - 子类可以添加新的方法<br>    - 子类可以修改父类的方法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法重载</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span><span class="params">(object)</span>:</span></span><br><span class="line">    __name = <span class="string">''</span>  <span class="comment"># 定义属性</span></span><br><span class="line">    __sex = <span class="number">0</span></span><br><span class="line">    __age = <span class="number">0</span></span><br><span class="line">    __height = <span class="number">0</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sex, age, height, weight)</span>:</span></span><br><span class="line">        self.__sex = sex</span><br><span class="line">        self.__age = age</span><br><span class="line">        self.__height = height</span><br><span class="line">        self.__weight = weight</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.__name, self.__sex, self.__age, self.__height, self.__weight)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Human)</span>:</span></span><br><span class="line">    __classes = <span class="number">0</span></span><br><span class="line">    __grade = <span class="number">0</span></span><br><span class="line">    __num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, classes, grade, num, sex, age, height, weight)</span>:</span>  <span class="comment"># 重载 __init__方法</span></span><br><span class="line">        self.__classes = classes</span><br><span class="line">        self.__grade = grade</span><br><span class="line">        self.__num = num</span><br><span class="line">        Human.__init__(self, sex, age, height, weight)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span>  <span class="comment"># 重载 show 方法</span></span><br><span class="line">        Human.show(self)</span><br><span class="line">        print(self.__classes, self.__grade, self.__num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Student(<span class="number">3</span>, <span class="number">2</span>, <span class="number">19990520</span>, <span class="string">'男'</span>, <span class="number">20</span>, <span class="string">'172'</span>, <span class="number">55</span>)</span><br><span class="line">    s.set_name(<span class="string">'小明'</span>)</span><br><span class="line">    s.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">小明 男 20 172 55</span></span><br><span class="line"><span class="string">3 2 19990520</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>运算符重载是在类方法中拦截内置的操作——当类的实例出现在内置操作中，Python自动调用重新定义的方法，并将重新定义方法的返回值变成了相应操作的结果。</p></blockquote><blockquote><p>python对运算符重载的一些限制：</p></blockquote><ul><li>不能重载内置类型的运算符</li><li>不能新建运算符，只能重载现有的</li><li>某些运算符不是重载：is、and、or、not</li></ul><p><strong><a href="https://www.cnblogs.com/laolibk/p/8011472.html" target="_blank" rel="noopener">Python中运算符重载</a></strong><br><strong><a href="https://www.cnblogs.com/lht-record/p/10306591.html" target="_blank" rel="noopener">《流畅的python》</a></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运算符重载</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span><span class="params">(object)</span>:</span></span><br><span class="line">    __list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span>  <span class="comment"># 重载 __init__ 方法</span></span><br><span class="line">        self.__list = []</span><br><span class="line">        <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">            self.__list.append(arg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, n)</span>:</span>  <span class="comment"># 重载加法"+"运算符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(self.__list)):</span><br><span class="line">            self.__list[i] +=n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self, n)</span>:</span>  <span class="comment"># 重载减法"-"运算符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(self.__list)):</span><br><span class="line">            self.__list[i] -= n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, n)</span>:</span>  <span class="comment"># 重载乘法"*"运算符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(self.__list)):</span><br><span class="line">            self.__list[i] *= n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__turediv__</span><span class="params">(self, n)</span>:</span>  <span class="comment"># 重载除法"/"运算符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(self.__list)):</span><br><span class="line">            self.__list[i] /= n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__floordiv__</span><span class="params">(self, n)</span>:</span>  <span class="comment"># 重载整除"//"运算符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(self.__list)):</span><br><span class="line">            self.__list[i] //= n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mod__</span><span class="params">(self, n)</span>:</span>  <span class="comment"># 重载求余"%"运算符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(self.__list)):</span><br><span class="line">            self.__list[i] %= n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__pow__</span><span class="params">(self, n)</span>:</span>  <span class="comment"># 重载次幂"**"运算符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(self.__list)):</span><br><span class="line">            self.__list[i] **= n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.__list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data_list = List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">    data_list.show()</span><br><span class="line"></span><br><span class="line">    data_list + <span class="number">2</span></span><br><span class="line">    data_list.show()</span><br><span class="line"></span><br><span class="line">    data_list - <span class="number">2</span></span><br><span class="line">    data_list.show()</span><br><span class="line"></span><br><span class="line">    data_list * <span class="number">2</span></span><br><span class="line">    data_list.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># data_list / 2</span></span><br><span class="line">    <span class="comment"># data_list.show()</span></span><br><span class="line"></span><br><span class="line">    data_list // <span class="number">2</span></span><br><span class="line">    data_list.show()</span><br><span class="line"></span><br><span class="line">    data_list % <span class="number">2</span></span><br><span class="line">    data_list.show()</span><br><span class="line"></span><br><span class="line">    data_list ** <span class="number">2</span></span><br><span class="line">    data_list.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="string">[3, 4, 5, 6, 7, 8, 9, 10, 11]</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="string">[2, 4, 6, 8, 10, 12, 14, 16, 18]</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="string">[1, 0, 1, 0, 1, 0, 1, 0, 1]</span></span><br><span class="line"><span class="string">[1, 0, 1, 0, 1, 0, 1, 0, 1]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>一元运算符重载:</p></blockquote><table><thead><tr><th align="center">名称</th><th align="left">运算符</th><th align="left">方法</th></tr></thead><tbody><tr><td align="center">取正</td><td align="left">+</td><td align="left"><code>__pos__</code></td></tr><tr><td align="center">取负</td><td align="left">-</td><td align="left"><code>__neg__</code></td></tr><tr><td align="center">按位取反</td><td align="left">~</td><td align="left"><code>__invert__</code></td></tr><tr><td align="center">取绝对值</td><td align="left">`</td><td align="left"></td></tr></tbody></table><blockquote><p>常见的算术运算符重载：</p></blockquote><table><thead><tr><th align="center">名称</th><th align="left">运算符</th><th align="left">正向方法</th><th align="center">反向方法</th><th align="center">就地方法</th></tr></thead><tbody><tr><td align="center">加法</td><td align="left">+</td><td align="left"><code>__add__</code></td><td align="center"><code>__radd__</code></td><td align="center"><code>__iadd__</code></td></tr><tr><td align="center">减法</td><td align="left">-</td><td align="left"><code>__sub__</code></td><td align="center"><code>__rsub__</code></td><td align="center"><code>__isub__</code></td></tr><tr><td align="center">乘法</td><td align="left">*</td><td align="left"><code>__mul__</code></td><td align="center"><code>__rmul__</code></td><td align="center"><code>__imul__</code></td></tr><tr><td align="center">除法</td><td align="left">/</td><td align="left"><code>__truediv__</code></td><td align="center"><code>__rtruediv__</code></td><td align="center"><code>__itruediv__</code></td></tr><tr><td align="center">整除</td><td align="left">//</td><td align="left"><code>__floordiv__</code></td><td align="center"><code>__rfloordiv__</code></td><td align="center"><code>__ifloordiv__</code></td></tr><tr><td align="center">求余</td><td align="left">%</td><td align="left"><code>__mod__</code></td><td align="center"><code>__rmod__</code></td><td align="center"><code>__imod__</code></td></tr><tr><td align="center">次幂</td><td align="left">**</td><td align="left"><code>__pow__</code></td><td align="center"><code>__rpow__</code></td><td align="center"><code>__ipow__</code></td></tr></tbody></table><blockquote><p>位操作运算符重载：</p></blockquote><table><thead><tr><th align="center">名称</th><th align="left">运算符</th><th align="left">正向方法</th><th align="center">反向方法</th><th align="center">就地方法</th></tr></thead><tbody><tr><td align="center">位与</td><td align="left">&amp;</td><td align="left"><code>__and__</code></td><td align="center"><code>__rand__</code></td><td align="center"><code>__iand__</code></td></tr><tr><td align="center">位或</td><td align="left">`</td><td align="left">`</td><td align="center"><code>__or__</code></td><td align="center"><code>__ror__</code></td></tr><tr><td align="center">位异或</td><td align="left">^</td><td align="left"><code>__xor__</code></td><td align="center"><code>__rxor__</code></td><td align="center"><code>__ixor__</code></td></tr><tr><td align="center">左移</td><td align="left">&lt;&lt;</td><td align="left"><code>__lshift__</code></td><td align="center"><code>__rlshift__</code></td><td align="center"><code>__ilshift__</code></td></tr><tr><td align="center">右移</td><td align="left">&gt;&gt;</td><td align="left"><code>__rshift__</code></td><td align="center"><code>__rrshift__</code></td><td align="center"><code>__irshift__</code></td></tr></tbody></table><blockquote><p>比较运算符重载：</p></blockquote><table><thead><tr><th align="center">名称</th><th align="left">运算符</th><th align="left">正向方法</th><th align="center">反向方法</th><th align="center">后备机制</th></tr></thead><tbody><tr><td align="center">相等</td><td align="left">a == b</td><td align="left"><code>a.__eq__(b)</code></td><td align="center"><code>b.__eq__(a)</code></td><td align="center">返回id(a) == id(b)</td></tr><tr><td align="center">不相等</td><td align="left">a ！= b</td><td align="left"><code>a.__ne__(b)</code></td><td align="center"><code>b.__ne__(a)</code></td><td align="center">返回not (a == b)</td></tr><tr><td align="center">大于</td><td align="left">a &gt; b</td><td align="left"><code>a.__gt__(b)</code></td><td align="center"><code>b.__gt__(a)</code></td><td align="center">抛出TypeError</td></tr><tr><td align="center">大于等于</td><td align="left">a &gt;= b</td><td align="left"><code>a.__ge__(b)</code></td><td align="center"><code>b.__ge__(a)</code></td><td align="center">抛出TypeError</td></tr><tr><td align="center">小于</td><td align="left">a &lt; b</td><td align="left"><code>a.__lt__(b)</code></td><td align="center"><code>b.__lt__(a)</code></td><td align="center">抛出TypeError</td></tr><tr><td align="center">小于等于</td><td align="left">a &lt;= b</td><td align="left"><code>a.__le__(b)</code></td><td align="center"><code>b.__le__(a)</code></td><td align="center">抛出TypeError</td></tr></tbody></table><blockquote><p>内建函数重载：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(obj)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__reversed__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reversed(obj)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__round__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> round(obj)</span><br></pre></td></tr></table></figure><blockquote><p>数值转换函数重载：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__int__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(obj)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__float__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> float(obj)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__complex__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> complex(obj)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bool(obj)</span><br></pre></td></tr></table></figure><blockquote><p>成员资格函数in、not in运算符重载</p></blockquote><p><code>def __contains__(self, e)</code></p><blockquote><p>索引和切片运算符重载</p></blockquote><p><code>__getitrm__(self, i)</code>方法<br><code>__setitrm__(self, i, v)</code>方法<br><code>__delitrm__(self, i)</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Indexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> index ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">x = Indexer()</span><br><span class="line">print(x[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>迭代对象重载：</p></blockquote><p><code>__next__(self)</code> 迭代器<br><code>__iter__(self)</code>可迭代对象</p><blockquote><p>with环境管理器类内重载:</p></blockquote><p><code>__enter__</code> 方法将在进入 with 语句时被调用返回由 as 变量管理的对象。<br><code>__exit__</code> 方法将在离开with语句时被调用，且可以用参数来判断离开with语句时是否有异常发生并作出相应的处理。</p><blockquote><p>属性相关方法重载</p></blockquote><p><code>__getattr__</code>属性获取<br><code>__setattr__</code>属性赋值<br><code>__delattr__</code>属性删除</p><blockquote><p>其他</p></blockquote><table><thead><tr><th align="center">方法</th><th align="left">重载</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center"><code>__init__</code></td><td align="left">构造函数</td><td align="left">对象创建: <code>X = Class(args)</code></td></tr><tr><td align="center"><code>__new__</code></td><td align="left">创建</td><td align="left">在<strong>init</strong>之前创建对象</td></tr><tr><td align="center"><code>__call__</code></td><td align="left">函数调用</td><td align="left"><code>X(*args, **kwargs)</code></td></tr><tr><td align="center"><code>__repr__, __str__</code></td><td align="left">打印，转换</td><td align="left"><code>print(X)，repr(X)，str(X)</code></td></tr><tr><td align="center"><code>__del__</code></td><td align="left">析构函数</td><td align="left">对X对象收回</td></tr></tbody></table><h2 id="34-函数式编程"><a href="#34-函数式编程" class="headerlink" title="34. 函数式编程"></a>34. 函数式编程</h2><blockquote><p>函数是Python内建支持的一种封装，通过把打断代码拆层函数，通过一层层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p></blockquote><blockquote><p>函数式编程（Hunctingal Programming）虽然可以归结到面向过程的程序设计，但其思想更接近数学计算。函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，这种函数是有副作用的。</p></blockquote><blockquote><p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数。Python对函数是编程仅提供部分支持，由于Python允许提供变量，因此python不是纯函数式编程语言。</p></blockquote><h2 id="35-python中的高阶函数"><a href="#35-python中的高阶函数" class="headerlink" title="35. python中的高阶函数"></a>35. python中的高阶函数</h2><blockquote><p>高阶函数：一个函数可以作为参数传给另外一个函数，或者一个函数的返回值为另外一个函数（若返回值为该函数本身，则为递归），满足其一则为高阶函数。</p></blockquote><ul><li>abs</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python内置的绝对值函数</span></span><br><span class="line">a = abs(<span class="number">-10</span>)  <span class="comment"># 直接调用abs()函数</span></span><br><span class="line">f = abs  <span class="comment"># 函数本身赋值给变量，即变量指向函数</span></span><br><span class="line">b = f(<span class="number">-10</span>)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><ul><li>map</li></ul><blockquote><p>map()函数会根据的函数对指定的序列做映射。<br>map()函数语法：<code>map(function, iterable, ...)</code>，其中第一个参数function表示对序列每个元素进行同样的处理的表达式；iterable表示一个或者多个序列。</p></blockquote><blockquote><p>特别注意，py2返回的是列表，py3返回是一个迭代器。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算平方</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line">data_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">res = map(square, data_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用匿名函数</span></span><br><span class="line">ans = map(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, data_list)</span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line">print(list(res))</span><br><span class="line">print(ans)</span><br><span class="line">print(list(ans))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;map object at 0x0000014F2F0F2A58&gt;</span></span><br><span class="line"><span class="string">[1, 4, 9, 16, 25]</span></span><br><span class="line"><span class="string">&lt;map object at 0x0000014F2F32B860&gt;</span></span><br><span class="line"><span class="string">[1, 4, 9, 16, 25]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><ul><li>reduce</li></ul><blockquote><p>reduce()函数会对参数序列中元素进行积累。函数将一个数据集合（链表、元组等）中的所有数据进行下列操作：用穿个reduce中的函数function(有两个参数)相对集合中的第1、2个元素进行操作，得到的结果在于第三个数据继续用function函数进行运算，如此循环迭代，最后得到结果。</p></blockquote><blockquote><p>reduce()函数语法：<code>reduce(function, iterable[, initializer])</code>，其中第一个参数是function函数，里面有两个参数；第二个参数iterable是可迭代对象；第三个是可选参数，初始参数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两数相加</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">data_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">res = reduce(add, data_list)  <span class="comment"># 1+2+3+4+5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用匿名函数</span></span><br><span class="line">ans = reduce(<span class="keyword">lambda</span> x, y: x + y, data_list)  <span class="comment"># 1+2+3+4+5</span></span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line">print(ans)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">15</span></span><br><span class="line"><span class="string">15</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><ul><li>filter</li></ul><blockquote><p>filter()函数用于过滤序列，过滤掉不符合条件的元素，返回符合条件的元素组成的新列表。</p></blockquote><blockquote><p>filter()函数语法：<code>filter(function, iterable)</code>，reduce()接收连个参数，第一个参数function是判断函数，第二个参数iterable是可迭代对象，序列的每个元素作为参数传递给函数进行判断，然后返回True/False，最后将返回True的元素放到新列表中。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 过滤出列表中所有奇数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">data_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">res = filter(is_odd, data_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用匿名函数</span></span><br><span class="line">ans = filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">1</span>, range(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line">print(list(res))</span><br><span class="line">print(ans)</span><br><span class="line">print(list(ans))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;filter object at 0x000001F3A98EB198&gt;</span></span><br><span class="line"><span class="string">[1, 3, 5, 7, 9]</span></span><br><span class="line"><span class="string">&lt;filter object at 0x000001F3A990EB38&gt;</span></span><br><span class="line"><span class="string">[1, 3, 5, 7, 9]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><ul><li>sorted</li></ul><blockquote><p>sort与sorted的区别：</p></blockquote><ul><li>sort是应用在list上的方法，sorted可以对所有可迭代的对象进行排序操作。</li><li>list的sort方法返回的是对已经存在的列表进行操作，而内建函数sorted方法返回的是一个新的list，而不是在原来的list上进行的操作。</li></ul><blockquote><p>sorted()函数语法：<code>sorted(iterable, key=None, reverse=False)</code>，其中iterable是可迭代对象；key主要是用来进行比较元素，只有一个参数，具体的函数的参数是取自于可迭代对象中，指定可迭代对象中的一个元素来排序；reverse是排序规则，默认的是False升序，True为降序。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">-1</span>]</span><br><span class="line">b = a</span><br><span class="line">c = [<span class="string">'a'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>, <span class="string">'b'</span>,  <span class="string">'c'</span>, <span class="string">'B'</span>]</span><br><span class="line">d = &#123;<span class="number">1</span>: <span class="string">'D'</span>, <span class="number">3</span>: <span class="string">'B'</span>, <span class="number">5</span>: <span class="string">'A'</span>, <span class="number">4</span>: <span class="string">'E'</span>, <span class="number">2</span>: <span class="string">'C'</span>&#125;</span><br><span class="line">e = [(<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Adam'</span>, <span class="number">92</span>), (<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>)]</span><br><span class="line">a.sort()</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">print(sorted(b))</span><br><span class="line">print(sorted(b, key=<span class="keyword">lambda</span> x: x*<span class="number">-1</span>))  <span class="comment"># 利用key进行倒序排序</span></span><br><span class="line">print(sorted(b, reverse=<span class="literal">True</span>))  <span class="comment"># 利用reverse=True进行倒序排序</span></span><br><span class="line">print(sorted(b, key=abs))  <span class="comment"># 按绝对值大小升序排序</span></span><br><span class="line">print(sorted(c))  <span class="comment"># 字符串排序，按照ASCII大小比较</span></span><br><span class="line">print(sorted(c, key=str.lower))  <span class="comment"># 忽略字符串大小写排序</span></span><br><span class="line">print(sorted(d))  <span class="comment"># 对字典排序默认是对键keys进行排序</span></span><br><span class="line">print(sorted(d.keys()))  <span class="comment"># 对字典按keys值排序</span></span><br><span class="line">print(sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))  <span class="comment"># 还是对字典按keys值排序</span></span><br><span class="line">print(sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]))  <span class="comment"># 对字典按键值value排序升序</span></span><br><span class="line">print(sorted(e,key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))  <span class="comment"># 根据姓名升序排序</span></span><br><span class="line">print(sorted(e,key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)) <span class="comment"># 根据得分降序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[-1, 0, 1, 2, 2, 3, 4]</span></span><br><span class="line"><span class="string">[-1, 0, 1, 2, 2, 3, 4]</span></span><br><span class="line"><span class="string">[4, 3, 2, 2, 1, 0, -1]</span></span><br><span class="line"><span class="string">[4, 3, 2, 2, 1, 0, -1]</span></span><br><span class="line"><span class="string">[0, -1, 1, 2, 2, 3, 4]</span></span><br><span class="line"><span class="string">['A', 'B', 'C', 'a', 'b', 'c']</span></span><br><span class="line"><span class="string">['a', 'A', 'b', 'B', 'C', 'c']</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="string">[(1, 'D'), (2, 'C'), (3, 'B'), (4, 'E'), (5, 'A')]</span></span><br><span class="line"><span class="string">[(5, 'A'), (3, 'B'), (2, 'C'), (1, 'D'), (4, 'E')]</span></span><br><span class="line"><span class="string">[('Adam', 92), ('Bart', 66), ('Bob', 75), ('Lisa', 88)]</span></span><br><span class="line"><span class="string">[('Adam', 92), ('Lisa', 88), ('Bob', 75), ('Bart', 66)]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="36-返回函数"><a href="#36-返回函数" class="headerlink" title="36. 返回函数"></a>36. 返回函数</h2><blockquote><p>高阶函数出了可以接受函数作为参数外，还可以把函数作为结果值返回。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 嵌套函数，内层函数返回值是函数对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">            x += i</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line">res = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)  <span class="comment"># 这里调用的是求和函数，而非求和结果</span></span><br><span class="line">print(res)</span><br><span class="line">print(res())</span><br><span class="line"></span><br><span class="line"><span class="comment">#  结果</span></span><br><span class="line"><span class="string">'''&lt;function lazy_sum.&lt;locals&gt;.sum at 0x000001A4B6E55488&gt;</span></span><br><span class="line"><span class="string">25</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>实际上是一种闭包，详细参见<a href="#19-闭包">19. 闭包</a>。<strong>返回闭包时要牢记：返回函数不要引用任何循环变量，或者后续会发生变化的量。</strong></p></blockquote><h2 id="37-匿名函数"><a href="#37-匿名函数" class="headerlink" title="37. 匿名函数"></a>37. 匿名函数</h2><p>先观摩下大佬博文<strong><a href="https://blog.csdn.net/PY0312/article/details/88956795" target="_blank" rel="noopener">Python 之 lambda 函数完整详解 &amp; 巧妙运用</a></strong></p><blockquote><p>匿名函数在python编程语言中使用频率非常高，使用起来非常灵活、巧妙。</p></blockquote><ul><li>python中使用关键字lambda来创建匿名函数，没有函数名字；</li><li>lambda只是一个表达式，函数体比def简单很多；</li><li>lambda的主体是一个表达式，而不是一个代码块，所以在表达式中只能封装有限的简单的逻辑表达式，复杂的需要函数来实现；</li><li>lambda函数拥有自己的命名空间，且不能范围自有列表之外或者全局命名空间里的参数；</li></ul><blockquote><p><strong>注意：</strong>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，内联函数的目的是调用小函数时不占用栈内存从而增加运行效率。</p></blockquote><blockquote><p>lambda函数语法：<code>lambda [arg1 [,arg2,...,argn]]: expression</code></p></blockquote><ul><li>lambda是python关键字，[arg…]和expression由用户自定义</li><li>[arg…]是参数列表，形参可以为多个，逗号隔开</li><li>expression是个参数表达式，且表达式只能是单行的，只能有一个表达式,且逻辑结束后直接返回数据</li><li>返回值在冒号之后设置，返回值和正常的函数一样,可以是任意数据类型。(但是想要返回多个元素要以容器的形式返回)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将lambda函数赋值给一个变量，通过这个变量间接调用该lambda函数</span></span><br><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line">res = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将lambda函数赋值给其他函数，从而将其他函数用该lambda函数替换</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep = <span class="keyword">lambda</span> x: <span class="literal">None</span></span><br><span class="line">t = time.sleep(<span class="number">3</span>)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">s = [<span class="keyword">lambda</span> : i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 嵌套的lambda表达式</span></span><br><span class="line">f = (<span class="keyword">lambda</span> x: (<span class="keyword">lambda</span> y: x + y))</span><br><span class="line">res = f(<span class="number">10</span>)</span><br><span class="line">print(res(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">15</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="38-偏函数"><a href="#38-偏函数" class="headerlink" title="38. 偏函数"></a>38. 偏函数</h2><blockquote><p>函数在执行时，要带上所有必要的参数进行调用，有时参数可以在函数被调用之前提前给定，这种情况下，一个函数有一个或多个参数预先就能用上，以便函数能用更少的参数进行调用。</p></blockquote><blockquote><p>偏函数就是将所要承载的函数作为partial()函数的第一个参数，原函数的个参数一次作为partial()函数后续的参数，除非使用关键字参数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对整数100，取得对于不同数m的 100 % m 的余数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mod</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n % m</span><br><span class="line"></span><br><span class="line">mod_by_100 = partial(mod, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">print(mod(<span class="number">100</span>, <span class="number">7</span>))</span><br><span class="line">print(mod_by_100(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大值中每次都有10</span></span><br><span class="line">max_new = partial(max, <span class="number">10</span>)  <span class="comment"># 把10作为max的第一个参数，加到最左边</span></span><br><span class="line">print(max_new(<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">args = (<span class="number">10</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line">print(max(*args))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="39-元编程"><a href="#39-元编程" class="headerlink" title="39. 元编程"></a>39. 元编程</h2><p><strong><a href="https://zhuanlan.zhihu.com/p/114242597" target="_blank" rel="noopener">Python黑魔法：元类和元编程</a></strong><br><strong><a href="https://blog.csdn.net/leongongye/article/details/48343089" target="_blank" rel="noopener">Python 元编程</a></strong></p><blockquote><p>元编程（Meta Programming）又叫超编程，是指某类计算机程序的编写，这类计算机程序的编写或者超重其他程序（或者自身）作为他们的数据，或者在运行完成部分本应该在编译时完成的工作。多数情况下，与手工编译全部代码相比，程序员可以获得更高的工作效率，或者给与程序员更大的灵活度去处理新的情形而无需重新编译。</p></blockquote><blockquote><p>编写元程序的语言称之为元语言。被操作的程序的语言称之为“目标语言”。一门编程语言可以同时也是自身的元语言的能力称之为“反射”或者“自反”。作为胶水语言的python，对各种语言的库的支持（ctypes、js2py等），就是元编程应用的很好实例。</p></blockquote><blockquote><p>元编程是一种可以将程序当作数据来操作的技术，元编程能够读取，生成，分析或转换其他的程序代码，甚至可以在运行时修改自身。元编程存在的目的，就是多提供了一个抽象层次。</p></blockquote><blockquote><p>在python中，元编程实现通常的手段有：</p></blockquote><ul><li>预定义方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, o)</span>:</span></span><br><span class="line">        self.__obj__ = o</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self.__obj__, name):</span><br><span class="line">            <span class="keyword">return</span> getattr(self.__obj__, name)</span><br><span class="line">        <span class="keyword">return</span> self.__dict__[name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__obj__.iter__()</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line">a = A(l)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">101</span>):</span><br><span class="line">    a.append(i)</span><br><span class="line">print(sum(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>这是一个简单的agent类，<code>__iter__</code>属于云定义函数，不会调用<code>__getattr__</code>来获得，需要额外定义。在<code>__getattr__</code>和<code>__setattr__</code>两个函数中，可以访问<code>__dict__</code>，而在函数<code>__getattribute__</code>中使用<code>self.__dict__</code>会引发递归，需要用<code>object.getattribute(self, name)</code>访问，<code>getattribute</code>只能用于新式类。</p></blockquote><ul><li>函数赋值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># socket.py中的例子</span></span><br><span class="line">_delegate_methods = (<span class="string">"recv"</span>, <span class="string">"recvfrom"</span>, <span class="string">"recv_into"</span>, <span class="string">"recvfrom_into"</span>, <span class="string">"send"</span>, <span class="string">"sendto"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, family=AF_INET, type=SOCK_STREAM, proto=<span class="number">0</span>, _sock=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> _sock <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        _sock = _realsocket(family, type, proto)</span><br><span class="line">    self._sock = _sock</span><br><span class="line">    <span class="keyword">for</span> method <span class="keyword">in</span> _delegate_method:</span><br><span class="line">        setattr(self, method, getattr(_sock, method))</span><br><span class="line"></span><br><span class="line"><span class="comment"># http代理装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">http_proxy</span><span class="params">(proxyaddr, username=None, password=None)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reciver</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">creator</span><span class="params">(family=socket.AF_INET, type=socket.SOCK_STREAM, proto=<span class="number">0</span>)</span>:</span></span><br><span class="line">            sock = func(family, type, proto)</span><br><span class="line">            sock.connect(proxyaddr)</span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">newconn</span><span class="params">(addr)</span>:</span></span><br><span class="line">                http_connect(sock, addr, username, password)</span><br><span class="line">            sock.connect, sock.connect_ex = nerconn, newconn</span><br><span class="line">            <span class="keyword">return</span> sock</span><br><span class="line">        <span class="keyword">return</span> creator</span><br><span class="line">    <span class="keyword">return</span> reciver</span><br></pre></td></tr></table></figure><ul><li>描述器</li></ul><blockquote><p>所谓描述器(descriptor)就是带有<code>__get__</code>和<code>__set__</code>函数的对象，当访问某个对象的某个属性，这个属性又是descriptor时，返回值是descriptor的<code>__get__</code>调用的返回，<code>__set__</code>也是类似的，带有<code>__set__</code>的称为data descriptor，而只有<code>__get__</code>的称为non data descriptor</p></blockquote><blockquote><p>Python访问某个对象的某个属性时，是按照以下次序的：</p></blockquote><ul><li>类的数据描述器</li><li>instance属性，无论其是否是描述器，都不调用<code>__get__</code></li><li>类属性，包括non data descriptor</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():</span><br><span class="line">            <span class="keyword">if</span> hasattr(v, <span class="string">'__meta_init__'</span>):</span><br><span class="line">                v.__meta_init__(k)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AttrBase</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__meta_init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        self.name = k</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> obj[self.name]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, value)</span>:</span></span><br><span class="line">        obj[self.name] = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(dict, metaclass = Meta)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(dict)</span>:</span></span><br><span class="line">    name = AttrBase()</span><br><span class="line"></span><br><span class="line">b = User()</span><br><span class="line">b.name = <span class="string">'shell'</span></span><br><span class="line">print(b)</span><br><span class="line">print(b.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;'name': 'shell'&#125;</span></span><br><span class="line"><span class="string">shell</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>当访问<code>b.name</code>时，实际上是去访问了<code>b[&#39;name&#39;]</code>，这个过程不是通过User类重载<code>__getattr__</code>实现的，而是通过descriptor。</p></blockquote><ul><li>元类</li></ul><blockquote><p>具体可以参考之前<a href="#3-python中的元类metaclass">python中的元类metaclass</a></p></blockquote><ul><li>eval函数</li></ul><blockquote><p>eval()函数来执行一个字符串表达式，并返回表达式的值。<br>eval()函数的语法：<code>eval(expression[, globals[, locals]])</code>，expression是表达式；globals是变量作用域，全局命名空间，如果被提供，这必须是一个字典对象；locals是变量作用域，局部变量命名空间，如果被提供，可以是任何映射对象。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s1 =<span class="string">'2 * 6 / 2 + 2'</span></span><br><span class="line">s2 = <span class="string">'pow(2, 3)'</span></span><br><span class="line">s3 = <span class="string">'2 ** 3'</span></span><br><span class="line"></span><br><span class="line">print(eval(s1))</span><br><span class="line">print(eval(s2))</span><br><span class="line">print(eval(s3))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">8.0</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">8</span></span><br></pre></td></tr></table></figure><p><strong>经典案例：使用元类在python语言和数据库中间增加一个抽象ORM层</strong>（可参考元类里面给出的<a href="#3-python中的元类metaclass">使用元类创建ORM实例</a>）</p><blockquote><p>元编程常见的应用场景</p></blockquote><ul><li>扩展重构语法</li><li>开发DSL</li><li>生成代码</li><li>根据特定场景自动选择代码优化</li><li>解决一些正交的架构设计问题</li><li>面向切面编程AOP</li></ul><h2 id="40-捕获异常"><a href="#40-捕获异常" class="headerlink" title="40. 捕获异常"></a>40. 捕获异常</h2><p><strong><a href="https://www.cnblogs.com/beile/p/10789333.html" target="_blank" rel="noopener">python捕获异常及方法总结</a></strong></p><blockquote><p>在编写程序或者调试程序时，或多或少存在BUG或者异常，这时候就需要进行异常的捕获，根据异常Traceback定位出错点，进行处理。</p></blockquote><ul><li><p>异常类型</p><p>(1) Python内置异常</p><blockquote><p>在Python中，异常也是对象，python的异常处理能力很强大，有很多内置异常，可以为用户准确反馈出错信息。BaseException是所有内置异常的基类，但用户自定义的类并不几层BaseException，所有的异常类都是从Exception继承，且都在exceptions模块中定义。python自动降所有的异常名称放在内建命名空间中，所以程序不必导入exceptions模块即可使用异常，一旦引发而且没有捕捉SystemExit异常，程序执行就会终止，如果交互式回话遇到一个为捕捉的SystemExit异常，会话就会终止。</p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""python内置异常类的层次结构"""</span></span><br><span class="line">BaseException  <span class="comment"># 所有异常的基类</span></span><br><span class="line"> +-- SystemExit  <span class="comment"># 解释器请求退出</span></span><br><span class="line"> +-- KeyboardInterrupt  <span class="comment"># 用户中断执行(通常是"ctrl+C")</span></span><br><span class="line"> +-- GeneratorExit  <span class="comment"># 生成器(generator)发生异常来通知退出</span></span><br><span class="line"> +-- Exception  <span class="comment"># 常规异常的基类</span></span><br><span class="line">      +-- StopIteration  <span class="comment"># 迭代器没有更多的值</span></span><br><span class="line">      +-- StopAsyncIteration  <span class="comment"># 必须通过异步迭代器对象的__anext__()方法引发以停止迭代</span></span><br><span class="line">      +-- ArithmeticError  <span class="comment"># 各种算术错误引发的内置异常的基类</span></span><br><span class="line">      |    +-- FloatingPointError  <span class="comment"># 浮点计算错误</span></span><br><span class="line">      |    +-- OverflowError  <span class="comment"># 数值运算结果太大无法表示</span></span><br><span class="line">      |    +-- ZeroDivisionError  <span class="comment"># 除(或取模)零 (所有数据类型)</span></span><br><span class="line">      +-- AssertionError  <span class="comment"># 当assert语句失败时引发</span></span><br><span class="line">      +-- AttributeError  <span class="comment"># 属性引用或赋值失败</span></span><br><span class="line">      +-- BufferError  <span class="comment"># 无法执行与缓冲区相关的操作时引发</span></span><br><span class="line">      +-- EOFError  <span class="comment"># 当input()函数在没有读取任何数据的情况下达到文件结束条件(EOF)时引发</span></span><br><span class="line">      +-- ImportError  <span class="comment"># 导入模块/对象失败</span></span><br><span class="line">      |    +-- ModuleNotFoundError  <span class="comment"># 无法找到模块或在在sys.modules中找到None</span></span><br><span class="line">      +-- LookupError  <span class="comment"># 映射或序列上使用的键或索引无效时引发的异常的基类</span></span><br><span class="line">      |    +-- IndexError  <span class="comment"># 序列中没有此索引(index)</span></span><br><span class="line">      |    +-- KeyError  <span class="comment"># 映射中没有这个键</span></span><br><span class="line">      +-- MemoryError  <span class="comment"># 内存溢出错误(对于Python 解释器不是致命的)</span></span><br><span class="line">      +-- NameError  <span class="comment"># 未声明/初始化对象 (没有属性)</span></span><br><span class="line">      |    +-- UnboundLocalError  <span class="comment"># 访问未初始化的本地变量</span></span><br><span class="line">      +-- OSError  <span class="comment"># 操作系统错误(EnvironmentError、IOError、WindowsError、socket.error、select.error、mmap.error已合并到OSError中，构造函数可能返回子类)</span></span><br><span class="line">      |    +-- BlockingIOError  <span class="comment"># 操作将阻塞对象设置为非阻塞操作</span></span><br><span class="line">      |    +-- ChildProcessError  <span class="comment"># 在子进程上的操作失败</span></span><br><span class="line">      |    +-- ConnectionError  <span class="comment"># 与连接相关的异常的基类</span></span><br><span class="line">      |    |    +-- BrokenPipeError  <span class="comment"># 另一端关闭时尝试写入管道或试图在已关闭写入的套接字上写入</span></span><br><span class="line">      |    |    +-- ConnectionAbortedError  <span class="comment"># 连接尝试被对等方中止</span></span><br><span class="line">      |    |    +-- ConnectionRefusedError  <span class="comment"># 连接尝试被对等方拒绝</span></span><br><span class="line">      |    |    +-- ConnectionResetError  <span class="comment"># 连接由对等方重置</span></span><br><span class="line">      |    +-- FileExistsError  <span class="comment"># 创建已存在的文件或目录</span></span><br><span class="line">      |    +-- FileNotFoundError  <span class="comment"># 请求不存在的文件或目录</span></span><br><span class="line">      |    +-- InterruptedError  <span class="comment"># 系统调用被输入信号中断</span></span><br><span class="line">      |    +-- IsADirectoryError  <span class="comment"># 在目录上请求文件操作(例如 os.remove())</span></span><br><span class="line">      |    +-- NotADirectoryError  <span class="comment"># 在不是目录的事物上请求目录操作(例如 os.listdir())</span></span><br><span class="line">      |    +-- PermissionError  <span class="comment"># 尝试在没有足够访问权限的情况下运行操作</span></span><br><span class="line">      |    +-- ProcessLookupError  <span class="comment"># 给定进程不存在</span></span><br><span class="line">      |    +-- TimeoutError  <span class="comment"># 系统函数在系统级别超时</span></span><br><span class="line">      +-- ReferenceError  <span class="comment"># weakref.proxy()函数创建的弱引用试图访问已经垃圾回收了的对象</span></span><br><span class="line">      +-- RuntimeError  <span class="comment"># 在检测到不属于任何其他类别的错误时触发</span></span><br><span class="line">      |    +-- NotImplementedError  <span class="comment"># 在用户定义的基类中，抽象方法要求派生类重写该方法或者正在开发的类指示仍然需要添加实际实现</span></span><br><span class="line">      |    +-- RecursionError  <span class="comment"># 解释器检测到超出最大递归深度</span></span><br><span class="line">      +-- SyntaxError  <span class="comment"># Python语法错误</span></span><br><span class="line">      |    +-- IndentationError  <span class="comment"># 缩进错误</span></span><br><span class="line">      |    |    +-- TabError  <span class="comment"># Tab和空格混用</span></span><br><span class="line">      +-- SystemError  <span class="comment"># 解释器发现内部错误</span></span><br><span class="line">      +-- TypeError  <span class="comment"># 操作或函数应用于不适当类型的对象</span></span><br><span class="line">      +-- ValueError  <span class="comment"># 操作或函数接收到具有正确类型但值不合适的参数</span></span><br><span class="line">      |    +-- UnicodeError  <span class="comment"># 发生与Unicode相关的编码或解码错误</span></span><br><span class="line">      |    |    +-- UnicodeDecodeError  <span class="comment"># Unicode解码错误</span></span><br><span class="line">      |    |    +-- UnicodeEncodeError  <span class="comment"># Unicode编码错误</span></span><br><span class="line">      |    |    +-- UnicodeTranslateError  <span class="comment"># Unicode转码错误</span></span><br><span class="line">      +-- Warning  <span class="comment"># 警告的基类</span></span><br><span class="line">      |    +-- DeprecationWarning  <span class="comment"># 有关已弃用功能的警告的基类</span></span><br><span class="line">      |    +-- PendingDeprecationWarning  <span class="comment"># 有关不推荐用功能的警告的基类</span></span><br><span class="line">      |    +-- RuntimeWarning  <span class="comment"># 有关可疑的运行时行为的警告的基类</span></span><br><span class="line">      |    +-- SyntaxWarning  <span class="comment"># 关于可疑语法警告的基类</span></span><br><span class="line">      |    +-- UserWarning  <span class="comment"># 用户代码生成警告的基类</span></span><br><span class="line">      |    +-- FutureWarning  <span class="comment"># 有关已弃用功能的警告基类</span></span><br><span class="line">      |    +-- ImportWarning  <span class="comment"># 关于模块导入时可能出错的警告的基类</span></span><br><span class="line">      |    +-- UnicodeWarning  <span class="comment"># 与Unicode相关的警告的基类</span></span><br><span class="line">      |    +-- BytesWarning  <span class="comment"># 与bytes和bytearray相关的警告的基类</span></span><br><span class="line">      |    +-- ResourceWarning  <span class="comment"># 与资源使用相关的警告的基类，被默认警告过滤器忽略。</span></span><br></pre></td></tr></table></figure><p>  (2) requests模块的相关异常</p><blockquote><p>python在开发爬虫时，经常用到requests库，要调用requests模块的内置异常，需要<code>from requests.exceptions import xxx</code>，例如: <code>from requests.exceptions import ConnectionError, ReadTimeout</code> 或者 <code>from requests import ConnectionError, ReadTimeout</code>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># requests模块内置异常类的层次结构</span></span><br><span class="line">IOError</span><br><span class="line"> +-- RequestException  <span class="comment"># 处理不确定的异常请求</span></span><br><span class="line">      +-- HTTPError  <span class="comment"># HTTP错误</span></span><br><span class="line">      +-- ConnectionError  <span class="comment"># 连接错误</span></span><br><span class="line">      |    +-- ProxyError  <span class="comment"># 代理错误</span></span><br><span class="line">      |    +-- SSLError  <span class="comment"># SSL错误</span></span><br><span class="line">      |    +-- ConnectTimeout(+-- Timeout)  <span class="comment"># (双重继承，下同)尝试连接到远程服务器时请求超时，产生此错误的请求可以安全的重试</span></span><br><span class="line">      +-- Timeout  <span class="comment"># 请求超时</span></span><br><span class="line">      |    +-- ReadTimeout  <span class="comment"># 服务器未在指定的时间发送任何数据</span></span><br><span class="line">      +-- URLRequired  <span class="comment"># 发出请求需要有效的URL</span></span><br><span class="line">      +-- TooManyRequired  <span class="comment"># 重定向太多</span></span><br><span class="line">      +-- MissingSchema(+-- ValueError)  <span class="comment"># 缺少URL架构(例如http或https)</span></span><br><span class="line">      +-- InvalidSchema(+-- ValueError)  <span class="comment"># 无效的架构，有效架构清常见defaults.py</span></span><br><span class="line">      +-- InvalidURL(+-- ValueError)  <span class="comment"># 无效的RUL</span></span><br><span class="line">      |    +-- InvalidProxyURL(+-- ValueError)  <span class="comment"># 无效的代理RUL</span></span><br><span class="line">      +-- InvalidHeader(+-- ValueError)  <span class="comment"># 无效的Header</span></span><br><span class="line">      +-- ChunkedEncodingError  <span class="comment"># 服务器声明了chunked编码但发送了一个无效的chunk</span></span><br><span class="line">      +-- ContentDecodingError(+-- BaseHTTPError)  <span class="comment"># 无法解码响应内容</span></span><br><span class="line">      +-- StreamCosumedError(+-- TypeError)  <span class="comment"># 此响应的内容已被使用</span></span><br><span class="line">      +-- RetryError  <span class="comment"># 自定义重试逻辑失败</span></span><br><span class="line">      +-- UnrewindableBodyError  <span class="comment"># 尝试倒回正文时，请求遇到错误</span></span><br><span class="line">      +-- FileModeWarning(+-- DeprecationWarning)  <span class="comment"># 文件以文本模式打开，但Requests确定其二进制长度</span></span><br><span class="line">      +-- RequestsDependencyWarning  <span class="comment"># 导入的依赖项与预期的版本范围不匹配</span></span><br><span class="line"></span><br><span class="line">Warning</span><br><span class="line"> +-- RequestsWarning <span class="comment"># 请求的基本警告</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单的requests请求，测试异常</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> ReadTimeout</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, timeout=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Get Page Failed'</span>, response.status_code)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> (ConnectionError, ReadTimeout):</span><br><span class="line">        print(<span class="string">'Crawling Failed'</span>, url)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    url = <span class="string">'https://www.baidu.com'</span></span><br><span class="line">    print(get_page(url))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&lt;/body&gt; &lt;/html&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>  (3) 用户自定义异常</p><blockquote><p>用户可以通过创建一个异常类，直接或间接继承Exception类。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义一个异常类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span><span class="params">(Exception)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.msg = msg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> MyError(<span class="string">'类型错误'</span>)</span><br><span class="line"><span class="keyword">except</span> MyError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'My exception occured'</span>, e.msg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">My exception occured 类型错误</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><ul><li>异常捕获</li></ul><blockquote><p>当发生异常时，需要对异常进行捕获，然后进行处理。python的异常捕获常用try…except…结构，把可能发生错误的语句放在try模块里，用except来处理异常，每个try都必须至少对应一个except。</p></blockquote><table><thead><tr><th align="center">关键字</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">try/except</td><td align="left">捕获异常并处理</td></tr><tr><td align="center">pass</td><td align="left">忽略异常</td></tr><tr><td align="center">as</td><td align="left">定义异常实例</td></tr><tr><td align="center">else</td><td align="left">如果try中的语句没有引发异常，这执行else中的语句</td></tr><tr><td align="center">finally</td><td align="left">无论是否出现异常，都执行的代码</td></tr><tr><td align="center">raise</td><td align="left">抛出/引发异常</td></tr></tbody></table><p>  (1) 捕获所有异常</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 捕获所有的异常，包含键盘中断和程序退出请求</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  do somethings</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  print(<span class="string">'捕获所有异常'</span>)</span><br></pre></td></tr></table></figure><p>  (2) 捕获指定异常</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 捕获指定异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  do somethings</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  print(<span class="string">'捕获指定异常'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 万能异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  do somethings</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">  print(<span class="string">'万能异常'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获指定的IOError</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  f = open(<span class="string">"test.txt"</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">  print(<span class="string">"open exception: %s: %s"</span> % (e.errno, e.strerror))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">open exception: 2: No such file or directory</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>  (3) 捕获多个异常</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># except同时处理多个异常，不区分优先级</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  do somethings</span><br><span class="line"><span class="keyword">except</span> (&lt;Error1&gt;, &lt;Error2&gt;, ...):</span><br><span class="line">  print(<span class="string">'异常说明'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区分优先级进行处理异常</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行try下的语句，如果引发异常，则执行过程会跳到第一个except语句。</span></span><br><span class="line"><span class="string">如果第一个except中定义的异常与引发的异常匹配，则执行该except中的语句。</span></span><br><span class="line"><span class="string">如果引发的异常不匹配第一个except，则会搜索第二个except，允许编写的except数量没有限制。</span></span><br><span class="line"><span class="string">如果所有的except都不匹配，则异常会传递到下一个调用本代码的最高层try代码中。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  do somethings</span><br><span class="line"><span class="keyword">except</span> &lt;Error1&gt;:</span><br><span class="line">  print(<span class="string">'异常说明1'</span>)</span><br><span class="line"><span class="keyword">except</span> &lt;Error2&gt;:</span><br><span class="line">  print(<span class="string">'异常说明2'</span>)</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line"><span class="keyword">except</span> &lt;Errorn&gt;:</span><br><span class="line">  print(<span class="string">'异常说明n'</span>)</span><br></pre></td></tr></table></figure><p>  (4) 异常中的else</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果判断完没有某些异常之后还想做其他事情，就可以用else语句</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  do somethings</span><br><span class="line"><span class="keyword">except</span> &lt;Error1&gt;:</span><br><span class="line">  print(<span class="string">'异常说明1'</span>)</span><br><span class="line"><span class="keyword">except</span> &lt;Error2&gt;:</span><br><span class="line">  print(<span class="string">'异常说明2'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  do other things  <span class="comment"># try语句没有异常才会跳到这</span></span><br></pre></td></tr></table></figure><p>  (5) 异常中的finally</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无论是否发生异常都要执行的操作代码</span></span><br><span class="line">str1 = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  int(str1)</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">  print(e)</span><br><span class="line"><span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">  print(e)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">  print(e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">'未发生异常'</span>)  <span class="comment"># try语句没有异常才会跳到这</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">  print(<span class="string">'不管前面怎么样，就是要做'</span>)  <span class="comment"># 不管前面是否异常，都做的事情</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">invalid literal for int() with base 10: 'hello world'</span></span><br><span class="line"><span class="string">不管前面怎么样，就是要做</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>  (6) raise主动触发异常</p><blockquote><p>raise语句用于抛出、触发异常<br>  raise语法格式：<code>raise [Exception [, arg [, traceback]]]</code>，其中，Exception是异常类型，如ValueError，arg是一个可选的异常参数，当不提供时，默认为None，traceback是跟踪异常对象，可选。</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断数是否为0，是的话抛出异常:"参数错误"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_zero</span><span class="params">(num)</span>:</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">      <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">          <span class="keyword">raise</span> ValueError(<span class="string">'参数错误'</span>)</span><br><span class="line">      <span class="keyword">return</span> num</span><br><span class="line">  <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">      print(e)</span><br><span class="line"></span><br><span class="line">not_zero(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">参数错误</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>  (7) 采用Traceback模块查看异常</p><blockquote><p>发生异常时，python利用traceback记住引发异常的以及程序的当前状态，维护着traceback对象，从而获取含有异常发生时函数调用堆栈有关的信息。<code>traceback.print_exc(file=open(&#39;error_log.txt&#39;,&#39;w+&#39;))</code></p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">  traceback.print_exc()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">File "C:/Users/holysll/PycharmProjects/untitled/test/super_parent_class.py", line 12, in &lt;module&gt;</span></span><br><span class="line"><span class="string">  1/0</span></span><br><span class="line"><span class="string">ZeroDivisionError: division by zero</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>traceback.print_exc()与traceback.format_exc()的区别：</p></blockquote><ul><li>format_exc()返回字符串，而print_exc()则直接给打印出来；</li><li>print_exc()还可以接受file参数直接写入到一个文件，如:<code>traceback.print_exc(file=open(&#39;error_log.txt&#39;,&#39;w+&#39;))</code></li></ul><h2 id="41-python常见的内置数据结构"><a href="#41-python常见的内置数据结构" class="headerlink" title="41. python常见的内置数据结构"></a>41. python常见的内置数据结构</h2><ul><li><p>字符串(string)</p><ul><li><p>由字符组成的有序的序列，是字符的集合</p></li><li><p>使用单引号’’、双引号””、三引号’’’’’’表示</p></li><li><p>有顺序、能索引、可迭代、元素能重复、不可变对象</p></li><li><p>python3中，字符串就是Unicode类型</p></li><li><p>字符串连接：<code>&quot;分隔符&quot;.join(iterable)</code>，如：<code>&quot;&quot;.join([&#39;1&#39;, &#39;2&#39;, &#39;3&#39;])</code>。<strong>注意：可迭代对象iterable必须是字符串</strong></p></li><li><p>字符串拼接：通过str + str 将两个字符串拼接得到一个新的字符串</p></li><li><p>字符串分割：</p><ul><li><code>str.split(sep=None, maxsplit=-1)</code>，seq表示分割符，缺省默认为空格，maxsplit表示分割次数，-1表示遍历整个字符串；</li><li><code>str.rsplit(sep=None, maxsplit=-1)</code>表示从右至左分割；</li><li><code>str.splitlines([keepends])</code>按照换行符切分字符串，换行符（<code>&#39;\r&#39;, &#39;\r\n&#39;, &#39;\n&#39;</code>），keepends表示是否保留换行符，默认为False不保留，True则保留会输出换行符；</li><li><code>str.partition(seq) -&gt; (head, seq ,tail)</code>从左到右，遇到分割符就把字符串分割成两部分，返回头、分隔符、尾三部分；若没找到分隔符，就返回头和两个空元素的三元组；</li><li><code>str.rpartition(seq) -&gt; (head, seq ,tail)</code>从右至左分割；</li></ul></li><li><p>字符串大小写：</p><ul><li><code>str.upper()</code> 全大写</li><li><code>str.lower()</code> 全小写</li><li><code>str.swapcase()</code>交互大小写</li></ul></li><li><p>字符串排版：</p><ul><li><code>str.title()</code> 标题的每个单词都大写</li><li><code>str.capitalize()</code> 首字母大写</li><li><code>str.center(width[, fillchar])</code> 字符串居中，并使用填充符(fillchar)填充至长度(width)，填充符默认为空格</li><li><code>str.zfill(width)</code> 返回指定长度(width)的字符串，右对齐，左边前面填充0</li><li><code>str.ljust(width[, fillchar])</code> 字符串左对齐，并使用填充符(fillchar)填充至长度(width)，填充符默认为空格</li><li><code>str.rjust(width[, fillchar])</code> 字符串右对齐，并使用填充符(fillchar)填充至长度(width)，填充符默认为空格</li></ul></li><li><p>字符串修改：</p><ul><li><code>str.replace(old, new[,count])</code> 字符串匹配固定字符进行替换，count表示替换次数，默认全部替换</li><li><code>str.strip([chars])</code> 字符串两端去除指定的字符集(chars)，默认是空格</li><li><code>str.lstrip([chars])</code> 字符串去除左边指定的字符集(chars)，默认是空格</li><li><code>str.lstrip([chars])</code> 字符串去除右边指定的字符集(chars)，默认是空格</li></ul></li><li><p>字符串查找：</p><ul><li><code>str.find(sub[, start[, end]])</code> 在指定区间[start, end]内，从左至右查找子串，找到返回索引，未找到返回-1</li><li><code>str.rfind(sub[, start[, end]])</code> 在指定区间[start, end]内，从右至左查找子串，找到返回索引，未找到返回-1</li><li><code>str.index(sub[, start[, end]])</code> 在指定区间[start, end]内，从左至右查找子串，找到返回索引，未找到抛出异常ValueError</li><li><code>str.rindex(sub[, start[, end]])</code> 在指定区间[start, end]内，从右至左查找子串，找到返回索引，未找到抛出异常ValueError</li></ul></li><li><p>字符串统计：</p><ul><li><code>str.count(sub[, start[, end]])</code> 在指定区间[start, end]内，从左至右统计子串sub出现的次数</li></ul></li><li><p>字符串判断：</p><ul><li><code>str.endswith(suffix[, start[, end]])</code> 在指定区间[start, end]内，字符串是否是suffix结尾</li><li><code>str.startswith(suffix[, start[, end]])</code> 在指定区间[start, end]内，字符串是否是suffix开头</li><li><code>str.isalnum()</code> 是否是字母和数字组成</li><li><code>str.isalpha()</code> 是否是字母</li><li><code>str.isdecimal()</code> 是否包含十进制数字</li><li><code>str.isdigit()</code> 是否全是全部数字（0-9）</li><li><code>str.isidentifier()</code> 是否是仅包含字母、数字和下划线</li><li><code>str.islower()</code> 是否都是小写</li><li><code>str.isupper()</code> 是否都是大写</li><li><code>str.isspace()</code> 是否只包含空白字符</li></ul></li><li><p>字符串格式化：</p><ul><li><code>&quot;This is %s&quot; % &quot;python&quot;</code></li><li><code>&quot;This is {}&quot;.format(&quot;python&quot;)</code></li><li><code>&quot;This {0[0]} {0[1]}&quot;.format((&quot;is&quot;,&quot;python&quot;))</code></li></ul></li><li><p>字符串翻倍：<code>str * n</code>，例如<code>&#39;py&#39; * 3</code> 结果是<code>&#39;pypypy&#39;</code></p></li></ul></li><li><p>列表(list)</p><ul><li><p>一个排列整齐的队列，由若干个元素组成</p></li><li><p>元素可以是任意对象，数字、字符串、字典、元组、列表、对象等</p></li><li><p>列表内的元素有顺序，可以使用索引，元素能重复，可修改</p></li><li><p>是线性数据结构，使用中括号[]表示</p></li><li><p>列表初始化：</p><ul><li><code>s = list()</code>或<code>s = []</code> 生成一个空列表</li><li><code>s = list(iterable)</code> 可将可循环的结构转化为列表，如：<code>s = list(range(5))</code>、<code>s = [1, 2, 3]</code></li></ul></li><li><p>列表索引访问</p><ul><li><code>list[index]</code> index即是list的索引，也叫下标，从左至右，丛0开始到列表长度减一(len(list)-1)；若从右至左，索引从-1开始；索引不可以越界，否则抛出异常indexError</li></ul></li><li><p>列表查询：</p><ul><li><code>list.index(value, [start, [stop]])</code> 在指定区间[start, stop]查找列表内的元素是否与value匹配，匹配到第一个就返回索引，匹配不到，抛出异常ValueError</li></ul></li><li><p>列表元素统计：</p><ul><li><code>list.count(value)</code> 返回列表中匹配value的次数</li></ul></li><li><p>列表元素修改：</p><ul><li><code>list[index] = value</code></li></ul></li><li><p>列表增加、插入元素</p><ul><li><code>list.append(object)</code> 尾部追加元素</li><li><code>list.insert(index, object)</code> 在指定索引位置插入元素</li><li><code>list.extend(iterable)</code> 将可迭代对象的元素追加进来</li><li><code>list1 + list2</code>连个列表连接操作，本质上是add()方法</li></ul></li><li><p>列表删除元素</p><ul><li><code>list.remove(value)</code> 从左至右查找第一个value的值，移除该元素</li><li><code>list.pop([index])</code> 根据指定的索引index弹出该元素，当index为空时，默认弹出尾部第一个元素即index=-1;</li><li><code>list.clear()</code> 清空列表</li></ul></li><li><p>列表元素排序</p><ul><li><code>list.sort(key=None, reverse=False)</code>key是用来比较的元素，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象的一个元素进行排序；reverse是排序规则，reverse=True降序，默认reverse=False升序</li><li><code>list.reverse()</code> 对列表的元素进行反向排序</li></ul></li><li><p>列表元素打乱顺序</p><ul><li><code>random.shuffle(list)</code> 就地打乱列表元素</li></ul></li><li><p>列表随机取数</p><ul><li><code>random.randint(a, b)</code> 返回范围[a, b)之间的整数</li><li><code>random.choice(seq)</code> 从非空序列的元素中随机选择一个元素</li><li><code>random.randrange([start,] stop[, step])</code> 从指定范围[start, stop]内，按指定步长递增的集合中获取一个随机数</li><li><code>random.sample(list, k)</code> 从样本空间或总体中随机取出k个不同的元素</li></ul></li><li><p>列表切片 <strong><a href="https://www.jianshu.com/p/15715d6f4dad" target="_blank" rel="noopener">Python切片操作详细例子</a></strong></p><ul><li>切片基本表达式：<code>object[start_index : end_index : step]</code> step不写的时候默认为1，<strong>注意索引方向必须与step的方向一致，否则返回空列表</strong></li><li>s = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</li><li><code>s[:]</code> 或<code>s[::]</code> 从左往右，切取完整列表  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</li><li><code>s[::-1]</code> 从右往左，切取完整列表  # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</li><li><code>s[1:6]</code> 开始索引为1到索引为6，步长为1，从左往右取值  # [1, 2, 3, 4, 5]</li><li><code>s[6:1:-1]</code> 开始索引为6到索引为1，步长为-1，从右往左取值  # [6, 5, 4, 3, 2]</li><li><code>s[:6]</code> start_index省略时，这时默认从起点开始，索引为0到索引为6，步长为1，从左往右取值  # [0, 1, 2, 3, 4, 5]</li><li><code>s[:6:-1]</code> start_index省略时，这时默认从终点开始，索引为9到索引为6，步长为-1，从右往左取值  # [9, 8, 7]</li><li><code>s[6:]</code> end_index省略，这时默认为终点，索引为6到索引为9，步长为1，从左往右取值  # [6, 7, 8, 9]</li><li><code>s[6:：-1]</code> end_index省略，这时默认为起点，索引为6到索引为0，步长为-1，从右往左取值  # [6, 5, 4, 3, 2, 1, 0]</li><li><code>s[-1:-6:-1]</code> end_index省略，默认为终点，索引为-1到索引为-6，步长为-1，从右往左取值  # [9, 8, 7, 6, 5]</li><li><code>s[-6:-1]</code> step省略，索引为-6到索引为-1，步长为1，从左往右取值  # [9, 8, 7, 6, 5]</li><li><code>s[:-6]</code> step=1，从左往右取值，从索引0开始到索引-6  # [0, 1, 2, 3]</li><li><code>s[:-6:-1]</code> start_index省略，这时默认为终点，step=-1，从右往左取值，从索引-1到索引-6  # [9, 8, 7, 6, 5]</li><li><code>s[-6:]</code> end_index省略，这时为终点，step=1，从左往右取值，从索引-6开始到终点  # [4, 5, 6, 7, 8, 9]</li><li><code>s[-6::-1]</code> end_index省略，这时为起点，step=-1，从右往左取值，从索引-6到索引0  # [4, 3, 2, 1, 0]</li><li><code>s[1:-6]</code> step=1，从左往右取值，从索引1到索引为-6  # [1, 2, 3]</li><li><code>s[-1:6:-1]</code> step=-1，从右往左取值，从索引-1到索引6  # [9, 8, 7]</li></ul></li><li><p>多层切片操作：</p><ul><li><code>s[:8][2:5][-1:]</code> 相当于先<code>s[:8]=[0, 1, 2, 3, 4, 5, 6, 7]</code>，然后<code>[0, 1, 2, 3, 4, 5, 6, 7][2:5]=[2, 3, 4]</code>，最后<code>[2, 3, 4][-1:]=[4]</code></li></ul></li><li><p>带表达式的切片操作：</p><ul><li><code>s[2+1:3*2:7%3]</code> 先计算各表达式可知，切片操作相当于<code>s[3:6:1]=[3, 4, 5]</code></li></ul></li><li><p>常用切片操作</p><ul><li>取偶数位置：<code>s[::2]=[0, 2, 4, 6, 8]</code></li><li>取奇数位置：<code>s[1::2]=[1, 3, 5, 7, 9]</code></li><li>for循环里的切片：<code>for i in range(1, 100)[2::3][-5:]:</code> 分解为三步，先生成[1, 2, 3, …, 99]的整数对象，然后step=3，从左往右取值，从索引2（即3）到终点（即99），得到[3, 6, 9, … , 99]，最后里面取最后五个数[99, 96, 93, 90, 87]</li></ul></li></ul></li><li><p>元组(tuple)</p><ul><li>一个有序的元素组成的集合</li><li>有顺序、能索引、元素能重复、不可变对象</li><li>小括号()表示，单个元素定义时：(1,) 必须带逗号</li><li>tuple是只读，没有增删改，其他功能和列表差不多</li><li>元组初始化：<code>t = tuple()</code>空元组；<code>t = tuple(iterable)</code> 可迭代对象元组</li></ul></li><li><p>字典(dict)</p><ul><li><p>key-value键值对形式的数据集合</p></li><li><p>无顺序、key不可重复、可变可迭代</p></li><li><p>是非线性数据结构，使用大括号{}表示，里面都是键值对key:value的形式</p></li><li><p>字典的初始化</p><ul><li><code>d = dict()</code> 或者 <code>d = {}</code> 新建一个空字典</li><li><code>d = {&#39;x&#39;: 1, &#39;y&#39;: 2}</code>  # {‘x’: 1, ‘y’: 2}</li><li><code>d = dict(x=1, y=2)</code>  # {‘x’: 1, ‘y’: 2}</li><li><code>d = dict(zip(&#39;abc&#39;,[1, 2, 3]))</code>  # {‘a’: 1, ‘b’: 2, ‘c’: 3}</li><li><code>d = dict.fromkeys(range(2), 3)</code>  # {0: 3, 1: 3}</li><li><code>d = dict.fromkeys((&#39;x&#39;, &#39;y&#39;), 2)</code>  # {‘x’: 2, ‘y’: 2}</li><li><code>d = dict([(&#39;x&#39;, 1),(&#39;y&#39;, 2)])</code>  # {‘x’: 1, ‘y’: 2}</li></ul></li><li><p>字典的访问</p><ul><li><code>d[key]</code> 返回key对应的值value，key不存在时抛出异常KeyError</li><li><code>get(key[, default])</code> 返回key对应的值value，key不存在时返回缺省值默认为None</li><li><code>setdefault(key[, default])</code> 返回key对应的值value，key不存在时添加key，value为default，并返回default，默认为None</li></ul></li><li><p>字典增加和修改：</p><ul><li><code>d[key] = value</code> 将key对应的值改为value，若key不存在这添加新的kv对</li><li><code>update([other])</code> 使用另一个字典的kv对更新本字典，若key存在就覆盖该key对应的值，若key不存在，就添加。如<code>d.update(x=6)</code>或<code>d.update({&#39;red&#39;: 3, &#39;x&#39;: 9})</code>或<code>d.update(((&#39;red&#39;, 666),(&#39;green&#39;, 333)))</code></li></ul></li><li><p>字典删除：</p><ul><li><code>d.pop(key[, default])</code> 若key存在，移除它，并返回key对应的value；若key不存在，返回给定的default，default未设置，key不存在时抛出异常KeyError</li><li><code>d.popitem()</code> 移除并返回字典中最后一个键值对，若字典为空，抛出KeyError异常</li><li><code>d.clear()</code> 清空字典</li><li><code>del d[&#39;x&#39;]</code> 删除key为x的键值对，本质是删除对象引用</li></ul></li><li><p>字典遍历：</p><ul><li>遍历key：<code>for k in d: print(k)</code> 打印的是字典中的key</li><li>遍历key：<code>for k in d.keys(): print(k)</code> 打印的是字典中的key</li><li>遍历key：<code>for k in d.items(): print(k[0])</code> 打印的是字典中的key</li><li>遍历value：<code>for k in d: print(d[k])</code> 打印key对应的value</li><li>遍历value：<code>for k in d.keys(): print(d.get(k))</code> 打印key对应的value</li><li>遍历value：<code>for v in d.values(): print(v)</code> 打印字典中的value</li><li>遍历value：<code>for v in d.items(): print(v[1])</code> 打印字典中的value</li><li>遍历item：<code>for item in d.items(): print(item)</code> 打印键值对</li><li>遍历item：<code>for item in d.items(): print(item[0], item[1])</code> 打印键值对</li><li>遍历item：<code>for k, v in d.items(): print(k, v)</code> 打印键值对</li></ul></li><li><p>字典的遍历移除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">d = dict(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>, e=<span class="string">'sss'</span>)</span><br><span class="line">keys = []</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="keyword">if</span> isinstance(v, str):</span><br><span class="line">        keys.append(k)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> keys:</span><br><span class="line">    d.pop(k)</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></li><li><p>defaultdict类</p><ul><li><code>collections.defaultdict([default_factory[, ...]])</code> 第一个参数是default_factory，缺省是None，它提供一个初始化函数，当key不存在时，会调用这个工厂函数的<strong>missing</strong>(key)的方法，返回一个根据default_factory参数的默认值给这个key的value</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常规方法</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">d1 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="string">'abcdef'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(random.randint(<span class="number">1</span>, <span class="number">5</span>)):</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> d1.keys():</span><br><span class="line">            d1[k] = []</span><br><span class="line">        d1[k].append(i)</span><br><span class="line">print(d1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过defaultdict类</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">d2 = defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="string">'abcdef'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(random.randint(<span class="number">1</span>, <span class="number">5</span>)):</span><br><span class="line">        d2[k].append(i)</span><br><span class="line">print(d2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;'a': [0, 1], 'b': [0], 'c': [0, 1, 2, 3], 'd': [0], 'e': [0, 1, 2, 3, 4], 'f': [0, 1]&#125;</span></span><br><span class="line"><span class="string">defaultdict(&lt;class 'list'&gt;, &#123;'a': [0, 1, 2, 3], 'b': [0, 1], 'c': [0], 'd': [0], 'e': [0, 1], 'f': [0, 1, 2]&#125;)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></li><li><p>OrderedDict记录顺序：</p><ul><li><code>collections.OrderedDict([items])</code> key并不是按照加入的顺序排列的，可以使用OrderedDict来记录顺序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">'banana'</span>:<span class="number">3</span>, <span class="string">'apple'</span>:<span class="number">4</span>, <span class="string">'pear'</span>:<span class="number">1</span>, <span class="string">'oranger'</span>:<span class="number">2</span>&#125;</span><br><span class="line">print(d)</span><br><span class="line">keys = list(d.keys())  <span class="comment"># 获取key转化为list</span></span><br><span class="line">random.shuffle(keys)  <span class="comment"># 打乱顺序</span></span><br><span class="line">print(keys)</span><br><span class="line">od = OrderedDict()</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">    od[key] = d[key]</span><br><span class="line">print(od)</span><br><span class="line">print(od.keys())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;'banana': 3, 'apple': 4, 'pear': 1, 'oranger': 2&#125;</span></span><br><span class="line"><span class="string">['oranger', 'pear', 'apple', 'banana']</span></span><br><span class="line"><span class="string">OrderedDict([('oranger', 2), ('pear', 1), ('apple', 4), ('banana', 3)])</span></span><br><span class="line"><span class="string">odict_keys(['oranger', 'pear', 'apple', 'banana'])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>集合(set)</p><ul><li><p>一个无序的不重复的元素序列</p></li><li><p>是非线性数据结构，使用大括号{}表示</p></li><li><p>集合的基本应用：元素测试、list和tuple元素去重</p></li><li><p>集合支持一些数学操作：并集(union)、交集(intersection)、差集(difference)、对称差集(symmetric difference)</p></li><li><p>集合的创建：</p><ul><li><code>set_name = {value1, value2, ...}</code> 类似于字典的创建</li><li><code>set_name = set()</code> 空集合必须用set()创建，而不能用{}，这样创建出来的是字典</li><li><code>set_name = set(list_name)</code> 把list转化为set类型</li></ul></li><li><p>利用集合去重</p><ul><li>列表去重：<code>set_name = set(list_name)</code></li><li>字符串去重：<code>set_name = set(string)</code></li><li>元组去重：<code>set_name = set(tuple)</code></li></ul></li><li><p>集合的数学操作</p><ul><li>并集：<code>A | B</code> 或 <code>A.union(B)</code>  # A和B的元素都有，且不会重复</li><li>交集：<code>A &amp; B</code> 或 <code>A.intersection(B)</code>  # A和B的共同有的元素</li><li>差集：<code>A - B</code> 或 <code>A.difference(B)</code>  # A中有，但B中没有的元素</li><li>对称差集：<code>A ^ B</code> 或 <code>A.symmetric_difference(B)</code>  # A有或B有，但不是它们都有，除开公共有的元素</li></ul></li><li><p>集合判断包含、子集：</p><ul><li>A包含B：<code>A.issuperset(B)</code> 或 <code>A &gt;= B</code></li><li>B是A的子集：<code>B.issubset(A)</code> 或 <code>B &lt;= A</code></li></ul></li><li><p>集合推导式： <code>s = {x for x in &#39;abcdef&#39; if x not in &#39;abc&#39;}</code></p></li><li><p>集合新增元素</p><ul><li>增加单个元素：<code>A.add(3)</code></li><li>增加一组元素：<code>A.update([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</code></li></ul></li><li><p>删除集合元素</p><ul><li>直接删除指定元素：<code>A.remove(3)</code>  # 若元素不存在会报错，建议用discard()方法</li><li>如果集合存在指定元素，则删除该元素：<code>A.discard(&#39;a&#39;)</code></li><li>随机删除元素：<code>A.pop()</code>  # set 集合的 pop 方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除</li><li>清空集合：<code>A.clear()</code></li></ul></li><li><p>判断两个集合包含的元素是否相同：<code>A.isdisjoint(B)</code>  # 若相同返回True, 否则返回False</p></li></ul></li></ul><h2 id="42-python-新增内置数据结构–bytes、bytearray"><a href="#42-python-新增内置数据结构–bytes、bytearray" class="headerlink" title="42. python 新增内置数据结构–bytes、bytearray"></a>42. python 新增内置数据结构–bytes、bytearray</h2><h2 id="43-空"><a href="#43-空" class="headerlink" title="43. 空"></a>43. 空</h2><h2 id="44-python中参数类型有哪些"><a href="#44-python中参数类型有哪些" class="headerlink" title="44. python中参数类型有哪些"></a>44. python中参数类型有哪些</h2><h2 id="45-python中函数传参过程"><a href="#45-python中函数传参过程" class="headerlink" title="45. python中函数传参过程"></a>45. python中函数传参过程</h2><h2 id="46-args和-kwargs"><a href="#46-args和-kwargs" class="headerlink" title="46. args和*kwargs"></a>46. <em>args和*</em>kwargs</h2><h2 id="47-实参和形参的区别"><a href="#47-实参和形参的区别" class="headerlink" title="47. 实参和形参的区别"></a>47. 实参和形参的区别</h2><h2 id="48-python中可变对象和不可变对象"><a href="#48-python中可变对象和不可变对象" class="headerlink" title="48. python中可变对象和不可变对象"></a>48. python中可变对象和不可变对象</h2><h2 id="49-python中正则使用方式"><a href="#49-python中正则使用方式" class="headerlink" title="49. python中正则使用方式"></a>49. python中正则使用方式</h2><blockquote><p>手写正则邮箱地址</p></blockquote><h2 id="50-Numpy与Scipy的区别"><a href="#50-Numpy与Scipy的区别" class="headerlink" title="50. Numpy与Scipy的区别"></a>50. Numpy与Scipy的区别</h2><h2 id="51-python中反射机制"><a href="#51-python中反射机制" class="headerlink" title="51. python中反射机制"></a>51. python中反射机制</h2><h2 id="52-python中如何管理依赖"><a href="#52-python中如何管理依赖" class="headerlink" title="52. python中如何管理依赖"></a>52. python中如何管理依赖</h2><blockquote><p>每个项目创建独立的虚拟环境</p></blockquote><h2 id="53-如何分析python代码性能"><a href="#53-如何分析python代码性能" class="headerlink" title="53. 如何分析python代码性能"></a>53. 如何分析python代码性能</h2><h2 id="54-列表的线性访问和随机访问"><a href="#54-列表的线性访问和随机访问" class="headerlink" title="54. 列表的线性访问和随机访问"></a>54. 列表的线性访问和随机访问</h2><blockquote><p>random.random()用于生成一个0到1的随机符点数: 0 &lt;= n &lt; 1.0 。</p></blockquote><blockquote><p>random.uniform(a, b)，用于生成一个指定范围内的随机符点数，两个参数其中一个是上限，一个是下限。如果a &gt; b，则生成的随机数n: a &lt;= n &lt;= b。如果 a &lt; b， 则 b &lt;= n &lt;= a 。</p></blockquote><blockquote><p>random.randint(a, b)，用于生成一个指定范围内的整数。其中参数a是下限，参数b是上限，生成的随机数n: a &lt;= n &lt;= b。</p></blockquote><blockquote><p>random.randrange([start], stop[, step])，从指定范围内，按指定基数递增的集合中 获取一个随机数。</p></blockquote><blockquote><p>random.choice(sequence)从序列中获取一个随机元素，参数sequence表示一个有序类型。</p></blockquote><blockquote><p>random.shuffle(x[, random])，用于将一个列表中的元素打乱。</p></blockquote><blockquote><p>random.sample(sequence, k)，从指定序列中随机获取指定长度的片断。sample函数不会修改原有序列。</p></blockquote><h2 id="55-Python中单下划线和双下划线"><a href="#55-Python中单下划线和双下划线" class="headerlink" title="55. Python中单下划线和双下划线"></a>55. Python中单下划线和双下划线</h2><h2 id="56-Python的作用域以及Python搜索变量的顺序"><a href="#56-Python的作用域以及Python搜索变量的顺序" class="headerlink" title="56. Python的作用域以及Python搜索变量的顺序"></a>56. Python的作用域以及Python搜索变量的顺序</h2><blockquote><p>Python作用域简单说就是一个变量的命名空间。代码中变量被赋值的位置，就决定了哪些范围的对象可以访问这个变量，这个范围就是变量的作用域。<br>在Python中，只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域。<br>Python的变量名解析机制也称为 LEGB 法则：本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）</p></blockquote><h2 id="57-编码与解码"><a href="#57-编码与解码" class="headerlink" title="57. 编码与解码"></a>57. 编码与解码</h2><blockquote><p>编码：gbk =&gt; unicode =&gt; utf16 =&gt; url解码</p></blockquote><blockquote><p>解码：url解码 =&gt; utf16 =&gt;unicode =&gt; gbk</p></blockquote><p>eg:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.quote(line.decode(<span class="string">"gbk"</span>).encode(<span class="string">"utf-16"</span>))</span><br></pre></td></tr></table></figure><h2 id="58-字符串格式化"><a href="#58-字符串格式化" class="headerlink" title="58. 字符串格式化"></a>58. 字符串格式化</h2><h2 id="59-增量赋值"><a href="#59-增量赋值" class="headerlink" title="59. 增量赋值"></a>59. 增量赋值</h2><ul><li><p>x += 1</p></li><li><p>x *= 1</p></li><li><p>x = x + 1</p></li></ul><h2 id="60-字典推导式"><a href="#60-字典推导式" class="headerlink" title="60. 字典推导式"></a>60. 字典推导式</h2><h2 id="61-exec对字符串执行和eval对字符串求值"><a href="#61-exec对字符串执行和eval对字符串求值" class="headerlink" title="61. exec对字符串执行和eval对字符串求值"></a>61. exec对字符串执行和eval对字符串求值</h2><h2 id="62-raise语句的作用"><a href="#62-raise语句的作用" class="headerlink" title="62. raise语句的作用"></a>62. raise语句的作用</h2><h2 id="63-yeild语句的作用"><a href="#63-yeild语句的作用" class="headerlink" title="63. yeild语句的作用"></a>63. yeild语句的作用</h2><h2 id="64-socket编程"><a href="#64-socket编程" class="headerlink" title="64. socket编程"></a>64. socket编程</h2><h2 id="65-urllib和urllib2"><a href="#65-urllib和urllib2" class="headerlink" title="65. urllib和urllib2"></a>65. urllib和urllib2</h2><h2 id="66-requests"><a href="#66-requests" class="headerlink" title="66. requests"></a>66. requests</h2><h2 id="67-Beautiful-Soup"><a href="#67-Beautiful-Soup" class="headerlink" title="67. Beautiful Soup"></a>67. Beautiful Soup</h2><h2 id="68-select-poll和epoll"><a href="#68-select-poll和epoll" class="headerlink" title="68. select,poll和epoll"></a>68. select,poll和epoll</h2><h2 id="69-python中实现IO多路复用"><a href="#69-python中实现IO多路复用" class="headerlink" title="69. python中实现IO多路复用"></a>69. python中实现IO多路复用</h2><h2 id="68-python常用的并发网络库"><a href="#68-python常用的并发网络库" class="headerlink" title="68. python常用的并发网络库"></a>68. python常用的并发网络库</h2><ul><li>tornado</li><li>gevent</li><li>asyncio</li></ul><h2 id="70-python-decimal精确计算"><a href="#70-python-decimal精确计算" class="headerlink" title="70. python decimal精确计算"></a>70. python decimal精确计算</h2><p><strong><a href="https://blog.csdn.net/weixin_37989267/article/details/79473706" target="_blank" rel="noopener">python decimal精确计算</a></strong></p><ul><li>(1). Decimal接收int和string类型参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不能传入浮点数据，因为浮点数据就不准确</span></span><br><span class="line">a = Decimal(<span class="number">3.33</span>)*<span class="number">100</span></span><br><span class="line">b = Decimal(<span class="string">'3.33'</span>)*<span class="number">100</span></span><br><span class="line">c = Decimal(<span class="number">3</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Decimal('333.0000000000000071054273576')</span></span><br><span class="line"><span class="string">Decimal('333.00')</span></span><br><span class="line"><span class="string">Decimal('3')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><ul><li>(2). 浮点数据转换为Decimal类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">Decimal.from_float(<span class="number">2.222</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Decimal('2.221999999999999975131004248396493494510650634765625')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><ul><li>(3). 设定有效数字</li></ul><blockquote><p>特别注意，如果prec的长度比数字的长度小的话，扩充*100时就会出错</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留6个有效数字</span></span><br><span class="line">getcontext().prec = <span class="number">6</span></span><br><span class="line">Decimal(<span class="number">1</span>)/Decimal(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Decimal('0.142857')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><ul><li>(4). 四舍五入，保留几位小数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留两位小数</span></span><br><span class="line">Decimal(<span class="string">'0.2335662'</span>).quantize(Decimal(<span class="string">'0.00'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Decimal('0.23')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><ul><li>(5). Decimal转化为字符串类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留两位小数</span></span><br><span class="line">str(Decimal(<span class="string">'0.2335662'</span>).quantize(Decimal(<span class="string">'0.00'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">'0.23'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要对python语言基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程语言-python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-python/"/>
    
    
  </entry>
  
  <entry>
    <title>Web与前端知识点总结归纳</title>
    <link href="http://yoursite.com/2020/05/08/Web%E4%B8%8E%E5%89%8D%E7%AB%AF/"/>
    <id>http://yoursite.com/2020/05/08/Web%E4%B8%8E%E5%89%8D%E7%AB%AF/</id>
    <published>2020-05-08T15:05:08.000Z</published>
    <updated>2020-05-13T17:36:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要对Web基础和前端框架知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。</p></blockquote><a id="more"></a><div style='display: none'><!-- TOC --><ul><li><a href="#web基础">Web基础</a><ul><li><a href="#1-常用的网络传输协议">1. 常用的网络传输协议</a></li><li><a href="#2-常见的状态码">2. 常见的状态码</a></li><li><a href="#3-三次握手">3. 三次握手</a></li><li><a href="#4-四次挥手">4. 四次挥手</a></li></ul></li><li><a href="#django">Django</a></li><li><a href="#flask">Flask</a></li><li><a href="#tornado">Tornado</a></li><li><a href="#jquery">jQuery</a></li><li><a href="#vue">Vue</a></li><li><a href="#angularjs">AngularJS</a></li><li><a href="#react">React</a></li></ul><!-- /TOC --></div><h1 id="Web基础"><a href="#Web基础" class="headerlink" title="Web基础"></a>Web基础</h1><h2 id="1-常用的网络传输协议"><a href="#1-常用的网络传输协议" class="headerlink" title="1. 常用的网络传输协议"></a>1. 常用的网络传输协议</h2><ul><li>TCP：传输控制协议，可靠传输，面向连接</li><li>UDP：用户数据包协议，不可靠传输，面向无连接</li><li>FTP：文件传输协议,用于上传和下载文件</li><li>HTTP：超文本传输协议，基于TCP/IP通信协议，面向对象</li><li>SMTP：邮件传输协议</li><li>TELNET：Internet远程登录服务的标准协议和主要方式</li><li>DNS：域名系统，将域名解析为ip地址</li></ul><h2 id="2-常见的状态码"><a href="#2-常见的状态码" class="headerlink" title="2. 常见的状态码"></a>2. 常见的状态码</h2><table><thead><tr><th align="center">状态码</th><th align="left">状态</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">200</td><td align="left">Ok</td><td align="left">请求成功</td></tr><tr><td align="center">400</td><td align="left">Bad Request</td><td align="left">请求语法错误，不能被服务器解析</td></tr><tr><td align="center">401</td><td align="left">Unauthorized</td><td align="left">未经授权，需与www-Authenticate一起用</td></tr><tr><td align="center">403</td><td align="left">Forbidden</td><td align="left">服务器收到请求，但拒绝提供服务</td></tr><tr><td align="center">404</td><td align="left">Not Found</td><td align="left">请求资源不存在</td></tr><tr><td align="center">500</td><td align="left">Internal Server Error</td><td align="left">服务器发生不可预期的错误</td></tr><tr><td align="center">503</td><td align="left">Server Unavailable</td><td align="left">服务器当前请求不可用</td></tr></tbody></table><h2 id="3-三次握手"><a href="#3-三次握手" class="headerlink" title="3. 三次握手"></a>3. 三次握手</h2><ul><li>第一次握手：建立连接时，客户端发送SYN（SYN=x）到服务器，有主动打开状态进入SYN_SENT状态，等待服务器确认。</li><li>第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=x+1）,同时自己也发送一个SYN包（syn=y），即SYN+ACK包，服务器进入SYN_RECV状态。</li><li>第三次握手：客户端收到服务器的SYN+ACK包，想服务器发送确认ACK包（ACK=y+1）,发送完毕，客户端和服务器进入ESTABLISHED状态，完成握手。</li></ul><h2 id="4-四次挥手"><a href="#4-四次挥手" class="headerlink" title="4. 四次挥手"></a>4. 四次挥手</h2><h1 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h1><h1 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h1><h1 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h1><h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h1 id="AngularJS"><a href="#AngularJS" class="headerlink" title="AngularJS"></a>AngularJS</h1><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要对Web基础和前端框架知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端知识" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Web基础" scheme="http://yoursite.com/tags/Web%E5%9F%BA%E7%A1%80/"/>
    
      <category term="前端框架" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
      <category term="知识回顾" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识点总结归纳</title>
    <link href="http://yoursite.com/2020/05/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2020/05/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/</id>
    <published>2020-05-08T15:05:08.000Z</published>
    <updated>2020-05-13T18:10:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要对操作系统和Linux基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。</p></blockquote><a id="more"></a><div style='display: none'><!-- TOC --><ul><li><a href="#操作系统">操作系统</a><ul><li><a href="#1-进程线程以及协程间的区别">1. 进程、线程以及协程间的区别</a></li><li><a href="#2-线程间通信的方式">2. 线程间通信的方式</a></li><li><a href="#3-进程间通信的方式">3. 进程间通信的方式</a></li><li><a href="#4-如何实现协程">4. 如何实现协程</a></li><li><a href="#5-并行与并发">5. 并行与并发</a></li><li><a href="#6-同步与异步">6. 同步与异步</a></li><li><a href="#7-阻塞与非阻塞">7. 阻塞与非阻塞</a></li><li><a href="#8-僵尸进程孤儿进程守护进程">8. 僵尸进程、孤儿进程、守护进程</a></li><li><a href="#9-线程安全">9. 线程安全</a></li><li><a href="#10-多线程资源竞争怎么解决">10. 多线程资源竞争，怎么解决</a></li><li><a href="#11-有几种锁">11. 有几种锁</a></li><li><a href="#12-线程池原理与实现">12. 线程池原理与实现</a></li><li><a href="#13-调度算法">13. 调度算法</a></li></ul></li><li><a href="#linux">Linux</a><ul><li><a href="#1-linux常用命令">1. linux常用命令</a></li><li><a href="#2-linux内存管理机制">2. Linux内存管理机制</a></li></ul></li></ul><!-- /TOC --></div><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-进程、线程以及协程间的区别"><a href="#1-进程、线程以及协程间的区别" class="headerlink" title="1. 进程、线程以及协程间的区别"></a>1. 进程、线程以及协程间的区别</h2><p><strong><a href="https://blog.csdn.net/holysll/article/details/89344794" target="_blank" rel="noopener">线程、进程、协程、锁的总结</a></strong></p><h2 id="2-线程间通信的方式"><a href="#2-线程间通信的方式" class="headerlink" title="2. 线程间通信的方式"></a>2. 线程间通信的方式</h2><h2 id="3-进程间通信的方式"><a href="#3-进程间通信的方式" class="headerlink" title="3. 进程间通信的方式"></a>3. 进程间通信的方式</h2><h2 id="4-如何实现协程"><a href="#4-如何实现协程" class="headerlink" title="4. 如何实现协程"></a>4. 如何实现协程</h2><h2 id="5-并行与并发"><a href="#5-并行与并发" class="headerlink" title="5. 并行与并发"></a>5. 并行与并发</h2><h2 id="6-同步与异步"><a href="#6-同步与异步" class="headerlink" title="6. 同步与异步"></a>6. 同步与异步</h2><h2 id="7-阻塞与非阻塞"><a href="#7-阻塞与非阻塞" class="headerlink" title="7. 阻塞与非阻塞"></a>7. 阻塞与非阻塞</h2><h2 id="8-僵尸进程、孤儿进程、守护进程"><a href="#8-僵尸进程、孤儿进程、守护进程" class="headerlink" title="8. 僵尸进程、孤儿进程、守护进程"></a>8. 僵尸进程、孤儿进程、守护进程</h2><h2 id="9-线程安全"><a href="#9-线程安全" class="headerlink" title="9. 线程安全"></a>9. 线程安全</h2><h2 id="10-多线程资源竞争，怎么解决"><a href="#10-多线程资源竞争，怎么解决" class="headerlink" title="10. 多线程资源竞争，怎么解决"></a>10. 多线程资源竞争，怎么解决</h2><h2 id="11-有几种锁"><a href="#11-有几种锁" class="headerlink" title="11. 有几种锁"></a>11. 有几种锁</h2><ul><li><p>互斥锁</p></li><li><p>可重入锁</p></li><li><p>死锁</p></li></ul><h2 id="12-线程池原理与实现"><a href="#12-线程池原理与实现" class="headerlink" title="12. 线程池原理与实现"></a>12. 线程池原理与实现</h2><h2 id="13-调度算法"><a href="#13-调度算法" class="headerlink" title="13. 调度算法"></a>13. 调度算法</h2><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="1-linux常用命令"><a href="#1-linux常用命令" class="headerlink" title="1. linux常用命令"></a>1. linux常用命令</h2><h2 id="2-Linux内存管理机制"><a href="#2-Linux内存管理机制" class="headerlink" title="2. Linux内存管理机制"></a>2. Linux内存管理机制</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要对操作系统和Linux基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="进程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>数据库知识点总结归纳</title>
    <link href="http://yoursite.com/2020/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2020/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/</id>
    <published>2020-05-08T15:05:08.000Z</published>
    <updated>2020-05-13T17:45:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要对数据库基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。</p></blockquote><a id="more"></a><div style='display: none'><!-- TOC --><ul><li><a href="#数据库常识">数据库常识</a><ul><li><a href="#1-什么是索引">1. 什么是索引</a></li><li><a href="#2-事务的特性">2. 事务的特性</a></li><li><a href="#3-存储过程">3. 存储过程</a></li><li><a href="#4-数据库怎么优化查询效率">4. 数据库怎么优化查询效率</a></li><li><a href="#5-数据库优化方案">5. 数据库优化方案</a></li><li><a href="#6-什么是悲观锁">6. 什么是悲观锁</a></li><li><a href="#7-什么是乐观锁">7. 什么是乐观锁</a></li><li><a href="#8-什么是缓存穿透">8. 什么是缓存穿透</a></li><li><a href="#9-什么是缓存击穿">9. 什么是缓存击穿</a></li><li><a href="#10-什么是缓存雪崩">10. 什么是缓存雪崩</a></li><li><a href="#11-sql查询基础">11. SQL查询基础</a></li><li><a href="#12-排序">12. 排序</a></li><li><a href="#13-聚合函数">13. 聚合函数</a></li><li><a href="#14-分组">14. 分组</a></li><li><a href="#15-关联查询">15. 关联查询</a></li><li><a href="#16-limit的用法">16. LIMIT的用法</a></li><li><a href="#17-case-when">17. case when</a></li></ul></li><li><a href="#mysql数据库">Mysql数据库</a><ul><li><a href="#1-mysql-常用数据类型">1. mysql 常用数据类型</a></li><li><a href="#2-mysql数据库引擎">2. mysql数据库引擎</a></li><li><a href="#3-mysql的索引类型">3. mysql的索引类型</a></li><li><a href="#4-mysql-几种锁的区别">4. Mysql 几种锁的区别</a></li><li><a href="#5-mysql事务原理特性事务并发控制">5. mysql事务原理、特性、事务并发控制</a></li></ul></li><li><a href="#redis数据库">Redis数据库</a><ul><li><a href="#1-redis的原理">1. redis的原理</a></li><li><a href="#2-持久化机制">2. 持久化机制</a></li><li><a href="#3-redis-和-memcached-的主要区别">3. redis 和 memcached 的主要区别</a></li><li><a href="#4-redis-高可用">4. Redis 高可用</a></li><li><a href="#5-redis-高并发">5. Redis 高并发</a></li></ul></li><li><a href="#mongodb数据库">MongoDB数据库</a></li><li><a href="#hive数据库">Hive数据库</a></li><li><a href="#hbase数据库">Hbase数据库</a></li><li><a href="#hadoop生态">Hadoop生态</a></li></ul><!-- /TOC --></div><h1 id="数据库常识"><a href="#数据库常识" class="headerlink" title="数据库常识"></a>数据库常识</h1><h2 id="1-什么是索引"><a href="#1-什么是索引" class="headerlink" title="1. 什么是索引"></a>1. 什么是索引</h2><h2 id="2-事务的特性"><a href="#2-事务的特性" class="headerlink" title="2. 事务的特性"></a>2. 事务的特性</h2><ul><li>原子性(Atomicity)</li></ul><blockquote><p>事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。</p></blockquote><ul><li>一致性(Consistency)</li></ul><blockquote><p>几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。</p></blockquote><ul><li>隔离性(Isolation)</li></ul><blockquote><p>事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。</p></blockquote><ul><li>持久性(Durability)</li></ul><blockquote><p>对于任意已交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现异常。</p></blockquote><h2 id="3-存储过程"><a href="#3-存储过程" class="headerlink" title="3. 存储过程"></a>3. 存储过程</h2><h2 id="4-数据库怎么优化查询效率"><a href="#4-数据库怎么优化查询效率" class="headerlink" title="4. 数据库怎么优化查询效率"></a>4. 数据库怎么优化查询效率</h2><h2 id="5-数据库优化方案"><a href="#5-数据库优化方案" class="headerlink" title="5. 数据库优化方案"></a>5. 数据库优化方案</h2><h2 id="6-什么是悲观锁"><a href="#6-什么是悲观锁" class="headerlink" title="6. 什么是悲观锁"></a>6. 什么是悲观锁</h2><h2 id="7-什么是乐观锁"><a href="#7-什么是乐观锁" class="headerlink" title="7. 什么是乐观锁"></a>7. 什么是乐观锁</h2><h2 id="8-什么是缓存穿透"><a href="#8-什么是缓存穿透" class="headerlink" title="8. 什么是缓存穿透"></a>8. 什么是缓存穿透</h2><h2 id="9-什么是缓存击穿"><a href="#9-什么是缓存击穿" class="headerlink" title="9. 什么是缓存击穿"></a>9. 什么是缓存击穿</h2><h2 id="10-什么是缓存雪崩"><a href="#10-什么是缓存雪崩" class="headerlink" title="10. 什么是缓存雪崩"></a>10. 什么是缓存雪崩</h2><h2 id="11-SQL查询基础"><a href="#11-SQL查询基础" class="headerlink" title="11. SQL查询基础"></a>11. SQL查询基础</h2><p><strong><a href="https://www.runoob.com/sql/sql-tutorial.html" target="_blank" rel="noopener">SQL基础知识</a></strong></p><ul><li>select语句</li></ul><blockquote><p>格式：select 字段 from 表名； # 全部字段可以用 *</p></blockquote><ul><li>where 用于限制查询的结果</li></ul><blockquote><p>格式：where 字段=’xxx’;  # 查询条件&gt; &lt; &gt;= &lt;= = !=</p></blockquote><ul><li><p>与(AND)或(OR)</p></li><li><p>在(IN)不在(NOT IN)</p></li><li><p>空(NULL)非空(NOT NULL)</p></li><li><p>全部(ALL) 任一(ANY)</p></li><li><p>在[a,b]之间</p></li></ul><blockquote><p>格式：between a and b</p></blockquote><ul><li>排重DISTINCT</li></ul><blockquote><p>格式：select DISTINCT 字段 from 表名；</p></blockquote><h2 id="12-排序"><a href="#12-排序" class="headerlink" title="12. 排序"></a>12. 排序</h2><ul><li>ORDER BY语句</li></ul><blockquote><p>格式：select 字段 from 表名 where 条件 ORDER BY 字段；</p></blockquote><ul><li>升序(ASC)与降序(DESC)</li></ul><blockquote><p>格式：select 字段 from 表名 where 条件 ORDER BY 字段 ASC;<br>格式：select 字段 from 表名 where 条件 ORDER BY 字段 DESC;  </p></blockquote><ul><li>多项排序</li></ul><blockquote><p>格式：select 字段 from 表名 where 条件 ORDER BY 字段 ASC|DESC，字段ASC|DESC;</p></blockquote><h2 id="13-聚合函数"><a href="#13-聚合函数" class="headerlink" title="13. 聚合函数"></a>13. 聚合函数</h2><blockquote><p>把 select 语句的查询结果汇聚成一个结果，这样的函数叫聚合函数。</p></blockquote><ul><li><p>最大值(MAX)</p></li><li><p>最小值(MIN)</p></li><li><p>平均值(SVG)</p></li><li><p>求和(SUM)</p></li><li><p>统计数量(COUNT)</p></li></ul><h2 id="14-分组"><a href="#14-分组" class="headerlink" title="14. 分组"></a>14. 分组</h2><ul><li>GROUP BY</li></ul><blockquote><p>格式：select 组函数 from 表 where 条件 group by 字段;</p></blockquote><ul><li>HAVING 组判断条件，它的真假决定一组数据是否返回</li></ul><blockquote><p>格式：select 组函数 from 表 where 条件 group by 字段 having 组判断条件;</p></blockquote><h2 id="15-关联查询"><a href="#15-关联查询" class="headerlink" title="15. 关联查询"></a>15. 关联查询</h2><ul><li>JOIN：如果表中有至少一个匹配，则返回行  </li></ul><blockquote><p>格式：select * from a join b on a.id=b.id;</p></blockquote><ul><li>内连接(INNER JOIN)：只返回两个表中联结字段相等的行</li></ul><blockquote><p>格式：select * from a inner join b on a.id=b.id;  # 其中inner可以省略，等同于JOIN的用法</p></blockquote><ul><li>左外连接(LEFT JOIN 或 LEFT OUTER JOIN)：即使右表中没有匹配，也从左表返回所有的行</li></ul><blockquote><p>格式：select * from a left outer join b on a.id=b.aid;  # 其中outer可忽略</p></blockquote><ul><li>右外连接(RIGHT JOIN 或 RIGHT OUTER JOIN)：即使左表中没有匹配，也从右表返回所有的行</li></ul><blockquote><p>格式：select * from a right outer join b on a.id=b.aid;  # 其中outer可忽略</p></blockquote><ul><li>全连接(FULL JOIN 或 FULL OUTER JOIN): 只要其中一个表中存在匹配，就返回行。相当于左外连接+右外链接，注意mysql不支持全连接</li></ul><blockquote><p>格式：select * from a full outer join b on a.id=b.id。# 其中outer可忽略</p></blockquote><ul><li>自连接：自连接意思是把自身表当成另外一张表看待，互相关联查询，连接方式可以使用以上的内外连接，这种连接方式可以解决很多奇怪的问题。</li></ul><blockquote><p>格式：SELECT ab.* from a ab,a ac where ab.id&gt;ac.id</p></blockquote><h2 id="16-LIMIT的用法"><a href="#16-LIMIT的用法" class="headerlink" title="16. LIMIT的用法"></a>16. LIMIT的用法</h2><blockquote><p>格式：select * from student limit 10;  # 查询前10条数据，显示1-10条数据</p></blockquote><blockquote><p>格式：select * from student limit 1,10;  # 查询从第2行开始，累加10条id记录，共显示id为2….11</p></blockquote><blockquote><p>格式：select * from student limit 5,10;  # 查询从第6行开始向前加10条数据，共显示id为6,7….15  </p></blockquote><blockquote><p>格式：select * from student limit i,n;  # i: 为查询结果的索引值(默认从0开始),当i=0时可省略i; n: 为查询结果返回的数量</p></blockquote><h2 id="17-case-when"><a href="#17-case-when" class="headerlink" title="17. case when"></a>17. case when</h2><p><strong><a href="https://www.cnblogs.com/aipan/p/7770611.html" target="_blank" rel="noopener">CASE WHEN 及 SELECT CASE WHEN的用法</a></strong><br><strong><a href="https://www.cnblogs.com/cx-zyq/archive/2013/05/16/3082295.html" target="_blank" rel="noopener">SQL Case when 的使用方法</a></strong></p><ul><li>简单Case函数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CASE sex</span><br><span class="line">WHEN '1' THEN '男'</span><br><span class="line">WHEN '2' THEN '女'</span><br><span class="line">ELSE '其他' <span class="keyword">END</span></span><br></pre></td></tr></table></figure><ul><li>Case搜索函数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CASE WHEN sex = '1' THEN '男'</span><br><span class="line">WHEN sex = '2' THEN '女'</span><br><span class="line">ELSE '其他' <span class="keyword">END</span></span><br></pre></td></tr></table></figure><blockquote><p>两种方式，可以实现相同的功能。简单Case函数的写法相对比较简洁，但是和Case搜索函数相比，功能方面会有些限制，比如写判断式。还有一个需要注意的问题，Case函数只返回第一个符合条件的值，剩下的Case部分将会被自动忽略。</p></blockquote><p><strong>实例分析：</strong></p><p>(1). 已知数据按照另外一种方式进行分组，分析</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*根据这个国家人口数据，统计亚洲和北美洲的人口数量*/</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">SUM</span>(population),</span><br><span class="line"><span class="keyword">CASE</span> country  <span class="keyword">WHEN</span> <span class="string">'中国'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="string">'印度'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="string">'日本'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="string">'美国'</span> <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="string">'加拿大'</span>  <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="string">'墨西哥'</span>  <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'其他'</span> <span class="keyword">END</span></span><br><span class="line"><span class="keyword">FROM</span>    Table_A</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">CASE</span> country </span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'中国'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'印度'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'日本'</span> <span class="keyword">THEN</span> <span class="string">'亚洲'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'美国'</span> <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'加拿大'</span>   <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'墨西哥'</span>   <span class="keyword">THEN</span> <span class="string">'北美洲'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'其他'</span> <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*判断工资的等级，并统计每一等级的人数*/</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary &lt;= <span class="number">500</span> <span class="keyword">THEN</span> <span class="string">'1'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">500</span> <span class="keyword">AND</span> salary &lt;= <span class="number">600</span>  <span class="keyword">THEN</span> <span class="string">'2'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">600</span> <span class="keyword">AND</span> salary &lt;= <span class="number">800</span>  <span class="keyword">THEN</span> <span class="string">'3'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">800</span> <span class="keyword">AND</span> salary &lt;= <span class="number">1000</span> <span class="keyword">THEN</span> <span class="string">'4'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span> salary_class, <span class="comment">-- 别名命名</span></span><br><span class="line"><span class="keyword">COUNT</span>(*)  <span class="keyword">FROM</span>    Table_A</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary &lt;= <span class="number">500</span> <span class="keyword">THEN</span> <span class="string">'1'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">500</span> <span class="keyword">AND</span> salary &lt;= <span class="number">600</span>  <span class="keyword">THEN</span> <span class="string">'2'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">600</span> <span class="keyword">AND</span> salary &lt;= <span class="number">800</span>  <span class="keyword">THEN</span> <span class="string">'3'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary &gt; <span class="number">800</span> <span class="keyword">AND</span> salary &lt;= <span class="number">1000</span> <span class="keyword">THEN</span> <span class="string">'4'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>(2). 用一个SQL语句完成不同条件的分组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按照国家和性别进行分组*/</span></span><br><span class="line"><span class="keyword">SELECT</span> country, </span><br><span class="line"><span class="keyword">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="string">'1'</span> <span class="keyword">THEN</span>  population <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>),  <span class="comment">--男性人口</span></span><br><span class="line"><span class="keyword">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="string">'2'</span> <span class="keyword">THEN</span>  population <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)   <span class="comment">--女性人口</span></span><br><span class="line"><span class="keyword">FROM</span>  Table_A  <span class="keyword">GROUP</span> <span class="keyword">BY</span> country;</span><br></pre></td></tr></table></figure><p>(3). 在Check中使用Case函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*公司A，这个公司有个规定，女职员的工资必须高于1000块*/</span></span><br><span class="line">CONSTRAINT check_salary <span class="keyword">CHECK</span></span><br><span class="line">( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">THEN</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary &gt; <span class="number">1000</span></span><br><span class="line"><span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="number">1</span> <span class="keyword">END</span> = <span class="number">1</span> )</span><br></pre></td></tr></table></figure><p>(4). 根据条件有选择的UPDATE</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1.工资5000以上的职员，工资减少10% */</span></span><br><span class="line"><span class="keyword">UPDATE</span> Personnel  <span class="keyword">SET</span> salary = salary * <span class="number">0.9</span>  <span class="keyword">WHERE</span> salary &gt;= <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.工资在2000到4600之间的职员，工资增加15% */</span></span><br><span class="line"><span class="keyword">UPDATE</span> Personnel  <span class="keyword">SET</span> salary = salary * <span class="number">1.15</span> <span class="keyword">WHERE</span> salary &gt;= <span class="number">2000</span> <span class="keyword">AND</span> salary &lt; <span class="number">4600</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.如果满足条件1和条件2，顺序执行则会出现问题。</span></span><br><span class="line"><span class="comment">假设有个人工资5000块。首先，按照条件1，工资减少10%，变成工资4500。</span></span><br><span class="line"><span class="comment">接下来运行第二个SQL时候，因为这个人的工资是4500在2000到4600的范围之内，需增加15%，</span></span><br><span class="line"><span class="comment">最后这个人的工资结果是5175,不但没有减少，反而增加了。</span></span><br><span class="line"><span class="comment">如果要是反过来执行，那么工资4600的人相反会变成减少工资。 </span></span><br><span class="line"><span class="comment">这里用到case when 进行不同条件的更新*/</span></span><br><span class="line"><span class="keyword">UPDATE</span> Personnel</span><br><span class="line"><span class="keyword">SET</span> salary =</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary &gt;= <span class="number">5000</span>  　                <span class="keyword">THEN</span> salary * <span class="number">0.9</span></span><br><span class="line">     <span class="keyword">WHEN</span> salary &gt;= <span class="number">2000</span> <span class="keyword">AND</span> salary &lt; <span class="number">4600</span>  <span class="keyword">THEN</span> salary * <span class="number">1.15</span></span><br><span class="line"><span class="keyword">ELSE</span> salary <span class="keyword">END</span>;  <span class="comment">-- 这行else必须写，不写会导致不符合这两个条件的工资会变成NULL</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 把主键a和b相互交换 */</span></span><br><span class="line"><span class="keyword">UPDATE</span> SomeTable</span><br><span class="line"><span class="keyword">SET</span> p_key = <span class="keyword">CASE</span> <span class="keyword">WHEN</span> p_key = <span class="string">'a'</span>  <span class="keyword">THEN</span> <span class="string">'b'</span></span><br><span class="line"><span class="keyword">WHEN</span> p_key = <span class="string">'b'</span>  <span class="keyword">THEN</span> <span class="string">'a'</span>  <span class="keyword">ELSE</span> p_key <span class="keyword">END</span></span><br><span class="line"><span class="keyword">WHERE</span> p_key <span class="keyword">IN</span> (<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br></pre></td></tr></table></figure><ul><li>检查两个表数据是否一致</li></ul><blockquote><p>Case函数不同于DECODE函数。在Case函数中，可以使用BETWEEN,LIKE,IS NULL,IN,EXISTS等等。比如说使用IN,EXISTS，可以进行子查询，从而 实现更多的功能。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用IN的时候</span></span><br><span class="line"><span class="keyword">SELECT</span> keyCol,</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> keyCol <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> keyCol <span class="keyword">FROM</span> tbl_B )  <span class="keyword">THEN</span> <span class="string">'Matched'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'Unmatched'</span> <span class="keyword">END</span> Label</span><br><span class="line"><span class="keyword">FROM</span> tbl_A;</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用EXISTS的时候</span></span><br><span class="line"><span class="keyword">SELECT</span> keyCol,</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">EXISTS</span> ( <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_B  <span class="keyword">WHERE</span> tbl_A.keyCol = tbl_B.keyCol )  <span class="keyword">THEN</span> <span class="string">'Matched'</span>  <span class="keyword">ELSE</span> <span class="string">'Unmatched'</span> <span class="keyword">END</span> Label</span><br><span class="line"><span class="keyword">FROM</span> tbl_A;</span><br></pre></td></tr></table></figure><ul><li>在Case函数中使用合计函数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Studentclass</span></span><br><span class="line"><span class="comment">+------+----------+--------------+-----------------+</span></span><br><span class="line"><span class="comment">|std_id| class_id |  class_name  |  main_class_flg |</span></span><br><span class="line"><span class="comment">+------+----------+--------------+-----------------+</span></span><br><span class="line"><span class="comment">| 100  |    1     |     经济学    |        Y        |</span></span><br><span class="line"><span class="comment">| 100  |    2     |     历史学    |        N        |</span></span><br><span class="line"><span class="comment">| 200  |    2     |     历史学    |        N        |</span></span><br><span class="line"><span class="comment">| 200  |    3     |     考古学    |        Y        |</span></span><br><span class="line"><span class="comment">| 200  |    4     |     计算机    |        N        |</span></span><br><span class="line"><span class="comment">| 300  |    4     |     计算机    |        N        |</span></span><br><span class="line"><span class="comment">| 400  |    5     |      化学     |        N        |</span></span><br><span class="line"><span class="comment">| 500  |    6     |      数学     |        N        |</span></span><br><span class="line"><span class="comment">+------+----------+---------------+----------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--条件1：只选择了一门课程的学生, 返回那门课程的ID</span></span><br><span class="line"><span class="keyword">SELECT</span> std_id, <span class="keyword">MAX</span>(class_id) <span class="keyword">AS</span> main_class  <span class="keyword">FROM</span> Studentclass  <span class="keyword">GROUP</span> <span class="keyword">BY</span> std_id  <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--条件2：选择多门课程的学生, 返回所选的主课程ID</span></span><br><span class="line"><span class="keyword">SELECT</span> std_id, class_id <span class="keyword">AS</span> main_class  <span class="keyword">FROM</span> Studentclass  <span class="keyword">WHERE</span> main_class_flg = <span class="string">'Y'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用Case函数,满足以上两个条件</span></span><br><span class="line"><span class="keyword">SELECT</span>  std_id, </span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">COUNT</span>(*) = <span class="number">1</span>                   <span class="keyword">THEN</span> <span class="keyword">MAX</span>(class_id)</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> main_class_flg = <span class="string">'Y'</span>  <span class="keyword">THEN</span> class_id  <span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span>)</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> main_class</span><br><span class="line"><span class="keyword">FROM</span> Studentclass  <span class="keyword">GROUP</span> <span class="keyword">BY</span> std_id;</span><br></pre></td></tr></table></figure><ul><li>select case when</li></ul><blockquote><p>select 与 case结合使用最大的好处有两点，一是在显示查询结果时可以灵活的组织格式，二是有效避免了多次对同一个表或几个表的访问。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 例如表 students(id, name ,birthday, sex, grade)，要求按每个年级统计男生和女生的数量各是多少，统计结果的表头为，年级，男生数量，女生数量。如果不用select case when，为了将男女数量并列显示，统计起来非常麻烦，先确定年级信息，再根据年级取男生数和女生数，而且很容易出错。*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> grade, <span class="keyword">COUNT</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="number">1</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                            <span class="keyword">ELSE</span> <span class="literal">NULL</span></span><br><span class="line">                        <span class="keyword">END</span>) 男生数,</span><br><span class="line">               <span class="keyword">COUNT</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="number">2</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                            <span class="keyword">ELSE</span> <span class="literal">NULL</span></span><br><span class="line">                       <span class="keyword">END</span>) 女生数</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> grade;</span><br></pre></td></tr></table></figure><h1 id="Mysql数据库"><a href="#Mysql数据库" class="headerlink" title="Mysql数据库"></a>Mysql数据库</h1><h2 id="1-mysql-常用数据类型"><a href="#1-mysql-常用数据类型" class="headerlink" title="1. mysql 常用数据类型"></a>1. mysql 常用数据类型</h2><h2 id="2-mysql数据库引擎"><a href="#2-mysql数据库引擎" class="headerlink" title="2. mysql数据库引擎"></a>2. mysql数据库引擎</h2><h2 id="3-mysql的索引类型"><a href="#3-mysql的索引类型" class="headerlink" title="3. mysql的索引类型"></a>3. mysql的索引类型</h2><h2 id="4-Mysql-几种锁的区别"><a href="#4-Mysql-几种锁的区别" class="headerlink" title="4. Mysql 几种锁的区别"></a>4. Mysql 几种锁的区别</h2><h2 id="5-mysql事务原理、特性、事务并发控制"><a href="#5-mysql事务原理、特性、事务并发控制" class="headerlink" title="5. mysql事务原理、特性、事务并发控制"></a>5. mysql事务原理、特性、事务并发控制</h2><h1 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h1><h2 id="1-redis的原理"><a href="#1-redis的原理" class="headerlink" title="1. redis的原理"></a>1. redis的原理</h2><h2 id="2-持久化机制"><a href="#2-持久化机制" class="headerlink" title="2. 持久化机制"></a>2. 持久化机制</h2><h2 id="3-redis-和-memcached-的主要区别"><a href="#3-redis-和-memcached-的主要区别" class="headerlink" title="3. redis 和 memcached 的主要区别"></a>3. redis 和 memcached 的主要区别</h2><h2 id="4-Redis-高可用"><a href="#4-Redis-高可用" class="headerlink" title="4. Redis 高可用"></a>4. Redis 高可用</h2><h2 id="5-Redis-高并发"><a href="#5-Redis-高并发" class="headerlink" title="5. Redis 高并发"></a>5. Redis 高并发</h2><h1 id="MongoDB数据库"><a href="#MongoDB数据库" class="headerlink" title="MongoDB数据库"></a>MongoDB数据库</h1><h1 id="Hive数据库"><a href="#Hive数据库" class="headerlink" title="Hive数据库"></a>Hive数据库</h1><h1 id="Hbase数据库"><a href="#Hbase数据库" class="headerlink" title="Hbase数据库"></a>Hbase数据库</h1><h1 id="Hadoop生态"><a href="#Hadoop生态" class="headerlink" title="Hadoop生态"></a>Hadoop生态</h1>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要对数据库基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>数据结构知识点总结归纳</title>
    <link href="http://yoursite.com/2020/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2020-05-08T15:05:08.000Z</published>
    <updated>2020-05-13T17:36:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要对数据结构基础知识进行梳理、回顾，解析原理，并通过实际例子深刻理解。</p></blockquote><a id="more"></a><div style='display: none'><!-- TOC --><ul><li><a href="#数据结构">数据结构</a><ul><li><a href="#1-字符串string">1. 字符串(String)</a></li><li><a href="#2-数组array">2. 数组(Array)</a></li><li><a href="#3-堆heap">3. 堆(Heap)</a></li><li><a href="#4-栈stack">4. 栈(Stack)</a></li><li><a href="#5-队列queue">5. 队列(Queue)</a></li><li><a href="#6-链表linked-list">6. 链表(Linked-List)</a></li><li><a href="#7-树tree">7. 树(Tree)</a></li><li><a href="#8-图graph">8. 图(Graph)</a></li><li><a href="#9-哈希表hash">9. 哈希表(Hash)</a></li></ul></li></ul><!-- /TOC --></div><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="1-字符串-String"><a href="#1-字符串-String" class="headerlink" title="1. 字符串(String)"></a>1. 字符串(String)</h2><h2 id="2-数组-Array"><a href="#2-数组-Array" class="headerlink" title="2. 数组(Array)"></a>2. 数组(Array)</h2><h2 id="3-堆-Heap"><a href="#3-堆-Heap" class="headerlink" title="3. 堆(Heap)"></a>3. 堆(Heap)</h2><h2 id="4-栈-Stack"><a href="#4-栈-Stack" class="headerlink" title="4. 栈(Stack)"></a>4. 栈(Stack)</h2><h2 id="5-队列-Queue"><a href="#5-队列-Queue" class="headerlink" title="5. 队列(Queue)"></a>5. 队列(Queue)</h2><h2 id="6-链表-Linked-List"><a href="#6-链表-Linked-List" class="headerlink" title="6. 链表(Linked-List)"></a>6. 链表(Linked-List)</h2><h2 id="7-树-Tree"><a href="#7-树-Tree" class="headerlink" title="7. 树(Tree)"></a>7. 树(Tree)</h2><h2 id="8-图-Graph"><a href="#8-图-Graph" class="headerlink" title="8. 图(Graph)"></a>8. 图(Graph)</h2><h2 id="9-哈希表-Hash"><a href="#9-哈希表-Hash" class="headerlink" title="9. 哈希表(Hash)"></a>9. 哈希表(Hash)</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要对数据结构基础知识进行梳理、回顾，解析原理，并通过实际例子深刻理解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>机器学习知识点总结归纳</title>
    <link href="http://yoursite.com/2020/05/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2020/05/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/</id>
    <published>2020-05-08T15:05:08.000Z</published>
    <updated>2020-05-13T18:32:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要对机器学习基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。</p></blockquote><a id="more"></a><div style='display: none'><!-- TOC --><ul><li><a href="#1-机器学习基础">1 机器学习基础</a><ul><li><a href="#11-机器学习概述">1.1 机器学习概述</a></li><li><a href="#12-监督学习">1.2 监督学习</a></li><li><a href="#13-非监督学习">1.3 非监督学习</a></li><li><a href="#14-增强学习">1.4 增强学习</a></li><li><a href="#15-深度学习">1.5 深度学习</a></li></ul></li><li><a href="#2-分类问题">2 分类问题</a><ul><li><a href="#21-knn">2.1 KNN</a></li><li><a href="#22-nb">2.2 NB</a></li><li><a href="#23-svm">2.3 SVM</a></li><li><a href="#24-adaboost">2.4 AdaBoost</a></li><li><a href="#25-dt">2.5 DT</a></li></ul></li><li><a href="#3-聚类分析">3 聚类分析</a><ul><li><a href="#31-k-means">3.1 K-means</a></li><li><a href="#32-dbscan">3.2 DBSCAN</a></li><li><a href="#33-lda">3.3 LDA</a></li></ul></li><li><a href="#4-预测分析">4 预测分析</a><ul><li><a href="#41-时间序列">4.1 时间序列</a></li><li><a href="#42-bp神经网络">4.2 BP神经网络</a></li></ul></li><li><a href="#5-关联分析">5 关联分析</a><ul><li><a href="#51-apriori">5.1 Apriori</a></li><li><a href="#52-fp-growth">5.2 FP-Growth</a></li></ul></li><li><a href="#6-回归分析">6 回归分析</a><ul><li><a href="#61-一元回归">6.1 一元回归</a></li><li><a href="#62-多元回归">6.2 多元回归</a></li><li><a href="#63-逻辑回归">6.3 逻辑回归</a></li></ul></li><li><a href="#7-集成学习">7 集成学习</a><ul><li><a href="#71-bagging">7.1 Bagging</a></li><li><a href="#72-随机森林">7.2. 随机森林</a></li><li><a href="#73-boosting">7.3 Boosting</a></li><li><a href="#74-adaboost">7.4 AdaBoost</a></li></ul></li><li><a href="#8-深度学习">8 深度学习</a><ul><li><a href="#81-有监督">8.1 有监督</a></li><li><a href="#82-无监督">8.2 无监督</a></li><li><a href="#83-tensorflow">8.3 TensorFlow</a></li><li><a href="#84-theano">8.4 Theano</a></li></ul></li><li><a href="#9-数据预处理">9 数据预处理</a><ul><li><a href="#91-数据清洗">9.1 数据清洗</a><ul><li><a href="#911-异常值处理">9.1.1 异常值处理</a></li><li><a href="#912-缺失值处理">9.1.2 缺失值处理</a></li><li><a href="#913-噪声处理">9.1.3 噪声处理</a></li><li><a href="#914-倾斜数据处理">9.1.4 倾斜数据处理</a></li></ul></li><li><a href="#92-数据集成">9.2 数据集成</a></li><li><a href="#93-数据变换">9.3 数据变换</a></li><li><a href="#94-数据归约">9.4 数据归约</a></li></ul></li><li><a href="#10-数据降维">10 数据降维</a><ul><li><a href="#101-主成份分析">10.1 主成份分析</a></li><li><a href="#102-奇异值分解">10.2 奇异值分解</a></li></ul></li></ul><!-- /TOC --></div><h1 id="1-机器学习基础"><a href="#1-机器学习基础" class="headerlink" title="1 机器学习基础"></a>1 机器学习基础</h1><h2 id="1-1-机器学习概述"><a href="#1-1-机器学习概述" class="headerlink" title="1.1 机器学习概述"></a>1.1 机器学习概述</h2><h2 id="1-2-监督学习"><a href="#1-2-监督学习" class="headerlink" title="1.2 监督学习"></a>1.2 监督学习</h2><h2 id="1-3-非监督学习"><a href="#1-3-非监督学习" class="headerlink" title="1.3 非监督学习"></a>1.3 非监督学习</h2><h2 id="1-4-增强学习"><a href="#1-4-增强学习" class="headerlink" title="1.4 增强学习"></a>1.4 增强学习</h2><h2 id="1-5-深度学习"><a href="#1-5-深度学习" class="headerlink" title="1.5 深度学习"></a>1.5 深度学习</h2><h1 id="2-分类问题"><a href="#2-分类问题" class="headerlink" title="2 分类问题"></a>2 分类问题</h1><h2 id="2-1-KNN"><a href="#2-1-KNN" class="headerlink" title="2.1 KNN"></a>2.1 KNN</h2><h2 id="2-2-NB"><a href="#2-2-NB" class="headerlink" title="2.2 NB"></a>2.2 NB</h2><h2 id="2-3-SVM"><a href="#2-3-SVM" class="headerlink" title="2.3 SVM"></a>2.3 SVM</h2><h2 id="2-4-AdaBoost"><a href="#2-4-AdaBoost" class="headerlink" title="2.4 AdaBoost"></a>2.4 AdaBoost</h2><h2 id="2-5-DT"><a href="#2-5-DT" class="headerlink" title="2.5 DT"></a>2.5 DT</h2><h1 id="3-聚类分析"><a href="#3-聚类分析" class="headerlink" title="3 聚类分析"></a>3 聚类分析</h1><h2 id="3-1-K-means"><a href="#3-1-K-means" class="headerlink" title="3.1 K-means"></a>3.1 K-means</h2><h2 id="3-2-DBSCAN"><a href="#3-2-DBSCAN" class="headerlink" title="3.2 DBSCAN"></a>3.2 DBSCAN</h2><h2 id="3-3-LDA"><a href="#3-3-LDA" class="headerlink" title="3.3 LDA"></a>3.3 LDA</h2><h1 id="4-预测分析"><a href="#4-预测分析" class="headerlink" title="4 预测分析"></a>4 预测分析</h1><h2 id="4-1-时间序列"><a href="#4-1-时间序列" class="headerlink" title="4.1 时间序列"></a>4.1 时间序列</h2><h2 id="4-2-BP神经网络"><a href="#4-2-BP神经网络" class="headerlink" title="4.2 BP神经网络"></a>4.2 BP神经网络</h2><h1 id="5-关联分析"><a href="#5-关联分析" class="headerlink" title="5 关联分析"></a>5 关联分析</h1><h2 id="5-1-Apriori"><a href="#5-1-Apriori" class="headerlink" title="5.1 Apriori"></a>5.1 Apriori</h2><h2 id="5-2-FP-Growth"><a href="#5-2-FP-Growth" class="headerlink" title="5.2 FP-Growth"></a>5.2 FP-Growth</h2><h1 id="6-回归分析"><a href="#6-回归分析" class="headerlink" title="6 回归分析"></a>6 回归分析</h1><h2 id="6-1-一元回归"><a href="#6-1-一元回归" class="headerlink" title="6.1 一元回归"></a>6.1 一元回归</h2><h2 id="6-2-多元回归"><a href="#6-2-多元回归" class="headerlink" title="6.2 多元回归"></a>6.2 多元回归</h2><h2 id="6-3-逻辑回归"><a href="#6-3-逻辑回归" class="headerlink" title="6.3 逻辑回归"></a>6.3 逻辑回归</h2><h1 id="7-集成学习"><a href="#7-集成学习" class="headerlink" title="7 集成学习"></a>7 集成学习</h1><h2 id="7-1-Bagging"><a href="#7-1-Bagging" class="headerlink" title="7.1 Bagging"></a>7.1 Bagging</h2><h2 id="7-2-随机森林"><a href="#7-2-随机森林" class="headerlink" title="7.2. 随机森林"></a>7.2. 随机森林</h2><h2 id="7-3-Boosting"><a href="#7-3-Boosting" class="headerlink" title="7.3 Boosting"></a>7.3 Boosting</h2><h2 id="7-4-AdaBoost"><a href="#7-4-AdaBoost" class="headerlink" title="7.4 AdaBoost"></a>7.4 AdaBoost</h2><h1 id="8-深度学习"><a href="#8-深度学习" class="headerlink" title="8 深度学习"></a>8 深度学习</h1><h2 id="8-1-有监督"><a href="#8-1-有监督" class="headerlink" title="8.1 有监督"></a>8.1 有监督</h2><h2 id="8-2-无监督"><a href="#8-2-无监督" class="headerlink" title="8.2 无监督"></a>8.2 无监督</h2><h2 id="8-3-TensorFlow"><a href="#8-3-TensorFlow" class="headerlink" title="8.3 TensorFlow"></a>8.3 TensorFlow</h2><h2 id="8-4-Theano"><a href="#8-4-Theano" class="headerlink" title="8.4 Theano"></a>8.4 Theano</h2><h1 id="9-数据预处理"><a href="#9-数据预处理" class="headerlink" title="9 数据预处理"></a>9 数据预处理</h1><h2 id="9-1-数据清洗"><a href="#9-1-数据清洗" class="headerlink" title="9.1 数据清洗"></a>9.1 数据清洗</h2><h3 id="9-1-1-异常值处理"><a href="#9-1-1-异常值处理" class="headerlink" title="9.1.1 异常值处理"></a>9.1.1 异常值处理</h3><h3 id="9-1-2-缺失值处理"><a href="#9-1-2-缺失值处理" class="headerlink" title="9.1.2 缺失值处理"></a>9.1.2 缺失值处理</h3><h3 id="9-1-3-噪声处理"><a href="#9-1-3-噪声处理" class="headerlink" title="9.1.3 噪声处理"></a>9.1.3 噪声处理</h3><h3 id="9-1-4-倾斜数据处理"><a href="#9-1-4-倾斜数据处理" class="headerlink" title="9.1.4 倾斜数据处理"></a>9.1.4 倾斜数据处理</h3><h2 id="9-2-数据集成"><a href="#9-2-数据集成" class="headerlink" title="9.2 数据集成"></a>9.2 数据集成</h2><h2 id="9-3-数据变换"><a href="#9-3-数据变换" class="headerlink" title="9.3 数据变换"></a>9.3 数据变换</h2><h2 id="9-4-数据归约"><a href="#9-4-数据归约" class="headerlink" title="9.4 数据归约"></a>9.4 数据归约</h2><h1 id="10-数据降维"><a href="#10-数据降维" class="headerlink" title="10 数据降维"></a>10 数据降维</h1><h2 id="10-1-主成份分析"><a href="#10-1-主成份分析" class="headerlink" title="10.1 主成份分析"></a>10.1 主成份分析</h2><h2 id="10-2-奇异值分解"><a href="#10-2-奇异值分解" class="headerlink" title="10.2 奇异值分解"></a>10.2 奇异值分解</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要对机器学习基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="分类问题" scheme="http://yoursite.com/tags/%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    
      <category term="聚类分析" scheme="http://yoursite.com/tags/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/"/>
    
      <category term="预测分析" scheme="http://yoursite.com/tags/%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/"/>
    
      <category term="回归分析" scheme="http://yoursite.com/tags/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/"/>
    
      <category term="关联分析" scheme="http://yoursite.com/tags/%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/"/>
    
      <category term="集成学习" scheme="http://yoursite.com/tags/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>算法编程知识点总结归纳</title>
    <link href="http://yoursite.com/2020/05/08/%E7%AE%97%E6%B3%95%E4%B8%8E%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/05/08/%E7%AE%97%E6%B3%95%E4%B8%8E%E7%BC%96%E7%A8%8B/</id>
    <published>2020-05-08T15:05:08.000Z</published>
    <updated>2020-05-13T17:36:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要对算法编程基础知识进行梳理、回顾，以及一些常见的算法掌握。</p></blockquote><a id="more"></a><div style='display: none'><!-- TOC --><ul><li><a href="#算法编程">算法编程</a><ul><li><a href="#1-反转链表">1. 反转链表</a></li><li><a href="#2-dfs">2. DFS</a></li><li><a href="#3-bfs">3. BFS</a></li><li><a href="#4-冒泡排序">4. 冒泡排序</a></li><li><a href="#5-快排">5. 快排</a></li><li><a href="#6-堆排序">6. 堆排序</a></li><li><a href="#7-二叉树">7. 二叉树</a></li><li><a href="#8-二分查找">8. 二分查找</a></li><li><a href="#9-求最大树深">9. 求最大树深</a></li><li><a href="#10-动态规划问题">10. 动态规划问题</a></li><li><a href="#11-01背包问题">11. 01背包问题</a></li></ul></li></ul><!-- /TOC --></div><h1 id="算法编程"><a href="#算法编程" class="headerlink" title="算法编程"></a>算法编程</h1><h2 id="1-反转链表"><a href="#1-反转链表" class="headerlink" title="1. 反转链表"></a>1. 反转链表</h2><h2 id="2-DFS"><a href="#2-DFS" class="headerlink" title="2. DFS"></a>2. DFS</h2><h2 id="3-BFS"><a href="#3-BFS" class="headerlink" title="3. BFS"></a>3. BFS</h2><h2 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4. 冒泡排序"></a>4. 冒泡排序</h2><h2 id="5-快排"><a href="#5-快排" class="headerlink" title="5. 快排"></a>5. 快排</h2><h2 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h2><h2 id="7-二叉树"><a href="#7-二叉树" class="headerlink" title="7. 二叉树"></a>7. 二叉树</h2><h2 id="8-二分查找"><a href="#8-二分查找" class="headerlink" title="8. 二分查找"></a>8. 二分查找</h2><h2 id="9-求最大树深"><a href="#9-求最大树深" class="headerlink" title="9. 求最大树深"></a>9. 求最大树深</h2><h2 id="10-动态规划问题"><a href="#10-动态规划问题" class="headerlink" title="10. 动态规划问题"></a>10. 动态规划问题</h2><h2 id="11-01背包问题"><a href="#11-01背包问题" class="headerlink" title="11. 01背包问题"></a>11. 01背包问题</h2><h2 id="12-两个栈实现一个队列"><a href="#12-两个栈实现一个队列" class="headerlink" title="12. 两个栈实现一个队列"></a>12. 两个栈实现一个队列</h2><h2 id="13-二叉树的直径"><a href="#13-二叉树的直径" class="headerlink" title="13. 二叉树的直径"></a>13. 二叉树的直径</h2><h2 id="14-全排列"><a href="#14-全排列" class="headerlink" title="14. 全排列"></a>14. 全排列</h2><ul><li>itertools内置permutations方法实现</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            n = int(input().strip())</span><br><span class="line">            s = [str(i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">            res = list(permutations(s))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">                print(<span class="string">" "</span>.join(i))</span><br><span class="line">            print(len(res))</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    func()</span><br></pre></td></tr></table></figure><ul><li>递归实现</li></ul><p>具体详细的思路参考：</p><p><strong><a href="https://blog.csdn.net/weixin_39910711/article/details/100692318" target="_blank" rel="noopener">递归实现全排列（回溯思想）</a></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(s, begin, end)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    <span class="keyword">if</span> begin == end:</span><br><span class="line">        print(<span class="string">" "</span>.join(s))</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(begin, end):</span><br><span class="line">            s[i], s[begin] = s[begin], s[i]</span><br><span class="line">            permutations(s, begin + <span class="number">1</span>, end)</span><br><span class="line">            s[i], s[begin] = s[begin], s[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = [str(i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(int(input().strip()))]</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    permutations(s, <span class="number">0</span>, len(s))</span><br><span class="line">    print(count)</span><br></pre></td></tr></table></figure><ul><li>DFS实现</li></ul><p><strong><a href="https://blog.csdn.net/weixin_39910711/article/details/100692318" target="_blank" rel="noopener">深度优先搜索（DFS）实现全排列</a></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(s, position, visit, num)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> position == len(s):</span><br><span class="line">        print(<span class="string">" "</span>.join(num))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> visit[index] == <span class="literal">True</span>:</span><br><span class="line">                num[position] = s[index]</span><br><span class="line">                visit[index] = <span class="literal">False</span></span><br><span class="line">                permutations(s, position + <span class="number">1</span>, visit, num)</span><br><span class="line">                visit[index] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    n = int(input().strip())</span><br><span class="line">    s = [str(i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    visit = [<span class="literal">True</span>] * n</span><br><span class="line">    num = [<span class="string">""</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    permutations(s, <span class="number">0</span>, visit, num)</span><br></pre></td></tr></table></figure><h2 id="15-最大公约数"><a href="#15-最大公约数" class="headerlink" title="15. 最大公约数"></a>15. 最大公约数</h2><h2 id="16-最小公倍数"><a href="#16-最小公倍数" class="headerlink" title="16. 最小公倍数"></a>16. 最小公倍数</h2><p><strong><a href="https://blog.csdn.net/weixin_41980474/article/details/80139275" target="_blank" rel="noopener">最小公倍数</a></strong></p><h2 id="17-求素数"><a href="#17-求素数" class="headerlink" title="17. 求素数"></a>17. 求素数</h2><h2 id="18-求质数"><a href="#18-求质数" class="headerlink" title="18. 求质数"></a>18. 求质数</h2><h2 id="19-查并集"><a href="#19-查并集" class="headerlink" title="19. 查并集"></a>19. 查并集</h2><p><strong><a href="https://blog.csdn.net/guoziqing506/article/details/78752557" target="_blank" rel="noopener">并查集(Union-Find)算法详解</a></strong><br><strong><a href="https://blog.csdn.net/qq_41593380/article/details/81146850" target="_blank" rel="noopener">并查集详解</a></strong><br><strong><a href="https://blog.csdn.net/dm_vincent/article/details/7655764" target="_blank" rel="noopener">并查集(Union-Find)算法介绍</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要对算法编程基础知识进行梳理、回顾，以及一些常见的算法掌握。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法编程" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理知识点总结归纳</title>
    <link href="http://yoursite.com/2020/05/08/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/08/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/</id>
    <published>2020-05-08T15:05:08.000Z</published>
    <updated>2020-05-13T18:29:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要对自然语言处理基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。</p></blockquote><a id="more"></a><div style='display: none'><!-- TOC --><ul><li><a href="#1-情感分析">1. 情感分析</a></li><li><a href="#2-文本挖掘">2. 文本挖掘</a></li><li><a href="#3-语义分析">3. 语义分析</a></li></ul><!-- /TOC --></div><h2 id="1-情感分析"><a href="#1-情感分析" class="headerlink" title="1. 情感分析"></a>1. 情感分析</h2><h2 id="2-文本挖掘"><a href="#2-文本挖掘" class="headerlink" title="2. 文本挖掘"></a>2. 文本挖掘</h2><h2 id="3-语义分析"><a href="#3-语义分析" class="headerlink" title="3. 语义分析"></a>3. 语义分析</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要对自然语言处理基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
      <category term="情感分析" scheme="http://yoursite.com/tags/%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90/"/>
    
      <category term="文本分析" scheme="http://yoursite.com/tags/%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
